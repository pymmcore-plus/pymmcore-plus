from __future__ import annotations

import uuid
from contextlib import suppress
from datetime import datetime
from typing import TYPE_CHECKING, NamedTuple

import useq
from ome_types.model import (
    OME,
    Channel,
    Image,
    ImageRef,
    Instrument,
    Pixels,
    Pixels_DimensionOrder,
    PixelType,
    Plane,
    Plate,
    UnitsLength,
    UnitsTime,
    Well,
    WellSample,
)

from pymmcore_plus.mda._runner import GeneratorMDASequence

if TYPE_CHECKING:
    from pymmcore_plus.metadata.schema import ImageInfo

    from .schema import FrameMetaV1, SummaryMetaV1


def create_ome_metadata(
    summary_metadata: SummaryMetaV1, frame_metadata_list: list[FrameMetaV1]
) -> OME:
    """Create OME metadata from metadata saved as json by the core engine.

    The metadata path should contain two files, `summary_metadata.json` and
    `frames_metadata.jsonl`.

    Parameters
    ----------
    metadata_path : Path | str
        Path to the directory containing `summary_metadata.json` and
        `frames_metadata.jsonl` files generated by the core engine.

    Returns
    -------
    OME
        The OME metadata as an `ome_types.OME` object.
    """
    # create OME model
    ome = OME(uuid=f"urn:uuid:{uuid.uuid4()}")

    # get instrument information from summary metadata
    ome.instruments = _add_ome_instrument_info(summary_metadata)

    # get pixel size, image dimensions, and data type from image_infos
    if (
        not frame_metadata_list
        or (image_infos := summary_metadata["image_infos"]) is None
    ):
        return ome

    # cannot create Pixels without dtype
    dim_info = _get_dimension_info(image_infos)
    if dim_info.dtype is None:  # pragma: no cover
        return ome

    # get the MDA sequence if available
    sequence = _get_mda_sequence(summary_metadata, frame_metadata_list[0])

    # get mapping of {position_name -> list of FrameMeta} associated with that position
    # (handling 'g' axis if present)
    positions_map = _group_frames_by_position(frame_metadata_list)

    # get acquisition date from summary metadata
    acquisition_date = _get_acquisition_date(summary_metadata)

    # add OME Images, one per position
    ome.images = _get_ome_images(dim_info, sequence, positions_map, acquisition_date)

    # add plate information if available
    if (plate_plan := _get_plate_plan(sequence)) is not None:
        # create a mapping from position index to image ID
        position_to_image_id = _positions_to_image_ids(positions_map)
        ome.plates = [_get_ome_plate(plate_plan, position_to_image_id)]

    return ome


def _get_ome_images(
    dim_info: _DimInfo,
    sequence: useq.MDASequence | None,
    positions_map: dict[_PositionKey, list[FrameMetaV1]],
    acquisition_date: datetime | None,
) -> list[Image]:
    """Create OME Images from grouped frame metadata by position."""
    images = []
    for pkey, position_frames in positions_map.items():
        image_id = pkey.image_id
        position_key = str(pkey)

        if sequence is None or isinstance(sequence, GeneratorMDASequence):
            dimension_order = Pixels_DimensionOrder.XYTCZ
        else:
            dimension_order = _get_dimension_order_from_sequence(sequence)

        if not dimension_order:  # pragma: no cover
            # cannot create Pixels without dimension order
            continue

        if sequence is None or isinstance(sequence, GeneratorMDASequence):
            (max_t, max_z, max_c), channels = _get_ome_pixels_info_from_frames(
                position_frames, image_id
            )
        else:
            (max_t, max_z, max_c), channels = _get_ome_pixels_info_from_sequence(
                sequence, image_id
            )

        from ome_types.model import MetadataOnly

        pixels = Pixels(
            id=f"Pixels:{image_id}",
            dimension_order=Pixels_DimensionOrder(dimension_order),
            size_x=dim_info.width,
            size_y=dim_info.height,
            size_z=max(max_z, 1),
            size_c=max(max_c, 1),
            size_t=max(max_t, 1),
            type=PixelType(dim_info.dtype),
            physical_size_x=dim_info.pixel_size_um,
            physical_size_x_unit=UnitsLength.MICROMETER,
            physical_size_y=dim_info.pixel_size_um,
            physical_size_y_unit=UnitsLength.MICROMETER,
            channels=channels,
            metadata_only=MetadataOnly(),
            planes=_get_ome_planes(position_frames),
        )

        image = Image(
            acquisition_date=acquisition_date,
            id=f"Image:{image_id}",
            name=position_key,
            pixels=pixels,
        )
        images.append(image)
    return images


def _get_plate_plan(
    sequence: useq.MDASequence | None,
) -> useq.WellPlatePlan | None:
    """Return the plate plan from the MDA sequence if it exists."""
    if sequence is None:  # pragma: no cover
        return None
    if (stage_pos := sequence.stage_positions) is not None and isinstance(
        stage_pos, useq.WellPlatePlan
    ):
        return stage_pos
    return None


def _positions_to_image_ids(
    positions_map: dict[_PositionKey, list[FrameMetaV1]],
) -> dict[int, str]:
    """Create a mapping from position index to image ID."""
    position_to_image_id: dict[int, str] = {}

    for key, position_frames in positions_map.items():
        # extract position index from the first frame
        if position_frames:
            mda_event = _get_mda_event(position_frames[0])
            if mda_event is not None:
                pos_index = mda_event.index.get("p", 0)
                position_to_image_id[pos_index] = key.image_id
    return position_to_image_id


def _get_mda_sequence(
    summary_metadata: SummaryMetaV1, single_frame_metadata: FrameMetaV1
) -> useq.MDASequence | None:
    """Get the MDA sequence from summary metadata or frame metadata."""
    # get the mda_sequence from summary metadata
    seq = summary_metadata.get("mda_sequence")
    if seq is not None:
        return useq.MDASequence.model_validate(seq)

    # if is not there try form single_frame_metadata useq.MDAEvent
    ev = _get_mda_event(single_frame_metadata)
    if ev is None:
        return None
    return ev.sequence


def _get_ome_plate(
    plate_plan: useq.WellPlatePlan, position_to_image_id: dict[int, str]
) -> Plate:
    """Create a Plate object from a useq.WellPlatePlan."""
    wells: list[Well] = []

    # create a mapping from well name to acquisition indices
    well_acquisition_map: dict[str, list[int]] = {}
    for acquisition_index, position in enumerate(plate_plan.image_positions):
        well_name = position.name
        if well_name is not None:
            if well_name not in well_acquisition_map:
                well_acquisition_map[well_name] = []
            well_acquisition_map[well_name].append(acquisition_index)

    for (row, col), name, pos in zip(
        plate_plan.selected_well_indices,
        plate_plan.selected_well_names,
        plate_plan.selected_well_positions,
    ):
        # get all acquisition indices for this well
        acquisition_indices = well_acquisition_map.get(name, [])

        # create WellSample objects for each acquisition in this well
        well_samples = []
        for acq_index in acquisition_indices:
            # Use the actual image ID from the mapping
            image_id = position_to_image_id.get(acq_index, str(acq_index))
            well_samples.append(
                WellSample(
                    id=f"WellSample:{acq_index}",
                    position_x=pos.x,
                    position_y=pos.y,
                    position_x_unit=UnitsLength.MICROMETER,
                    position_y_unit=UnitsLength.MICROMETER,
                    index=acq_index,
                    image_ref=ImageRef(id=f"Image:{image_id}"),
                )
            )

        wells.append(
            Well(
                row=row,
                column=col,
                well_samples=well_samples,
            )
        )

    return Plate(
        name=plate_plan.plate.name,
        rows=plate_plan.plate.rows,
        columns=plate_plan.plate.columns,
        wells=wells,
        well_origin_x=plate_plan.a1_center_xy[0],
        well_origin_x_unit=UnitsLength.MICROMETER,
        well_origin_y=plate_plan.a1_center_xy[1],
        well_origin_y_unit=UnitsLength.MICROMETER,
    )


def _add_ome_instrument_info(summary_meta: SummaryMetaV1) -> list[Instrument]:
    """Add instrument information to the OME model based on summary metadata."""
    # TODO: use devices to get info about microscope
    # create instrument information

    # instrument = None
    # microscope_device = None
    # camera_device = None

    # devices = summary_meta[DEVICES]
    # for device in devices:
    #     if ...
    #        microscope_device = ...
    #     if ...

    # if microscope_device:
    #     microscope = Microscope(
    #             manufacturer=microscope_device.get("description", "Unknown"),
    #             model="Micro-Manager System",
    #         )
    #     instrument = Instrument(
    #         id="Instrument:0",
    #         microscope=microscope,
    #     )
    #     ome.instruments.append(instrument)
    # ...
    return []


class _DimInfo(NamedTuple):
    pixel_size_um: float
    dtype: str | None
    height: int
    width: int


def _get_dimension_info(
    image_infos: tuple[ImageInfo, ...],
) -> _DimInfo:
    """Extract pixel size (Âµm), data type, width, and height from image_infos."""
    pixel_size_um = 1.0
    dtype: str | None = None
    width = height = 0
    if image_infos and (img_info := image_infos[0]):
        pixel_size_um = img_info.get("pixel_size_um", 1.0)
        dtype = img_info.get("dtype")
        width, height = img_info.get("width", 0), img_info.get("height", 0)
    return _DimInfo(pixel_size_um, dtype, height, width)


def _get_acquisition_date(summary_metadata: SummaryMetaV1) -> datetime | None:
    acquisition_date = None
    if (acq_time := summary_metadata.get("datetime")) is not None:
        with suppress(ValueError, AttributeError):
            # parse ISO format datetime string
            acquisition_date = datetime.fromisoformat(acq_time.replace("Z", "+00:00"))
    return acquisition_date


class _PositionKey(NamedTuple):
    name: str | None
    p_index: int
    g_index: int | None = None

    def __str__(self) -> str:
        p_name = self.name or f"Pos{self.p_index:04d}"
        if self.g_index is not None:
            return f"{p_name}_Grid{self.g_index:04d}_{self.p_index}_{self.g_index}"
        else:
            return f"{p_name}_{self.p_index}"

    @property
    def image_id(self) -> str:
        if self.g_index is not None:
            return f"{self.p_index}_{self.g_index}"
        return f"{self.p_index}"


def _group_frames_by_position(
    frame_metadata_list: list[FrameMetaV1],
) -> dict[_PositionKey, list[FrameMetaV1]]:
    """Reorganize frame metadata by stage position index in a dictionary.

    Handles the 'g' axis (grid) by converting it to separate positions,
    since OME doesn't support the 'g' axis. Each grid position becomes
    a separate OME Image with names like "Pos0000_Grid0000".

    Returns
    -------
    dict[str, list[FrameMetaV1]]
        mapping of position identifier (e.g. 'Pos0000_Grid0000')
        to list of `FrameMetaV1`.
    """
    frames_by_position: dict[_PositionKey, list[FrameMetaV1]] = {}
    for frame_meta in frame_metadata_list:
        mda_event = _get_mda_event(frame_meta)
        if mda_event is None:  # pragma: no cover
            continue

        p_index = mda_event.index.get(useq.Axis.POSITION, 0) or 0
        g_index = mda_event.index.get(useq.Axis.GRID, None)

        # get position name from event or generate default
        key = _PositionKey(mda_event.pos_name, p_index, g_index)
        pos_list = frames_by_position.setdefault(key, [])
        pos_list.append(frame_meta)
    return frames_by_position


def _get_mda_event(frame_meta: FrameMetaV1) -> useq.MDAEvent | None:
    """Retrieve the useq.MDAEvent from frame metadata."""
    if (mda_event := frame_meta.get("mda_event")) is not None:
        return useq.MDAEvent.model_validate(mda_event)
    return None  # pragma: no cover


def _get_ome_pixels_info_from_frames(
    pos_metadata: list[FrameMetaV1],
    image_id: str,
) -> tuple[tuple[int, int, int], list[Channel]]:
    """Get the position information from position metadata.

    Returns
    -------
        A tuple containing the maximum (t, z, c) indices, and a list of channels.
    """
    max_t, max_z, max_c = 0, 0, 0
    channels: dict[int, Channel] = {}

    for frame_meta in pos_metadata:
        mda_event = _get_mda_event(frame_meta)
        if mda_event is None:  # pragma: no cover
            continue

        # get indices with single dictionary lookups
        t_idx = mda_event.index.get("t", 0)
        z_idx = mda_event.index.get("z", 0)
        c_idx = mda_event.index.get("c", 0)

        max_t = max(max_t, t_idx)
        max_z = max(max_z, z_idx)
        max_c = max(max_c, c_idx)

        # create channel if not exists - use image_id to make globally unique
        if c_idx not in channels and (ch := mda_event.channel) is not None:
            channels[c_idx] = Channel(
                id=f"Channel:{image_id}:{c_idx}",
                name=ch.config,
                samples_per_pixel=1,
            )

    # convert to sorted list by channel index
    sorted_channels = [channels[i] for i in sorted(channels.keys())]
    return (max_t + 1, max_z + 1, max_c + 1), sorted_channels


def _get_ome_pixels_info_from_sequence(
    sequence: useq.MDASequence,
    image_id: str,
) -> tuple[tuple[int, int, int], list[Channel]]:
    """Get the position information from a useq.MDASequence."""
    max_t = sequence.sizes.get("t", 1)
    max_z = sequence.sizes.get("z", 1)
    channels = [
        Channel(
            id=f"Channel:{image_id}:{idx}",
            name=ch.config,
            samples_per_pixel=1,
        )
        for idx, ch in enumerate(sequence.channels)
    ]
    return (max_t, max_z, len(channels)), channels


def _get_ome_planes(position_frames: list[FrameMetaV1]) -> list[Plane]:
    """Create Plane objects for a list of frame metadata at a specific position."""
    planes = []
    for frame_meta in position_frames:
        mda_event = _get_mda_event(frame_meta)
        if mda_event is None:  # pragma: no cover
            continue

        # get indices
        event_index = mda_event.index
        z_idx = event_index.get("z", 0)
        c_idx = event_index.get("c", 0)
        t_idx = event_index.get("t", 0)

        # get time delta
        runner_time_ms = frame_meta.get("runner_time_ms", 0.0)
        delta_t = runner_time_ms / 1000.0 if runner_time_ms > 0 else None

        # get exposure time
        exposure_ms = frame_meta.get("exposure_ms", 0.0)

        plane = Plane(
            the_z=z_idx,
            the_c=c_idx,
            the_t=t_idx,
            position_x=mda_event.x_pos,
            position_x_unit=UnitsLength.MICROMETER,
            position_y=mda_event.y_pos,
            position_y_unit=UnitsLength.MICROMETER,
            position_z=mda_event.z_pos,
            position_z_unit=UnitsLength.MICROMETER,
            delta_t=delta_t,
            delta_t_unit=UnitsTime.SECOND,
            exposure_time=exposure_ms,
            exposure_time_unit=UnitsTime.MILLISECOND,
        )

        planes.append(plane)
    return planes


def _get_dimension_order_from_sequence(
    sequence: useq.MDASequence,
) -> Pixels_DimensionOrder:
    """
    Get axis order (fastest -> slowest) from a useq.MDASequence.

    Returns
    -------
    A string representing the dimension order compatible with OME standards
    (e.g., "XYCZT").
    """
    ordered_axes = [ax for ax in sequence.axis_order if ax not in {"p", "g"}]
    dimension_order = "XY" + "".join(ordered_axes[::1]).upper()
    # if there are axis missing, add them
    if len(dimension_order) != 5:
        missing = [a for a in "XYCZT" if a not in dimension_order]
        dimension_order += "".join(missing)
    return Pixels_DimensionOrder(dimension_order)
