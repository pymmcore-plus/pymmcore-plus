"""Logic for reading and writing MMCore config files."""
from __future__ import annotations

import datetime
import warnings
from typing import TYPE_CHECKING, Any, Callable, Iterable, Sequence

from pymmcore_plus import CFGCommand, DeviceType, FocusDirection, Keyword
from pymmcore_plus.model import (
    DEFAULT_AFFINE,
    ConfigGroup,
    ConfigPreset,
    Device,
    Microscope,
    PixelSizePreset,
    Setting,
)

if TYPE_CHECKING:
    import io
    from typing import TypeAlias

    Executor: TypeAlias = Callable[[Microscope, Sequence[str]], None]

__all__ = ["load_from_string", "dump"]


def load_from_string(text: str, scope: Microscope | None = None) -> Microscope:
    """Load the Microscope from a string."""
    if scope is None:
        scope = Microscope()
    scope.reset()
    for line in text.splitlines():
        line = line.strip()
        if not line or line.startswith("#"):
            continue

        run_command(line, scope)
    return scope


def dump(scope: Microscope, str_io: io.TextIOBase) -> None:
    for header, lines in CONFIG_SECTIONS.items():
        str_io.write(f"# {header}\n")
        for line in lines(scope):
            str_io.write(line + "\n")
        str_io.write("\n")


# ------------------ Serialization ------------------


def _serialize(*args: Any) -> str:
    """Return a config string for the given args."""
    return CFGCommand.FieldDelimiters.join(map(str, args))


RESET = _serialize(CFGCommand.Property, Keyword.CoreDevice, Keyword.CoreInitialize, 0)
INIT = _serialize(CFGCommand.Property, Keyword.CoreDevice, Keyword.CoreInitialize, 1)


def yield_date(scope: Microscope) -> Iterable[str]:
    now = datetime.datetime.now(datetime.timezone.utc)
    date = now.astimezone().strftime("%a %b %d %H:%M:%S %Z %Y")
    yield f"# Date: {date}\n"


def iter_devices(scope: Microscope) -> Iterable[str]:
    for d in scope.devices:
        if d.device_type != DeviceType.Core:
            yield _serialize(CFGCommand.Device, d.name, d.library, d.adapter_name)


def iter_pre_init_props(scope: Microscope) -> Iterable[str]:
    for d in scope.devices:
        if d.device_type != DeviceType.Core:
            for p in d.pre_init_props():
                yield _serialize(CFGCommand.Property, p.device_name, p.name, p.value)


def iter_hub_refs(scope: Microscope) -> Iterable[str]:
    for d in scope.devices:
        if d.device_type != DeviceType.Core and d.parent_name:
            yield _serialize(CFGCommand.ParentID, d.name, d.parent_name)


def iter_delays(scope: Microscope) -> Iterable[str]:
    for d in scope.devices:
        if d.device_type != DeviceType.Core and d.delay_ms:
            yield _serialize(CFGCommand.Delay, d.name, d.delay_ms)


def iter_focus_directions(scope: Microscope) -> Iterable[str]:
    for d in scope.devices:
        if d.device_type == DeviceType.Stage:
            yield _serialize(CFGCommand.FocusDirection, d.name, d.focus_direction.value)


def iter_roles(scope: Microscope) -> Iterable[str]:
    for field in (
        Keyword.CoreCamera,
        Keyword.CoreShutter,
        Keyword.CoreFocus,
        Keyword.CoreAutoShutter,
    ):
        if p := scope.core_device.find_property(field):
            yield _serialize(CFGCommand.Property, p.device_name, p.name, p.value)


def iter_labels(scope: Microscope) -> Iterable[str]:
    for d in scope.devices:
        if d.device_type == DeviceType.State and d.labels:
            yield f"# {d.name}"
            for state, label in d.labels.items():
                yield _serialize(CFGCommand.Label, d.name, state, label)


def iter_config_presets(scope: Microscope) -> Iterable[str]:
    for group in scope.config_groups.values():
        yield f"# Group: {group.name}"
        for preset in group.presets.values():
            yield f"# Preset: {preset.name}"
            for s in preset.settings:
                yield _serialize(CFGCommand.ConfigGroup, group.name, preset.name, *s)


def iter_pixel_size_presets(scope: Microscope) -> Iterable[str]:
    pixels = scope.pixel_size_group
    for p in pixels.presets.values():
        yield f"# Resolution preset: {p.name}"
        for setting in p.settings:
            yield _serialize(CFGCommand.ConfigPixelSize, p.name, *setting)
        yield _serialize(CFGCommand.PixelSize_um, p.name, p.pixel_size_um)
        if p.affine_transform != DEFAULT_AFFINE:
            yield _serialize(CFGCommand.PixelSizeAffine, p.name, *p.affine_transform)


# Order will determine the order of the sections in the file
CONFIG_SECTIONS: dict[str, Callable[[Microscope], Iterable[str]]] = {
    "Generated by pymmcore-plus": yield_date,
    "Reset": lambda _: [RESET],
    "Devices": iter_devices,
    "Pre-init settings for devices": iter_pre_init_props,
    "Pre-init settings for COM ports": lambda _: [],
    "Hub (parent) references": iter_hub_refs,
    "Initialize": lambda _: [INIT],
    "Delays": iter_delays,
    "Focus directions": iter_focus_directions,
    "Roles": iter_roles,
    "Camera-synchronized devices": lambda _: [],
    "Labels": iter_labels,
    "Configuration presets": iter_config_presets,
    "PixelSize settings": iter_pixel_size_presets,
}

# ------------------ Deserialization ------------------

# TODO: ... I think the command subclasses are probably overkill here.
# could just use a map of command name to function


def run_command(line: str, scope: Microscope) -> None:
    """Apply a line of a config file to a scope model instance."""
    try:
        cmd_name, *args = line.split(CFGCommand.FieldDelimiters)
    except ValueError:
        raise ValueError(f"Invalid config line: {line!r}") from None

    try:
        command = CFGCommand(cmd_name)
    except ValueError as exc:
        raise ValueError(f"Invalid command name: {cmd_name!r}") from exc

    if command not in COMMAND_EXECUTORS:
        warnings.warn(
            f"Command {cmd_name!r} not implemented", RuntimeWarning, stacklevel=2
        )
        return

    exec_cmd, expected_n_args = COMMAND_EXECUTORS[command]

    if (nargs := len(args) + 1) not in expected_n_args:
        exp_str = " or ".join(map(str, expected_n_args))
        raise ValueError(
            f"Invalid configuration line encountered for command {cmd_name}. "
            f"Expected {exp_str} arguments, got {nargs}: {line!r}"
        )

    try:
        exec_cmd(scope, args)
    except Exception as exc:
        raise ValueError(f"Error executing command {line!r}: {exc}") from exc


def _exec_Device(scope: Microscope, args: Sequence[str]) -> None:
    """Load a device from the available devices."""
    # TODO: add description from available devices
    name, library, adapter_name = args
    dev = Device(name=name, library=library, adapter_name=adapter_name)
    scope.devices.append(dev)


def _exec_Property(scope: Microscope, args: Sequence[str]) -> None:
    device_name, prop_name, *_value = args
    value = _value[0] if _value else ""
    if device_name == Keyword.CoreDevice and prop_name == Keyword.CoreInitialize:
        try:
            scope.initialized = bool(int(value))
        except (ValueError, TypeError):
            raise ValueError(f"Value {value!r} is not an integer") from None
        return

    dev = scope.find_device(device_name)
    prop = dev.set_prop_default(prop_name, value, pre_init=not scope.initialized)
    prop.value = value


def _exec_Label(scope: Microscope, args: Sequence[str]) -> None:
    device_name, state, label = args
    dev = scope.find_device(device_name)
    dev.device_type = DeviceType.State
    try:
        state_int = int(state)
    except (ValueError, TypeError):
        raise ValueError(f"State {state} is not an integer") from None
    dev.labels[state_int] = label


def _exec_ConfigGroup(scope: Microscope, args: Sequence[str]) -> None:
    group_name, preset_name, device_name, prop_name, value = args
    cg = scope.config_groups.setdefault(group_name, ConfigGroup(name=group_name))
    preset = cg.presets.setdefault(preset_name, ConfigPreset(name=preset_name))
    preset.settings.append(Setting(device_name, prop_name, value))


def _exec_ConfigPixelSize(scope: Microscope, args: Sequence[str]) -> None:
    # NOTE: this is quite similar to _cmd_config_group... maybe refactor?
    preset_name, device_name, prop_name, value = args
    cg = scope.pixel_size_group
    preset = cg.presets.setdefault(preset_name, PixelSizePreset(name=preset_name))
    preset.settings.append(Setting(device_name, prop_name, value))


def _exec_PixelSize_um(scope: Microscope, args: Sequence[str]) -> None:
    preset_name, value = args
    try:
        preset = scope.pixel_size_group.presets[preset_name]
    except KeyError:
        raise ValueError(f"Pixel size preset {preset_name!r} not found") from None

    try:
        preset.pixel_size_um = float(value)
    except ValueError as exc:
        raise ValueError(f"Invalid pixel size: {value}. Expected a float.") from exc


def _exec_PixelSizeAffine(scope: Microscope, args: Sequence[str]) -> None:
    preset_name, *tform = args
    try:
        preset = scope.pixel_size_group.presets[preset_name]
    except KeyError:
        raise ValueError(f"Pixel size preset {preset_name!r} not found") from None

    # TODO: I think zero args is also a valid value for the affine transform
    if len(tform) != 6:
        raise ValueError(f"Expected 6 values for affine transform, got {len(tform)}")

    try:
        preset.affine_transform = tuple(float(v) for v in tform)
    except ValueError as exc:
        raise ValueError(
            f"Invalid affine transform: {tform!r}. Expected 6 floats."
        ) from exc


def _exec_ParentID(scope: Microscope, args: Sequence[str]) -> None:
    device_name, parent_name = args
    dev = scope.find_device(device_name)
    dev.parent_name = parent_name
    dev.device_type = DeviceType.Hub
    try:
        scope.find_device(parent_name)
    except ValueError:
        warnings.warn(
            f"Parent hub {parent_name!r} not found for device {device_name!r}",
            RuntimeWarning,
            stacklevel=2,
        )


def _exec_Delay(scope: Microscope, args: Sequence[str]) -> None:
    device_name, delay_ms = args
    dev = scope.find_device(device_name)
    try:
        dev.delay_ms = float(delay_ms)
    except ValueError as exc:
        raise ValueError(f"Invalid delay: {delay_ms!r}. Expected a float.") from exc


def _exec_FocusDirection(scope: Microscope, args: Sequence[str]) -> None:
    device_name, direction = args
    dev = scope.find_device(device_name)
    dev.device_type = DeviceType.Stage
    try:
        dev.focus_direction = FocusDirection(int(direction))
    except (ValueError, TypeError):
        raise ValueError(f"{direction} is not a valid FocusDirection") from None


# expected_nargs INCLUDES the command itself
# e.g. Property,Core,Initialize,1 => 4 args
#                         command -> (executor, expected_n_args)
COMMAND_EXECUTORS: dict[CFGCommand, tuple[Executor, set[int]]] = {
    CFGCommand.Device: (_exec_Device, {4}),
    CFGCommand.Label: (_exec_Label, {4}),
    CFGCommand.Property: (_exec_Property, {3, 4}),
    CFGCommand.ConfigGroup: (_exec_ConfigGroup, {5, 6}),
    CFGCommand.Delay: (_exec_Delay, {3}),
    CFGCommand.ConfigPixelSize: (_exec_ConfigPixelSize, {5}),
    CFGCommand.PixelSize_um: (_exec_PixelSize_um, {3}),
    CFGCommand.PixelSizeAffine: (_exec_PixelSizeAffine, {8}),
    CFGCommand.ParentID: (_exec_ParentID, {3}),
    CFGCommand.FocusDirection: (_exec_FocusDirection, {3}),
}
