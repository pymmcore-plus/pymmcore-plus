"""Logic for reading and writing MMCore config files."""
import datetime
import io
import warnings
from typing import Any, Callable, ClassVar, Iterable

from pymmcore_plus import CFGCommand, DeviceType, FocusDirection, Keyword
from pymmcore_plus.model import (
    DEFAULT_AFFINE,
    ConfigGroup,
    ConfigPreset,
    Device,
    Microscope,
    PixelSizePreset,
    Setting,
    StageDevice,
    StateDevice,
)

__all__ = ["load_from_string", "dump"]


def load_from_string(text: str, scope: Microscope | None = None) -> Microscope:
    """Load the Microscope from a string."""
    if scope is None:
        scope = Microscope()
    scope.reset()
    for line in text.splitlines():
        line = line.strip()
        if not line or line.startswith("#"):
            continue

        Command.apply(line, scope)
    return scope


def dump(scope: Microscope, str_io: io.TextIOBase) -> None:
    for header, lines in CONFIG_SECTIONS.items():
        str_io.write(f"# {header}\n")
        for line in lines(scope):
            str_io.write(line + "\n")
        str_io.write("\n")


# ------------------ Serialization ------------------


def _cfg_field(*args: Any) -> str:
    """Return a config string for the given args."""
    return CFGCommand.FieldDelimiters.join(map(str, args))


RESET = _cfg_field(CFGCommand.Property, Keyword.CoreDevice, Keyword.CoreInitialize, 0)
INIT = _cfg_field(CFGCommand.Property, Keyword.CoreDevice, Keyword.CoreInitialize, 1)


def yield_date(scope: Microscope) -> Iterable[str]:
    now = datetime.datetime.now(datetime.timezone.utc)
    date = now.astimezone().strftime("%a %b %d %H:%M:%S %Z %Y")
    yield f"# Date: {date}\n"


def iter_devices(scope: Microscope) -> Iterable[str]:
    for d in scope.devices:
        if d.type != DeviceType.Core:
            yield CFGCommand.Device.serialize(d.name, d.library, d.adapter_name)


def iter_pre_init_props(scope: Microscope) -> Iterable[str]:
    for d in scope.devices:
        if d.type != DeviceType.Core:
            for p in d.pre_init_props():
                yield CFGCommand.Property.serialize(p.device, p.name, p.value)


def iter_hub_refs(scope: Microscope) -> Iterable[str]:
    for d in scope.devices:
        if d.type != DeviceType.Core and d.parent_name:
            yield CFGCommand.ParentID.serialize(d.name, d.parent_name)


def iter_delays(scope: Microscope) -> Iterable[str]:
    for d in scope.devices:
        if d.type != DeviceType.Core and d.delay_ms:
            yield CFGCommand.Delay.serialize(d.name, d.delay_ms)


def iter_focus_directions(scope: Microscope) -> Iterable[str]:
    for d in scope.devices:
        if isinstance(d, StageDevice):
            yield CFGCommand.FocusDirection.serialize(d.name, d.focus_direction.value)


def iter_roles(scope: Microscope) -> Iterable[str]:
    for field in (
        Keyword.CoreCamera,
        Keyword.CoreShutter,
        Keyword.CoreFocus,
        Keyword.CoreAutoShutter,
    ):
        if p := scope.core.find_property(field):
            yield CFGCommand.Property.serialize(p.device, p.name, p.value)


def iter_labels(scope: Microscope) -> Iterable[str]:
    for d in scope.devices:
        if isinstance(d, StateDevice) and d.labels:
            yield f"# {d.name}"
            for state, label in d.labels.items():
                yield CFGCommand.Label.serialize(d.name, state, label)


def iter_config_presets(scope: Microscope) -> Iterable[str]:
    for group in scope.config_groups.values():
        yield f"# Group: {group.name}"
        for preset in group.presets.values():
            yield f"# Preset: {preset.name}"
            for s in preset.settings:
                yield CFGCommand.ConfigGroup.serialize(group.name, preset.name, *s)


def iter_pixel_size_presets(scope: Microscope) -> Iterable[str]:
    pixels = scope.pixel_size_group
    for p in pixels.presets.values():
        yield f"# Resolution preset: {p.name}"
        for setting in p.settings:
            yield CFGCommand.ConfigPixelSize.serialize(p.name, *setting)
        yield CFGCommand.PixelSize_um.serialize(p.name, p.pixel_size_um)
        if p.affine_transform != DEFAULT_AFFINE:
            yield CFGCommand.PixelSizeAffine.serialize(p.name, *p.affine_transform)


# Order will determine the order of the sections in the file
CONFIG_SECTIONS: dict[str, Callable[[Microscope], Iterable[str]]] = {
    "Generated by pymmcore-plus": yield_date,
    "Reset": lambda _: [RESET],
    "Devices": iter_devices,
    "Pre-init settings for devices": iter_pre_init_props,
    "Pre-init settings for COM ports": lambda _: [],
    "Hub (parent) references": iter_hub_refs,
    "Initialize": lambda _: [INIT],
    "Delays": iter_delays,
    "Focus directions": iter_focus_directions,
    "Roles": iter_roles,
    "Camera-synchronized devices": lambda _: [],
    "Labels": iter_labels,
    "Configuration presets": iter_config_presets,
    "PixelSize settings": iter_pixel_size_presets,
}

# ------------------ Deserialization ------------------

# TODO: ... I think the command subclasses are probably overkill here.
# could just use a map of command name to function


class Command:
    command: ClassVar[CFGCommand]
    _SUBS: ClassVar[dict[CFGCommand, type["Command"]]] = {}

    def __init_subclass__(cls) -> None:
        cls._SUBS[cls.command] = cls

    @staticmethod
    def exec(scope: Microscope, *args: Any) -> None:
        """Load the command into the config."""
        raise NotImplementedError

    @classmethod
    def apply(cls, line: str, scope: Microscope) -> None:
        """Apply a line of a config file to a scope model instance."""
        try:
            cmd_name, *args = line.split(CFGCommand.FieldDelimiters)
        except ValueError:
            raise ValueError(f"Invalid config line: {line!r}") from None

        try:
            command = CFGCommand(cmd_name)
        except ValueError as exc:
            raise ValueError(f"Invalid command name: {cmd_name!r}") from exc

        try:
            SubCommand = cls._SUBS[command]
        except KeyError:
            warnings.warn(
                f"Command {cmd_name!r} not implemented", RuntimeWarning, stacklevel=2
            )
            return

        nargs = len(args) + 1  # +1 for the command itself
        if nargs not in (exp := SubCommand.command.expected_args()):
            exp_str = " or ".join(str(n) for n in exp)
            raise ValueError(
                f"Invalid configuration line encountered for command {cmd_name}. "
                f"Expected {exp_str} arguments, got {nargs}: {line!r}"
            )

        try:
            SubCommand.exec(scope, *args)
        except Exception as exc:
            raise ValueError(f"Error executing command {line!r}: {exc}") from exc


class DeviceCommand(Command):
    command = CFGCommand.Device

    @staticmethod
    def exec(  # type: ignore[override]
        scope: Microscope, name: str, library: str, adapter_name: str
    ) -> None:
        """Load a device from the available devices."""
        # TODO: add description from available devices
        dev = Device(name=name, library=library, adapter_name=adapter_name)
        scope.devices.append(dev)


class PropertyCommand(Command):
    command = CFGCommand.Property

    @staticmethod
    def exec(  # type: ignore[override]
        scope: Microscope, device_name: str, prop_name: str, value: str = ""
    ) -> None:
        if device_name == Keyword.CoreDevice and prop_name == Keyword.CoreInitialize:
            try:
                scope.initialized = bool(int(value))
            except (ValueError, TypeError):
                raise ValueError(f"Value {value!r} is not an integer") from None
            return

        dev = scope.find_device(device_name)
        prop = dev.set_default_prop(prop_name, value, pre_init=not scope.initialized)
        prop.value = value


class LabelCommand(Command):
    command = CFGCommand.Label

    @staticmethod
    def exec(  # type: ignore[override]
        scope: Microscope, device_name: str, state: str, label: str
    ) -> None:
        dev = scope.find_device(device_name)
        if not isinstance(dev, StateDevice):
            scope.devices[scope.devices.index(dev)] = dev = StateDevice.from_device(dev)

        try:
            state_int = int(state)
        except (ValueError, TypeError):
            raise ValueError(f"State {state} is not an integer") from None
        dev.labels[state_int] = label


class ConfigGroupCommand(Command):
    command = CFGCommand.ConfigGroup

    @staticmethod
    def exec(  # type: ignore[override]
        scope: Microscope,
        group_name: str,
        preset_name: str,
        device_name: str,
        prop_name: str,
        value: str = "",
    ) -> None:
        cg = scope.config_groups.setdefault(group_name, ConfigGroup(name=group_name))
        preset = cg.presets.setdefault(preset_name, ConfigPreset(name=preset_name))
        preset.settings.append(Setting(device_name, prop_name, value))


class ConfigPixelSizeCommand(Command):
    command = CFGCommand.ConfigPixelSize

    @staticmethod
    def exec(  # type: ignore[override]
        scope: Microscope,
        preset_name: str,
        device_name: str,
        prop_name: str,
        value: str = "",
    ) -> None:
        # NOTE: this is quite similar to _cmd_config_group... maybe refactor?
        cg = scope.pixel_size_group
        preset = cg.presets.setdefault(preset_name, PixelSizePreset(name=preset_name))
        preset.settings.append(Setting(device_name, prop_name, value))


class PixelSize_umCommand(Command):
    command = CFGCommand.PixelSize_um

    @staticmethod
    def exec(  # type: ignore[override]
        scope: Microscope, preset_name: str, value: str
    ) -> None:
        try:
            preset = scope.pixel_size_group.presets[preset_name]
        except KeyError:
            raise ValueError(f"Pixel size preset {preset_name!r} not found") from None

        try:
            preset.pixel_size_um = float(value)
        except ValueError as exc:
            raise ValueError(f"Invalid pixel size: {value}. Expected a float.") from exc


class PixelSizeAffineCommand(Command):
    command = CFGCommand.PixelSizeAffine

    @staticmethod
    def exec(  # type: ignore[override]
        scope: Microscope, preset_name: str, *tform: float
    ) -> None:
        try:
            preset = scope.pixel_size_group.presets[preset_name]
        except KeyError:
            raise ValueError(f"Pixel size preset {preset_name!r} not found") from None

        # TODO: I think zero args is also a valid value for the affine transform
        if len(tform) != 6:
            raise ValueError(
                f"Expected 6 values for affine transform, got {len(tform)}"
            )

        try:
            preset.affine_transform = tuple(float(v) for v in tform)
        except ValueError as exc:
            raise ValueError(
                f"Invalid affine transform: {tform!r}. Expected 6 floats."
            ) from exc


class ParentIDCommand(Command):
    command = CFGCommand.ParentID

    @staticmethod
    def exec(  # type: ignore[override]
        scope: Microscope, device_name: str, parent_name: str
    ) -> None:
        dev = scope.find_device(device_name)
        dev.parent_name = parent_name


class DelayCommand(Command):
    command = CFGCommand.Delay

    @staticmethod
    def exec(  # type: ignore[override]
        scope: Microscope, device_name: str, delay_ms: str
    ) -> None:
        dev = scope.find_device(device_name)
        try:
            dev.delay_ms = float(delay_ms)
        except ValueError as exc:
            raise ValueError(f"Invalid delay: {delay_ms!r}. Expected a float.") from exc


class FocusDirectionCommand(Command):
    command = CFGCommand.FocusDirection

    @staticmethod
    def exec(  # type: ignore[override]
        scope: Microscope, device_name: str, direction: str
    ) -> None:
        dev = scope.find_device(device_name)
        if not isinstance(dev, StageDevice):
            scope.devices[scope.devices.index(dev)] = dev = StageDevice.from_device(dev)

        try:
            dev.focus_direction = FocusDirection(int(direction))
        except (ValueError, TypeError):
            raise ValueError(f"{direction} is not a valid FocusDirection") from None
