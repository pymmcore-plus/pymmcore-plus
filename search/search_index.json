{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Overview","text":"<p><code>pymmcore-plus</code> aims to extend pymmcore (python bindings for the C++ micro-manager core) with a number of features designed to facilitate working with Micro-manager in pure python/C environments.</p> <ul> <li> <p><code>pymmcore-plus</code> itself is a superset of   <code>pymmcore</code> (python bindings   for Micro-manager's C++ <code>CMMCore</code>). <code>pymmcore_plus.CMMCorePlus</code> (the main object in this library)   aims to be a drop-in replacement for <code>pymmcore.CMMCore</code>, while adding a number   of additional features including:</p> <ul> <li>A multi-dimensional acquisition engine   implemented in pure python. (The existing acquisition engines in   Micro-manager are written in Java and Clojure).</li> <li>More flexible event connections and callback handling.</li> <li>Extended convenience APIs for working with core (which would be hard or   impossible to implement in the <code>pymmcore</code> SWIG wrapper).</li> <li>More pythonic APIs for various pymmcore objects (e.g. <code>pymmcore_plus.Device</code>,   <code>pymmcore_plus.Configuration</code>) and constants.</li> </ul> </li> <li> <p><code>pymmcore-widgets</code> is a     Qt-based widget library built on     <code>pymmcore-plus</code> that provides GUI elements for     most of the device and acquisition functionality of <code>pymmcore</code>.  It     allows users to build their own custom GUIs for Micro-manager.</p> </li> <li><code>napari-micromanager</code>     is a plugin for the napari image viewer that composes     <code>pymmcore-plus</code> and <code>pymmcore-widgets</code> to provide a full GUI for     Micro-manager that is integrated with the napari viewer.</li> </ul> <p>How is pymmcore-plus different than Pycro-Manager?</p> <p>A common question about <code>pymmcore-plus</code> and related libraries is how it differs from Pycro-Manager, another python library written by Henry Pinkard for working with Micro-manager.</p> <p>The two projects are not mutually exclusive! They aim to support different use cases</p> <p>The primary difference is that Pycro-Manager controls Micro-manager via a ZMQ-based connection to a remote Java process in which the Micro-manager GUI is running (or a headless Java process if the GUI is not running). The Java process in turn communicates with the C++ core driving the hardware.</p> <p><code>pymmcore-plus</code> aims to remove the need for a Java process by communicating directly with the C++ core (via the <code>pymmcore</code> library), and re-implementing any necessary event-based or GUI-based functionality in pure python or C.</p> <p>A major advantage of Pycro-Manager is that you get the entire Java-based micro-manager ecosystem, including the GUI and plugins. A potential disadvantage (depending on your needs), is that it requires a Java runtime environment and cross-process communication.</p> <p>If you are looking to control a microscope via python without any need for Java or interprocess communication, <code>pymmcore(-plus)</code> may help. Note however, that you will be sacrificing the MMStudio GUI! See <code>pymmcore-widgets</code> and <code>napari-micromanager</code>, and <code>pymmcore-gui</code> for ongoing efforts to implement a complete python-based GUI for Micro-manager.</p> <p></p>"},{"location":"#quickstart","title":"Quickstart","text":""},{"location":"#install","title":"Install","text":"<p>Install with <code>pip</code> or <code>conda</code>:</p> <pre><code>pip install pymmcore-plus\n\n# OR, to include the `mmcore` command line tool\npip install \"pymmcore-plus[cli]\"\n\n# OR\nconda install -c conda-forge pymmcore-plus\n</code></pre> <p>You will also need the micro-manager device adapters on your system. To get them quickly, assuming you have installed with <code>pymmcore-plus[cli]</code>, you can run:</p> <pre><code>mmcore install\n</code></pre> <p>See install for more details.</p>"},{"location":"#usage","title":"Usage","text":"<p>The main object is <code>pymmcore_plus.CMMCorePlus</code>, which is an enhanced subclass of <code>pymmcore.CMMCore</code>:</p> <pre><code>from pymmcore_plus import CMMCorePlus\n\n# instantiate as you would pymmcore.CMMCore\nmmc = CMMCorePlus()\n# OR: use the global singleton\n# mmc = CMMCorePlus.instance()\n\n# without arguments, this will load the demo config\nmmc.loadSystemConfiguration()\n</code></pre> <p>See the <code>CMMCorePlus</code> API documentation for details on the additional features of <code>CMMCorePlus</code>.</p> <p><code>CMMCorePlus.instance</code></p> <p>Creating/accessing a <code>CMMCorePlus</code> object using <code>CMMCorePlus.instance()</code> is a convenient way to access the same core instance from multiple places in your code. All widgets in <code>pymmcore-widgets</code> also use <code>CMMCorePlus.instance()</code> by default, so any widgets you use will automatically connect to the same core instance without any additional configuration.</p> <p>Attempts are made to make it thread-safe.  But please open an issue if you find any problems.</p> <p>While you can easily use <code>pymmcore-plus</code> from a script or IPython/Jupyter you can also use it in combination with the napari based gui napari-micromanager. See using with napari-micromanager for an example of how to use them together.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>We welcome contributions to <code>pymmcore-plus</code> and related libraries.  Please see contributing for more information.</p>"},{"location":"cli/","title":"CLI Reference","text":"<p>This page provides documentation for the <code>mmcore</code> command line tool.</p> <p>Usage of the CLI requires the <code>cli</code> extra to be installed:</p> <pre><code>pip install \"pymmcore_plus[cli]\"\n</code></pre> <p>The CLI can be used to interact with the <code>pymmcore_plus</code> package from the command line, including the installation, removal, and selection of micro-manager drivers, as well as executing an experiment and/or showing log files.</p>"},{"location":"cli/#mmcore","title":"mmcore","text":"<p>mmcore: pymmcore-plus command line.</p> <p>For additional help on a specific command: type <code>mmcore [command] --help</code></p> <p>Usage:</p> <pre><code>mmcore [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> <pre><code>  --version             Show version and exit.\n  --install-completion  Install completion for the current shell.\n  --show-completion     Show completion for the current shell, to copy it or\n                        customize the installation.\n</code></pre>"},{"location":"cli/#bench","title":"bench","text":"<p>Run a benchmark of Core and Devices loaded with <code>config</code> (or Demo).</p> <p>Usage:</p> <pre><code>mmcore bench [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  -c, --config FILE     Path to Micro-Manager system configuration file.\n  -n, --number INTEGER  Number of iterations for each test.  [default: 10]\n</code></pre>"},{"location":"cli/#build-dev","title":"build-dev","text":"<p>Build Micro-Manager device adapters from the git repo.</p> <p>Currently only supports macos and linux.</p> <p>Usage:</p> <pre><code>mmcore build-dev [OPTIONS] [DEVICES]...\n</code></pre> <p>Options:</p> <pre><code>  [DEVICES]...          Device adapters to build. Defaults to ['DemoCamera',\n                        'Utilities', 'SequenceTester']\n  -d, --dest DIRECTORY  Installation directory.  [default:\n                        /home/runner/.local/share/pymmcore-plus/mm]\n  -y                    Overwrite existing if git sha is already built. If not\n                        specified, will prompt.\n</code></pre>"},{"location":"cli/#clean","title":"clean","text":"<p>Remove all Micro-Manager installs downloaded by pymmcore-plus.</p> <p>Usage:</p> <pre><code>mmcore clean [OPTIONS] [GLOB]\n</code></pre> <p>Options:</p> <pre><code>  [GLOB]  glob pattern to clean  [default: *]\n</code></pre>"},{"location":"cli/#info","title":"info","text":"<p>Display information about the Micro-Manager and pymmcore install.</p> <p>Usage:</p> <pre><code>mmcore info [OPTIONS]\n</code></pre>"},{"location":"cli/#install","title":"install","text":"<p>Install Micro-Manager Device adapters from https://download.micro-manager.org.</p> <p>Usage:</p> <pre><code>mmcore install [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  -d, --dest DIRECTORY  Installation directory.  [default:\n                        /home/runner/.local/share/pymmcore-plus/mm]\n  -r, --release TEXT    Release date. e.g. 20210201  [default: latest-\n                        compatible]\n  --plain-output        Do not use rich output. Useful for scripting.\n  --test-adapters       Install only test adapters (e.g. DemoCamera and others\n                        for testing).\n</code></pre>"},{"location":"cli/#list","title":"list","text":"<p>Show all discovered Micro-Manager installations.</p> <p>Usage:</p> <pre><code>mmcore list [OPTIONS]\n</code></pre>"},{"location":"cli/#logs","title":"logs","text":"<p>Display recent output from pymmcore-plus log.</p> <p>Usage:</p> <pre><code>mmcore logs [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  -n, --num INTEGER  Number of lines to display.\n  -t, --tail         Continually stream logs.\n  -c, --clear        Delete all log files.\n  --reveal           Reveal log file in Explorer/Finder.\n</code></pre>"},{"location":"cli/#mmstudio","title":"mmstudio","text":"<p>Run the Java Micro-Manager GUI.</p> <p>This command will attempt to locate an execute an ImageJ application found in the active Micro-Manager directory.</p> <p>Usage:</p> <pre><code>mmcore mmstudio [OPTIONS]\n</code></pre>"},{"location":"cli/#run","title":"run","text":"<p>Run a Micro-Manager acquisition from a useq-schema MDASequence file.</p> <p>Usage:</p> <pre><code>mmcore run [OPTIONS] [USEQ]\n</code></pre> <p>Options:</p> <pre><code>  [USEQ]                    Path to useq-schema file.\n  -c, --config FILE         Path to Micro-Manager system configuration file.\n  --z-go-up / --no-z-go-up  Acquire from bottom to top.\n  --z-top FLOAT             Top of z-stack.\n  --z-bottom FLOAT          Bottom of z-stack.\n  --z-range FLOAT           Symmetric range of z-stack around position.\n  --z-above FLOAT           Asymmetric range of z-stack above position.\n  --z-below FLOAT           Asymmetric range of z-stack below position.\n  --z-step FLOAT            Step size of z-stack.\n  -zr FLOAT                 Relative z-positions to acquire (may use multiple\n                            times).\n  -za FLOAT                 Absolute z-positions to acquire (may use multiple\n                            times).\n  --t-interval FLOAT        Interval between timepoints.\n  --t-duration FLOAT        Duration of time lapse.\n  --t-loops FLOAT           Number of time points to acquire.\n  --dry-run / --no-dry-run  Do not run the acquisition.  [default: no-dry-run]\n  --axis-order TEXT         Order of axes to acquire (e.g. 'TPCZ').\n  --channel TEXT            Channel to acquire. Argument is a string of the\n                            following form:  - name: \"DAPI\"  -\n                            name;exposure: \"DAPI;0.5\"  - useq-schema JSON:\n                            '{\"config\": \"DAPI\", \"exposure\": 0.5, \"z_offset\":\n                            0.5}'\n  --channel-group TEXT      Name of Micro-Manager configuration group for\n                            channels.  [default: Channel]\n</code></pre>"},{"location":"cli/#use","title":"use","text":"<p>Change the currently used Micro-manager version/path.</p> <p>Usage:</p> <pre><code>mmcore use [OPTIONS] PATTERN\n</code></pre> <p>Options:</p> <pre><code>  PATTERN  Path to an existing directory, or pattern to match against\n           installations found by `mmcore list`  [required]\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<p>Thanks for thinking of a way to help improve this library! Remember that contributions come in all shapes and sizes beyond writing bug fixes. Contributing to documentation, opening new issues for bugs, asking for clarification on things you find unclear, and requesting new features, are all super valuable contributions.</p>"},{"location":"contributing/#contributing-code","title":"Contributing Code","text":"<p>All development for this library happens in the pymmcore-plus/pymmcore-plus  repo on GitHub. We recommend you work with uv, but any virtual environment manager should work.</p> <p>Using <code>uv</code>:</p> <pre><code>git clone &lt;your fork&gt;\ncd pymmcore-plus\nuv sync\npre-commit install\n</code></pre> <pre><code>uv run pytest \n</code></pre> <p>or activate the virtual environment (<code>source .venv/bin/activate</code> on Linux/macOS, <code>.venv\\Scripts\\activate</code> on Windows) and run:</p> <pre><code>pytest\n</code></pre> <p>If using a different virtual environment manager (like conda) instead of uv, you can install the dependencies with:</p> <pre><code>pip install -e . --group dev\n</code></pre> <p>This requires a newer version of <code>pip</code> (&gt;= 25.1) to work.</p>"},{"location":"contributing/#contributing-documentation","title":"Contributing Documentation","text":"<p>Our documentation is built with mkdocs from the files in the <code>docs</code> folder.  To build docs locally:</p> <pre><code># build docs and serve locally\nuv run --group docs mkdocs serve\n</code></pre> <p>The docs should be live at http://127.0.0.1:8000 and will update automatically as you edit and save them.</p>"},{"location":"contributing/#developing-on-apple-silicon","title":"Developing on Apple Silicon","text":"<p>To build a native version of the DemoCamera for local testing on apple silicon, you can run the following command (you must have homebrew installed)</p> <pre><code>uv run mmcore build-dev\n</code></pre> <p>This will download the micro-manager repo, build it, and drop the DemoCamera and Utilities devices into a folder in your pymmcore-plus install folder (by default <code>~/Library/Application Support/pymmcore-plus/mm</code>).  This path is on the default search path so you should be good to go.  You can confirm by running:</p> <pre><code>from pymmcore_plus import CMMCorePlus\n\ncore = CMMCorePlus()\ncore.loadSystemConfiguration()\ncore.snap()\n</code></pre>"},{"location":"env_var/","title":"Environment Variables","text":"<p>The following environment variables may be used to configure pymmcore-plus globally.</p> <p>Boolean variables can be set to <code>1</code>, <code>0</code>, <code>True</code>, or <code>False</code> (case insensitive).</p> Variable Description Default <code>PYMM_DEBUG_LOG</code> Call <code>enableDebugLog(True)</code> when initializing a <code>CMMCore</code>. <code>PYMM_STDERR_LOG</code> Call <code>enableStderrLog(True)</code> when initializing a <code>CMMCore</code>. <code>PYMM_BUFFER_SIZE_MB</code> Circular buffer memory footprint in MB. 250 MB <code>PYMM_STRICT_INIT_CHECKS</code> Enable/disable strict initialization checks Enabled <code>PYMM_PARALLEL_INIT</code> Enable/disable parallel device initialization Enabled <code>PYMM_LOG_LEVEL</code> pymmcore-plus logging level. <code>'INFO'</code> <code>PYMM_LOG_FILE</code> Logfile location. <code>pymmcore_plus.log</code> in the pymmcore-plus log directory <code>MICROMANAGER_PATH</code> Override location of Micro-Manager directory (with device adapters) User-directory, described here <code>PYMM_SIGNALS_BACKEND</code> The event backend to use. Must be one of <code>'qt'</code>, <code>'psygnal'</code>, or <code>'auto'</code> <code>auto</code> (Qt if <code>QApplication</code> exists, otherwise psygnal) <code>PYMM_DISABLE_IPYTHON_COMPLETIONS</code> Disable Tab autocompletion for IPython <code>\"0\"</code>  (enabled)"},{"location":"install/","title":"Install","text":""},{"location":"install/#installing-pymmcore-plus","title":"Installing pymmcore-plus","text":"<p><code>pymmcore-plus</code> can be installed with pip:</p> <pre><code>pip install pymmcore-plus\n</code></pre> <p>or with conda:</p> <pre><code>conda install -c conda-forge pymmcore-plus\n</code></pre> <p>... and then proceed to the next section to learn about device adapters.</p>"},{"location":"install/#installing-micro-manager-device-adapters","title":"Installing Micro-Manager Device Adapters","text":"<p>Just like the underlying <code>pymmcore</code> library, <code>pymmcore-plus</code> also relies on the device adapters and C++ core provided by mmCoreAndDevices. They can be installed in two ways:</p> <ol> <li> <p>Use the <code>mmcore</code> command line tool</p> <p>This library provides a quick way to install the latest version of micro-manager:</p> <pre><code>mmcore install\n</code></pre> <p>This will download the latest release of micro-manager and, by default, place it in a <code>pymmcore-plus\\mm</code> folder in the user's data directory (e.g. <code>C:\\Users\\UserName\\AppData\\Local\\pymmcore-plus\\mm</code>). If you would like to modify the location of the installation, or the release of micro-manager to install, you can use the <code>--dest</code> and <code>--release</code> flags respectively.</p> <p>For more information on the <code>install</code> command, run:</p> <pre><code>mmcore install --help\n</code></pre> <p>To explore all the <code>mmcore</code> command line tool functionalities, run:</p> <pre><code>mmcore --help\n</code></pre> </li> <li> <p>Download manually from micro-manager.org</p> <p>Go to the micro-manager downloads page and download the latest release for your Operating System.</p> </li> </ol> <p>Critical</p> <p>The device interface version MUST match between <code>pymmcore</code> and the Micro-Manager device adapters. See below</p>"},{"location":"install/#show-the-currently-used-micro-manager-installation","title":"Show the currently used Micro-Manager installation","text":"<p>To see which micro-manager installation <code>pymmcore-plus</code> is using, you can run:</p> <pre><code>mmcore list\n</code></pre> <p>or, if you didn't install with the <code>cli</code> extra, you can use <code>find_micromanager</code>:</p> <pre><code>python -c \"from pymmcore_plus import find_micromanager; print(find_micromanager())\"\n</code></pre>"},{"location":"install/#set-the-active-micro-manager-installation","title":"Set the active Micro-Manager installation","text":"<p>By default, <code>pymmcore-plus</code> will look for a <code>Micro-Manager</code> folder in the default install location. On Windows this is <code>C:\\Program Files\\</code>, on macOS it is <code>/Applications/</code> and on Linux it is <code>/usr/local/lib/</code>. To override these default device adapter search path, set the <code>MICROMANAGER_PATH</code> environment variable</p> <pre><code>export MICROMANAGER_PATH=/path/to/installation\n</code></pre> <p>If you want to permanently set the Micro-Manager installation path that <code>pymmcore-plus</code> uses, you can use the <code>mmcore use</code> command:</p> <pre><code>mmcore use &lt;some path or pattern&gt;\n</code></pre> <p>... where <code>&lt;some path or pattern&gt;</code> is either a path to an existing directory (containing micro-manager device adapters) or a pattern to match against directories returned by <code>find_micromanager</code>.</p> <p>Alternatively, you can use the <code>use_micromanager</code> function, passing either a path to an existing directory, or a pattern to match against directories returned by <code>find_micromanager</code>:</p> <pre><code>python -c \"from pymmcore_plus import use_micromanager; use_micromanager(path=..., pattern=...)\"\n</code></pre>"},{"location":"install/#on-linux","title":"On Linux","text":"<p>On a linux based system the easiest approach is to just install the C++ core of micromanager, mmCoreAndDevices. To do that follow the build instructions in the micro-manager repo.</p>"},{"location":"install/#understanding-device-interface-versions","title":"Understanding Device Interface Versions","text":"<p>Micro-Manager's C++ layer (called MMCore) controls devices via adapters that are compiled into platform-specific shared libraries.  These libraries are always compiled to work with a specific \"device interface version\" expected by the MMCore object itself.  If you try to load a device adapter with a device interface version that does not match the version expected by the core, then you will get an error.</p> <p>pymmcore is a library that wraps the C++ code and makes it available to python.  It has a 5-number version string that looks something like <code>11.1.1.71.2</code>.  The first three parts (here: <code>11.1.1</code>) represent the version of the MMCore library.  The next number (here: <code>71</code>) is the device interface version that pymmcore expects.  (The last number is a pymmcore-specific build number).  To query version information of your installed libraries you can run:</p> <pre><code>mmcore --version\n</code></pre> <p>Critical</p> <p>You must use device adapter libraries that were compiled for the same device interface version as your version of pymmcore.</p> <p>By default, when you run <code>mmcore install</code>, it will pick the latest compatible version to install. However, you can also do this explicitly.  For the example above, for a device interface version of <code>71</code>, you could explicitly install the last compatible device adapters listed on the table below with <code>mmcore install</code> as follows:</p> <pre><code>mmcore install -r 20250310\n</code></pre> <p>Here is a list of the latest device interface numbers, the date of the first nightly build where they were available, the last nightly build date to support that version, and the commit in mmCoreAndDevices that bumped the version.</p> Version Release Date Last Release Commit 75 20260226 3c6312ac5 74 20250815 20260225 7e9f2f214 73 20250318 20250814 55863b2d8 72 20250318 20250318 b8de737b2 71 20221031 20250310 7ba63fb8f 70 20210219 20221030 8687ddb51 69 20180712 1a9938168 68 20171107 285a9fbb2 67 20160609 2cafb3481 Older versions Version Release Date Commit 66 20160608 6378720c9 65 20150528 b98858d3b 64 20150515 6fdcdc274 63 20150505 ae4ced454 62 20150501 38cfde8ef 61 20140801 aac034a5c 60 20140618 cff69f1c2 59 20140515 1a3c3c884 58 20140514 b3781c0a9 57 20140125 97beb0f6c 56 20140120 bbf1b852c 55 20131221 d9d939aed 54 20131022 0058a1202 53 20121108 34329bb10 52 20120925 feeeff5d0 51 20120117 c62cd71df 50 20120117 121dea472 49 20111026 0f999b4f7 48 20111010 5407292c4 47 20110916 de02aa524 46 20110915 f886a5a60 45 20110722 3de97a552 44 20110721 adffbed3c 43 20110721 f1fa3260c 42 20110720 70d420b79 41 20110626 6f1e9e3c7 40 20110526 c9c4f901b 39 20110411 d6cf30e11 38 20110324 5fb856c6d 39 20110322 aca92c283 38 20101224 3327c6083 37 20101221 63e284ccf 36 20100920 7b180c4ef 35 20100823 41603ae0c 34 20100202 5bd9a38d5 28 20080911 ecdc3ffe9 27 20080806 644297085 26 20080604 99fd3cd80 16 20070412 38ebafde1 15 20070405 18ec4b48b 14 20070227 3b69e7670"},{"location":"metadata/","title":"Metadata Schema","text":"<p>This page defines the schema for the metadata <code>dicts</code> emitted during the course of an Multi-dimensional Acquisition (MDA).</p> <p>These are not classes (and should not be imported outside of a <code>typing.TYPE_CHECKING</code> clause), but rather are <code>typing.TypedDict</code> definitions that outline the structure of objects that are passed to the <code>sequenceStarted</code> and <code>frameReady</code> callbacks in an MDA.  One use case for these definitions is to provide type hints for the arguments to these callbacks, which is both handy for looking up the structure of the metadata and for static type checking.</p> <p></p>"},{"location":"metadata/#primary-metadata-types","title":"Primary Metadata Types","text":""},{"location":"metadata/#pymmcore_plus.metadata.SummaryMetaV1","title":"<code>pymmcore_plus.metadata.SummaryMetaV1</code>","text":"<p>Complete summary metadata for the system.</p> <p>This is the structure of the summary metadata object that is emitted during the <code>sequenceStarted</code> event of an MDA run.  It contains general information about the system and all of the devices.</p> <p>It may be generated outside of a running mda sequence as well using <code>pymmcore_plus.metadata.summary_metadata</code></p> <p>Keys:</p> Name Type Description <code>format</code> <code>Literal['summary-dict']</code> <p>The format of this summary metadata object.</p> <code>version</code> <code>Literal['1.0']</code> <p>The version of this summary metadata object.</p> <code>datetime</code> <code>str</code> <p>The date and time when the summary metadata was generated. This is an ISO 8601 formatted string, including date, time and offset from UTC: <code>YYYY-MM-DD HH:MM:SS.mmmmmm+HH:MM</code></p> <code>devices</code> <code>tuple[DeviceInfo, ...]</code> <p>Information about all loaded devices.</p> <code>system_info</code> <code>SystemInfo</code> <p>General system information.</p> <code>image_infos</code> <code>tuple[ImageInfo, ...]</code> <p>Information about the current image structure.</p> <code>config_groups</code> <code>tuple[ConfigGroup, ...]</code> <p>Groups of device property settings.</p> <code>pixel_size_configs</code> <code>tuple[PixelSizeConfigPreset, ...]</code> <p>Pixel size presets.</p> <code>position</code> <code>Position</code> <p>Current position in 3D space.</p> <code>mda_sequence</code> <code>useq.MDASequence</code> <p>NotRequired. The current MDA sequence.</p> <code>extra</code> <code>dict[str, Any]</code> <p>NotRequired. Additional information, may be used to store arbitrary user info.</p>"},{"location":"metadata/#pymmcore_plus.metadata.FrameMetaV1","title":"<code>pymmcore_plus.metadata.FrameMetaV1</code>","text":"<p>Metadata for a single frame.</p> <p>This is the structure of the summary metadata object that is emitted during the <code>frameReady</code> event of an MDA run.  It contains information about the frame that was just acquired. By design, it is relatively lightweight and does not contain the full system state. Values that are not expected to change during an MDA sequence should be looked up in the summary metadata.</p> <p>It may be generated outside of a running mda sequence as well using <code>pymmcore_plus.metadata.frame_metadata</code></p> <p>Keys:</p> Name Type Description <code>format</code> <code>Literal['frame-dict']</code> <p>The format of this frame metadata object.</p> <code>version</code> <code>Literal['1.0']</code> <p>The version of this frame metadata object.</p> <code>pixel_size_um</code> <code>float</code> <p>The pixel size in microns.</p> <code>camera_device</code> <code>str</code> <p>The label of the camera device used to acquire the image.</p> <code>exposure_ms</code> <code>float</code> <p>The exposure time in milliseconds.</p> <code>property_values</code> <code>tuple[PropertyValue, ...]</code> <p>Device property settings.  This is not a comprehensive list of all device properties, but only those that may have changed for this frame (such as properties in the channel config or light path config).</p> <code>runner_time_ms</code> <code>float</code> <p>Elapsed time in milliseconds since the beginning of the MDA sequence.</p> <code>position</code> <code>Position</code> <p>NotRequired. The current stage position(s) in 3D space.  This is often slow to retrieve, so its inclusion is optional and left to the implementer.</p> <code>mda_event</code> <code>useq.MDAEvent</code> <p>NotRequired. The MDA event object that commanded the acquisition of this frame.</p> <code>hardware_triggered</code> <code>bool</code> <p>NotRequired. Whether the frame was part of a hardware-triggered sequence. If missing, assume <code>False</code>.</p> <code>images_remaining_in_buffer</code> <code>int</code> <p>NotRequired. The number of images remaining to be popped from the image buffer (only applicable for hardware-triggered sequences).</p> <code>camera_metadata</code> <code>dict[str, Any]</code> <p>NotRequired. Additional metadata from the camera device.  This is unstructured and may contain any information that the camera device provides.  Do not rely on the presence of any particular keys.</p> <code>extra</code> <code>dict[str, Any]</code> <p>NotRequired. Additional information, may be used to store arbitrary user info or additional metadata.</p>"},{"location":"metadata/#supporting-types","title":"Supporting Types","text":""},{"location":"metadata/#pymmcore_plus.metadata.DeviceInfo","title":"<code>pymmcore_plus.metadata.DeviceInfo</code>","text":"<p>Information about a specific device.</p> <p>Keys:</p> Name Type Description <code>label</code> <code>str</code> <p>The user-provided label of the device.</p> <code>library</code> <code>str</code> <p>The name of the device adapter library (e.g. \"DemoCamera\" or \"ASITiger\").</p> <code>name</code> <code>str</code> <p>The name of the device, as known to the adapter. (e.g. \"DCam\" or \"XYStage\")</p> <code>type</code> <code>str</code> <p>The type of the device (e.g. \"Camera\", \"XYStage\", \"State\", etc...)</p> <code>description</code> <code>str</code> <p>A description of the device, provided by the adapter.</p> <code>properties</code> <code>tuple[PropertyInfo, ...]</code> <p>Information about the device's properties.</p> <code>parent_label</code> <code>str</code> <p>Not Required. The label of the parent device, if any. This will be missing for hub devices and other devices that are not peripherals.</p> <code>labels</code> <code>tuple[str, ...]</code> <p>Not Required. The labels of the device, if it is a state device.</p> <code>child_names</code> <code>tuple[str, ...]</code> <p>Not Required. The names of the child (peripheral) devices, if it is a hub device.</p> <code>is_continuous_focus_drive</code> <code>bool</code> <p>Not Required. Whether the device is a continuous focus drive. If missing, assume <code>False</code>.</p> <code>focus_direction</code> <code>Literal['Unknown', 'TowardSample', 'AwayFromSample']</code> <p>Not Required. The direction of focus movement. Will be missing if device is not a Stage device.</p> <code>is_sequenceable</code> <code>bool</code> <p>Not Required. Whether the device is sequenceable. If missing, assume <code>False</code>. This may be present for Cameras, SLMs, Stages, and XYStages.  See also the <code>is_sequenceable</code> property of each <code>PropertyInfo</code> object.</p>"},{"location":"metadata/#pymmcore_plus.metadata.SystemInfo","title":"<code>pymmcore_plus.metadata.SystemInfo</code>","text":"<p>General system information.</p> <p>Keys:</p> Name Type Description <code>pymmcore_version</code> <code>str</code> <p>The version of the PyMMCore library.</p> <code>pymmcore_plus_version</code> <code>str</code> <p>The version of the PyMMCore Plus library.</p> <code>mmcore_version</code> <code>str</code> <p>The version of the MMCore library. (e.g. <code>MMCore version 11.1.1</code>)</p> <code>device_api_version</code> <code>str</code> <p>The version of the device API. (e.g. <code>Device API version 71, Module API version 10</code>)</p> <code>device_adapter_search_paths</code> <code>tuple[str, ...]</code> <p>The active search paths for device adapters.  This may be useful to indicate the nightly build of device adapters, or other information that isn't in the version numbers.</p> <code>system_configuration_file</code> <code>str | None</code> <p>The path of the last loaded system configuration file, if any.</p> <code>primary_log_file</code> <code>str</code> <p>The path of the primary log file.</p> <code>sequence_buffer_size_mb</code> <code>int</code> <p>The size of the circular buffer available for storing images during hardware-triggered sequence acquisition.</p> <code>continuous_focus_enabled</code> <code>bool</code> <p>Whether continuous focus is enabled.</p> <code>continuous_focus_locked</code> <code>bool</code> <p>Whether continuous focus is currently locked.</p> <code>auto_shutter</code> <code>bool</code> <p>Whether auto-shutter is currently active.</p> <code>timeout_ms</code> <code>int | None</code> <p>Not Required. The current timeout in milliseconds for the system. The default timeout is 5000 ms.</p>"},{"location":"metadata/#pymmcore_plus.metadata.ImageInfo","title":"<code>pymmcore_plus.metadata.ImageInfo</code>","text":"<p>Information about the image format for a camera device.</p> <p>Keys:</p> Name Type Description <code>camera_label</code> <code>str</code> <p>The label of the corresponding camera device.</p> <code>plane_shape</code> <code>tuple[int, ...]</code> <p>The shape (height, width[, num_components]) of the numpy array that will be returned for each snap of the camera.  This will be length 2 for monochromatic images, and length 3 for images with multiple components (e.g. RGB).</p> <code>dtype</code> <code>str</code> <p>The numpy dtype of the image array (e.g. \"uint8\", \"uint16\", etc...)</p> <code>height</code> <code>int</code> <p>The height of the image in pixels.</p> <code>width</code> <code>int</code> <p>The width of the image in pixels.</p> <code>pixel_format</code> <code>Literal['Mono8', 'Mono10', 'Mono12', 'Mono14', 'Mono16', 'Mono32', 'RGB8', 'RGB10', 'RGB12', 'RGB14', 'RGB16']</code> <p>The GenICam pixel format of the camera. See PixelFormat and https://docs.baslerweb.com/pixel-format#unpacked-and-packed-pixel-formats for more information.</p> <code>pixel_size_config_name</code> <code>str</code> <p>The name of the currently active pixel size configuration.</p> <code>pixel_size_um</code> <code>float</code> <p>The pixel size in microns.</p> <code>magnification_factor</code> <code>float</code> <p>Not Required. The product of magnification of all loaded devices of type MagnifierDevice.  If no devices are found, or all have magnification=1, this will not be present.</p> <code>pixel_size_affine</code> <code>tuple[float, float, float, float, float, float]</code> <p>Not Required. Affine Transform to relate camera pixels with stage movement, corrected for binning and known magnification devices. The affine transform consists of the first two rows of a 3x3 matrix, the third row is always assumed to be <code>(0, 0, 1)</code>.  If missing, assume identity transform.</p> <code>roi</code> <code>tuple[int, int, int, int]</code> <p>Not Required. The active subarray (ROI: region of interest) on the camera, in the form <code>(x_offset, y_offset, width, height)</code>.  If missing, the full chip is being used.</p> <code>multi_roi</code> <code>tuple[list[int], list[int], list[int], list[int]]</code> <p>Not Required. The active subarrays (ROIs: regions of interest) on the camera, in the form <code>(x_offsets, y_offsets, widths, heights)</code>.  If missing, the camera does not support multiple ROIs or is not currently using them.</p>"},{"location":"metadata/#pymmcore_plus.metadata.ConfigGroup","title":"<code>pymmcore_plus.metadata.ConfigGroup</code>","text":"<p>A group of configuration presets.</p> <p>Keys:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the config group.</p> <code>presets</code> <code>tuple[ConfigPreset, ...]</code> <p>A collection of presets, each of which define a set of device property settings that can be applied to the system.</p>"},{"location":"metadata/#pymmcore_plus.metadata.ConfigPreset","title":"<code>pymmcore_plus.metadata.ConfigPreset</code>","text":"<p>A group of device property settings.</p> <p>Keys:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the preset.</p> <code>settings</code> <code>tuple[PropertyValue, ...]</code> <p>A collection of device property settings that make up the preset.</p>"},{"location":"metadata/#pymmcore_plus.metadata.PixelSizeConfigPreset","title":"<code>pymmcore_plus.metadata.PixelSizeConfigPreset</code>","text":"<p>A specialized group of device property settings for a pixel size preset.</p> <p>Keys:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the pixel size preset.</p> <code>settings</code> <code>tuple[PropertyValue, ...]</code> <p>A collection of device property settings that make up the pixel size preset.</p> <code>pixel_size_um</code> <code>float</code> <p>The pixel size in microns.</p> <code>pixel_size_affine</code> <code>tuple[float, float, float, float, float, float]</code> <p>Not Required. Affine Transform to relate camera pixels with stage movement, corrected for binning and known magnification devices. The affine transform consists of the first two rows of a 3x3 matrix, the third row is always assumed to be 0.0 0.0 1.0.</p> <p>pixel_size_dxdz : float     Not Required. The angle between the camera's x axis and the axis (direction)     of the z drive for the given pixel size configuration. This angle is     dimensionless (i.e. the ratio of the translation in x caused by a translation     in z, i.e. dx / dz). If missing, assume 0.0. pixel_size_dydz : float     Not Required. The angle between the camera's y axis and the axis (direction)     of the z drive for the given pixel size configuration. This angle is     dimensionless (i.e. the ratio of the translation in y caused by a translation     in z, i.e. dy / dz). If missing, assume 0.0. pixel_size_optimal_z_um : float     Not Required. User-defined optimal Z step size is for this pixel size config.     If missing, assume 0.0.</p>"},{"location":"metadata/#pymmcore_plus.metadata.PropertyInfo","title":"<code>pymmcore_plus.metadata.PropertyInfo</code>","text":"<p>Information about a single device property.</p> <p>Keys:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the property.</p> <code>value</code> <code>str | None</code> <p>The current value of the property, if any.</p> <code>data_type</code> <code>Literal['undefined', 'float', 'int', 'str']</code> <p>The data type of the <code>value</code> field.</p> <code>is_read_only</code> <code>bool</code> <p>Whether the property is read-only.</p> <code>allowed_values</code> <code>tuple[str, ...]</code> <p>Not Required. The allowed values for the property, if any.  Consumers should not depend on this field being present.</p> <code>is_pre_init</code> <code>bool</code> <p>Not Required. Whether the property is pre-init.  If missing, assume <code>False</code>.</p> <code>limits</code> <code>tuple[float, float]</code> <p>Not Required. The limits of the property, if any.  If missing, the property has no limits.</p> <code>sequenceable</code> <code>bool</code> <p>Not Required. Whether the property is sequenceable.  If missing, assume <code>False</code>.</p> <code>sequence_max_length</code> <code>int</code> <p>Not Required. The maximum length of a sequence for the property, if applicable.  Will be missing if the property is not sequenceable.</p>"},{"location":"metadata/#pymmcore_plus.metadata.PropertyValue","title":"<code>pymmcore_plus.metadata.PropertyValue</code>","text":"<p>A single device property setting.</p> <p>This represents a single device property setting, whether it be an \"active\" value, or an intended value as a part of a configuration preset.</p> <p>Keys:</p> Name Type Description <code>dev</code> <code>str</code> <p>The label of the device.</p> <code>prop</code> <code>str</code> <p>The name of the property.</p> <code>val</code> <code>Any</code> <p>The value of the property.</p>"},{"location":"metadata/#pymmcore_plus.metadata.Position","title":"<code>pymmcore_plus.metadata.Position</code>","text":"<p>Represents a position in 3D space and focus.</p> <p>Keys:</p> Name Type Description <code>x</code> <code>float</code> <p>Not Required. The X coordinate of the \"active\" XY stage device. May be missing if there is no current XY stage device.</p> <code>y</code> <code>float</code> <p>Not Required. The Y coordinate of the \"active\" XY stage device. May be missing if there is no current XY stage device.</p> <code>z</code> <code>float</code> <p>Not Required. The coordinate of the \"active\" focus device. May be missing if there is no current focus stage device.</p> <code>all_stages</code> <code>tuple[StagePosition, ...]</code> <p>Not Required. The positions of all stage devices (both inactive and active devices that are represented by <code>x</code>, <code>y</code>, and <code>z</code>).  Inclusion of this field is up to the implementer.</p>"},{"location":"metadata/#pymmcore_plus.metadata.StagePosition","title":"<code>pymmcore_plus.metadata.StagePosition</code>","text":"<p>Represents the position of a single stage device.</p>"},{"location":"metadata/#functions","title":"Functions","text":"<p>In most cases, the metadata dicts described above will be received as an argument to either the <code>sequenceStarted</code> or <code>frameReady</code> callbacks in an MDA. However, they can also be generated with the following functions.</p>"},{"location":"metadata/#pymmcore_plus.metadata.summary_metadata","title":"<code>pymmcore_plus.metadata.summary_metadata(core: CMMCorePlus, *, mda_sequence: useq.MDASequence | None = None, cached: bool = True, include_time: bool = True) -&gt; SummaryMetaV1</code>","text":"<p>Return a summary metadata for the current state of the system.</p> <p>See pymmcore_plus.metadata.SummaryMetaV1 for a description of the dictionary format.</p> Source code in <code>pymmcore_plus/metadata/functions.py</code> <pre><code>def summary_metadata(\n    core: CMMCorePlus,\n    *,\n    mda_sequence: useq.MDASequence | None = None,\n    cached: bool = True,\n    include_time: bool = True,\n) -&gt; SummaryMetaV1:\n    \"\"\"Return a summary metadata for the current state of the system.\n\n    See [pymmcore_plus.metadata.SummaryMetaV1][] for a description of the\n    dictionary format.\n    \"\"\"\n    summary: SummaryMetaV1 = {\n        \"format\": \"summary-dict\",\n        \"version\": \"1.0\",\n        \"devices\": devices_info(core, cached=cached),\n        \"system_info\": system_info(core),\n        \"image_infos\": image_infos(core),\n        \"position\": position(core),\n        \"config_groups\": config_groups(core),\n        \"pixel_size_configs\": pixel_size_configs(core),\n    }\n    if include_time:\n        summary[\"datetime\"] = timestamp()\n    if mda_sequence:\n        summary[\"mda_sequence\"] = mda_sequence\n    return summary\n</code></pre>"},{"location":"metadata/#pymmcore_plus.metadata.frame_metadata","title":"<code>pymmcore_plus.metadata.frame_metadata(core: CMMCorePlus, *, cached: bool = True, runner_time_ms: float = -1, camera_device: str | None = None, property_values: tuple[PropertyValue, ...] = (), include_position: bool = False, **kwargs: Unpack[_OptionalFrameMetaKwargs]) -&gt; FrameMetaV1</code>","text":"<p>Return metadata for the current frame.</p> Source code in <code>pymmcore_plus/metadata/functions.py</code> <pre><code>def frame_metadata(\n    core: CMMCorePlus,\n    *,\n    cached: bool = True,\n    runner_time_ms: float = -1,\n    camera_device: str | None = None,\n    property_values: tuple[PropertyValue, ...] = (),\n    include_position: bool = False,\n    **kwargs: Unpack[_OptionalFrameMetaKwargs],\n) -&gt; FrameMetaV1:\n    \"\"\"Return metadata for the current frame.\"\"\"\n    info: FrameMetaV1 = {\n        \"format\": \"frame-dict\",\n        \"version\": \"1.0\",\n        \"runner_time_ms\": runner_time_ms,\n        \"camera_device\": camera_device or core.getPhysicalCameraDevice(),\n        \"property_values\": property_values,\n        \"exposure_ms\": core.getExposure(),\n        \"pixel_size_um\": core.getPixelSizeUm(cached),\n        **kwargs,\n    }\n    if include_position and \"position\" not in kwargs:\n        info[\"position\"] = position(core)\n    return info\n</code></pre>"},{"location":"profiling/","title":"Performance Profiling","text":"<p>Identifying performance bottlenecks is an important part of the development process. MMCore coordinates control of many different devices, each of which may have its own performance characteristics. As a result, performance issues can vary dramatically depending on the specific hardware configuration and the operations being performed.</p> <p>This document provides an overview of some tools and techniques that can be used to identify and address performance bottlenecks when using pymmcore-plus</p>"},{"location":"profiling/#profiling-with-py-spy","title":"Profiling with py-spy","text":"<p>There are many tools available for profiling Python code. We recommend starting with <code>py-spy</code>.  You can add it to your environment with <code>pip install py-spy</code>.  For complete usage tips, see the <code>py-spy</code> readme, but here is a quick example of how to use it with pymmcore-plus:</p>"},{"location":"profiling/#example-with-python-script","title":"Example with python script","text":"<p>Create a Python script that uses pymmcore-plus to perform some operations, such as instantiating a CMMCorePlus object, loading a configuration, and performing some task such as running a multi-dimensional acquisition.  Save this script somewhere (we'll call it <code>example.py</code>) and profile it with <code>py-spy</code>:</p> <p>Note: py-spy will require sudo access</p> <pre><code>sudo py-spy record -o profile.json -f speedscope -r 1000 -- python example.py\n</code></pre> <ul> <li>the <code>-o profile</code> flag specifies the output file name</li> <li>the <code>-f speedscope</code> flag specifies the output format.  Here, we use the   <code>speedscope</code> format, which can be viewed in the Speedscope   web viewer.</li> <li>the <code>-r 1000</code> flag specifies the sampling rate (in Hz).  The default is 100 Hz, so if   you want more detailed profiling, you can increase this number as we've done here.</li> <li>the <code>--</code> separates the <code>py-spy</code> arguments from the Python script to be profiled</li> </ul>"},{"location":"profiling/#example-using-mmcore-run","title":"Example using <code>mmcore run</code>","text":"<p>If you are profiling a standard MDASequence acquisition, you can use the <code>mmcore run</code> command line tool to run the acquisition and profile it with <code>py-spy</code>.  First, create a json/yaml file representing the MDASequence acquisition you want to run:</p> <pre><code>from useq import MDASequence\n\nseq = MDASequence(\n    channels=[\"DAPI\", {\"config\": \"FITC\", \"exposure\": 1}],\n    time_plan={\"interval\": 2, \"loops\": 5},\n    z_plan={\"range\": 4, \"step\": 0.5},\n    axis_order=\"tpcz\",\n)\nseq_json = sequence.model_dump_json(exclude_unset=True)\n\nwith open(\"mda_seq.json\", \"w\") as f:\n    f.write(seq_json)\n</code></pre> <p>Then, run the acquisition with <code>mmcore run</code> and profile it with py-spy:</p> <pre><code>sudo py-spy record -o profile.json -f speedscope -r 1000 -- mmcore run mda_seq.json --config your_mm_config.cfg\n</code></pre> <ul> <li>the <code>-o</code>, <code>-f</code>, <code>-r</code>, and <code>--</code> flags are the same as in the previous example</li> <li>the <code>mmcore run</code> command runs the acquisition specified in the json file</li> <li>the <code>--config</code> flag specifies the path to the MMCore configuration file defining your microscope.</li> </ul>"},{"location":"profiling/#example-attaching-to-a-running-process","title":"Example attaching to a running process","text":"<p>If you have a running Python process that you want to profile, you can attach <code>py-spy</code> to it using the <code>-p</code> flag:</p> <pre><code>sudo py-spy record -o profile.json -f speedscope -r 1000 -p &lt;pid&gt;\n</code></pre>"},{"location":"profiling/#analyzing-the-profile","title":"Analyzing the profile","text":"<p>Once you have a profile, you can view it in the Speedscope web viewer.</p> <p>Open https://www.speedscope.app/ and drag the profile file into the window.</p> <p>See the Speedscope documentation for more information.  The \"Sandwich\" view is particularly useful for identifying slow functions and hot paths in your code:</p> <p></p> <p>Feel free to open an issue with your <code>profile.json</code> file if you need help interpreting the results.</p>"},{"location":"troubleshooting/","title":"Troubleshooting","text":""},{"location":"troubleshooting/#micro-manager-directory-not-found","title":"Micro-Manager directory not found","text":"<pre><code>pymmcore-plus - ERROR - (_util.py:131) could not find micromanager directory. Please run 'mmcore install'\n</code></pre> <p>If you tried to create a <code>pymmcore_plus.CMMCorePlus</code> instance and got an error similar the one above, it means that pymmcore-plus was unable to find micro-manager on on your system. Please run <code>mmcore install</code> to install the latest version of Micro-Manager.</p> <p>See the installation section for more details.</p>"},{"location":"troubleshooting/#incompatible-device-interface-version","title":"Incompatible device interface version","text":"<pre><code>OSError: Line 7: Device,DHub,DemoCamera,DHub\nFailed to load device \"DHub\" from adapter module \"DemoCamera\" [ Failed to load device adapter \"DemoCamera\" from \"/Users/fdrgsp/Library/Application Support/pymmcore-plus/mm/Micro-Manager-2.0.1-20210715/libmmgr_dal_DemoCamera\" [ Incompatible device interface version (required = 71; found = 70) ] ]\n</code></pre> <p>If you create a <code>pymmcore_plus.CMMCorePlus</code> instance and you get an error similar the one above when trying to load a Micro-Manager configuration file, you need to update your Micro-Manager device adapters installation to the newest version (for example by running: <code>mmcore install</code>).</p> <p>See the installation section for more details.</p>"},{"location":"troubleshooting/#slow-performance","title":"Slow performance","text":"<p>If you are experiencing slow performance with pymmcore-plus, you can profile your code to identify bottlenecks.  See the profiling section for more details. If you identify a specific issue, or have a question regarding the interpretation of the profiling results, please open an issue and attach the profiling results if possible.</p>"},{"location":"api/cmmcoreplus/","title":"CMMCorePlus","text":"<p>The main object in <code>pymmcore_plus</code> is the <code>pymmcore_plus.CMMCorePlus</code> class. <code>CMMCorePlus</code> is a subclass of <code>pymmcore.CMMCore</code> with additional functionality, and some overrides for the sake of convenience or fixed behavior.</p>"},{"location":"api/cmmcoreplus/#cmmcoreplus-api-summary","title":"CMMCorePlus API summary","text":"<p>This table presents all methods available in the <code>CMMCorePlus</code> class, and indicates which methods are unique to <code>CMMCorePlus</code> () and which methods are overridden from <code>CMMCore</code> ().  Below the table, the signatures of all methods are presented, broken into a <code>CMMCorePlus</code> section and a <code>CMMCore</code> section (depending on whether the method is implemented in <code>CMMCorePlus</code> or not).</p> <p> This method is overridden by <code>CMMCorePlus</code>. This method only exists in <code>CMMCorePlus</code>. This method is deprecated. </p> Method Description <code>addGalvoPolygonVertex</code> Add a vertex to a galvo polygon. <code>canSequenceEvents</code> Check whether two <code>useq.MDAEvent</code> are sequenceable by this core instance. <code>channelGroup_pattern</code> The regex pattern used to identify channel groups. <code>clearCircularBuffer</code> Removes all images from the circular buffer. <code>clearROI</code> Set the region of interest of the current camera to the full frame. <code>debugLogEnabled</code> Indicates if logging of debug messages is enabled <code>defineConfig</code> Defines a configuration. <code>defineConfigGroup</code> Creates an empty configuration group. <code>definePixelSizeConfig</code> Defines an empty pixel size entry. <code>defineStateLabel</code> Defines a label for the specific state. <code>deleteConfig</code> Delete <code>configName</code> from <code>groupName</code>. <code>deleteConfigGroup</code> Deletes an entire configuration <code>group</code>. <code>deleteGalvoPolygons</code> Remove all added polygons <code>deletePixelSizeConfig</code> Delete the pixel size configuration for the given <code>resolutionID</code>. <code>describe</code> Print information table with the current configuration. <code>detectDevice</code> Tries to communicate to a device through a given serial port. <code>deviceBusy</code> Checks the busy status of the specific device. <code>deviceTypeBusy</code> Checks the busy status for all devices of the specific type. <code>displaySLMImage</code> Display the waiting image on the SLM. <code>enableContinuousFocus</code> Enables or disables the operation of the continuous focusing hardware device. <code>enableDebugLog</code> Enable or disable logging of debug messages. <code>enableFeature</code> Enable or disable the given Core feature. <code>enableStderrLog</code> Enables or disables log message display on the standard console. <code>events</code> Signaler for core events. <code>fixImage</code> Fix img shape/dtype based on <code>self.getNumberOfComponents()</code>. <code>fullFocus</code> Performs focus acquisition and lock for the one-shot focusing device. <code>getAPIVersionInfo</code> Returns the module and device interface versions. <code>getAdapterObject</code> Return an <code>Adapter</code> object bound to library_name on this core. <code>getAllowedBinningValues</code> <code>getAllowedPropertyValues</code> Returns all valid values for the specified property. <code>getAutoFocusDevice</code> Returns the label of the currently selected auto-focus device. <code>getAutoFocusOffset</code> Measures offset for the one-shot focusing device. <code>getAutoShutter</code> Returns the current setting of the auto-shutter option. <code>getAvailableConfigGroups</code> Returns the names of all defined configuration groups <code>getAvailableConfigs</code> Returns all defined configuration (preset) names in a given group <code>getAvailableDeviceDescriptions</code> Get descriptions for available devices from the specified library. <code>getAvailableDeviceTypes</code> Get type information for available devices from the specified library. <code>getAvailableDevices</code> Get available devices from the specified device library. <code>getAvailablePixelSizeConfigs</code> Returns all defined resolution preset names <code>getBinning</code> <code>getBufferFreeCapacity</code> Returns the number of images that can be added to the buffer without <code>getBufferTotalCapacity</code> Returns the total number of images that can be stored in the buffer <code>getBytesPerPixel</code> How many bytes for each pixel. <code>getCameraChannelName</code> Returns the name of the requested channel as known by the default camera <code>getCameraChannelNames</code> Convenience method to call <code>getCameraChannelName</code> for all camera channels. <code>getCameraDevice</code> Returns the label of the currently selected camera device. <code>getChannelGroup</code> Returns the group determining the channel selection. <code>getCircularBufferMemoryFootprint</code> Returns the size of the Circular Buffer in MB <code>getConfigData</code> Return the configuration object for a given <code>configGroup</code> and <code>configName</code>. <code>getConfigGroupObject</code> Return a <code>ConfigGroup</code> object bound to group_name on this core. <code>getConfigGroupState</code> Return the state of the devices included in the specified <code>group</code>. <code>getConfigGroupStateFromCache</code> Return the state of the system cache, for the devices in the specified group. <code>getConfigState</code> Return state of devices included in the specified configuration. <code>getCoreErrorText</code> Returns a pre-defined error test with the given error code <code>getCurrentConfig</code> Returns the current configuration (preset) for a given group. <code>getCurrentConfigFromCache</code> Returns the configuration for a given group based on the data in the cache. <code>getCurrentDeviceOfType</code> Return the current device of type <code>device_type</code>. <code>getCurrentFocusScore</code> Returns the focus score from the default focusing device measured at the <code>getCurrentPixelSizeConfig</code> <code>getDeviceAdapterNames</code> Return the names of discoverable device adapters. <code>getDeviceAdapterSearchPaths</code> Return the current device adapter search paths. <code>getDeviceDelayMs</code> Reports action delay in milliseconds for the specific device. <code>getDeviceDescription</code> Returns description text for a given device label. \"Description\" is determined <code>getDeviceInitializationState</code> Queries the initialization state of the given device. <code>getDeviceLibrary</code> Returns device library (aka module, device adapter) name. <code>getDeviceName</code> Returns device name for a given device label. <code>getDeviceObject</code> Return a <code>Device</code> object bound to device_label on this core. <code>getDevicePropertyNames</code> Returns all property names supported by the device. <code>getDeviceSchema</code> Return JSON-schema describing device <code>device_label</code> and its properties. <code>getDeviceType</code> Return device type for a given device. <code>getExposure</code> <code>getExposureSequenceMaxLength</code> Gets the maximum length of a camera's exposure sequence. <code>getFocusDevice</code> Returns the label of the currently selected focus device. <code>getFocusDirection</code> Return device type for a given device. <code>getGalvoChannel</code> Get the name of the active galvo channel (for a multi-laser galvo device). <code>getGalvoDevice</code> Returns the label of the currently selected Galvo device. <code>getGalvoPosition</code> <code>getGalvoXMinimum</code> Get the Galvo x minimum <code>getGalvoXRange</code> Get the Galvo x range <code>getGalvoYMinimum</code> Get the Galvo y minimum <code>getGalvoYRange</code> Get the Galvo y range <code>getImage</code> Return the internal image buffer. <code>getImageBitDepth</code> How many bits of dynamic range are to be expected from the camera. <code>getImageBufferSize</code> Returns the size of the internal image buffer. <code>getImageHeight</code> Vertical dimension of the image buffer in pixels. <code>getImageProcessorDevice</code> Returns the label of the currently selected image processor device. <code>getImageWidth</code> Horizontal dimension of the image buffer in pixels. <code>getInstalledDeviceDescription</code> Returns description from the specified peripheral on <code>hubLabel</code> device. <code>getInstalledDevices</code> Performs auto-detection and loading of child devices that are attached to a <code>getLastFocusScore</code> Returns the latest focus score from the focusing device. <code>getLastImage</code> Gets the last image from the circular buffer. <code>getLastImageAndMD</code> Return last image from the circular buffer along with metadata. <code>getLastImageMD</code> <code>getLoadedDevices</code> Returns an array of labels for currently loaded devices. <code>getLoadedDevicesOfType</code> Returns an array of labels for currently loaded devices of specific type. <code>getLoadedPeripheralDevices</code> Return labels of all loaded peripherals of <code>hubLabel</code> device. <code>getMMCoreVersionMajor</code> <code>getMMCoreVersionMinor</code> <code>getMMCoreVersionPatch</code> <code>getMMDeviceDeviceInterfaceVersion</code> <code>getMMDeviceModuleInterfaceVersion</code> <code>getMagnificationFactor</code> Returns the product of all Magnifiers in the system or 1.0 when none is found. <code>getMultiROI</code> Get multiple ROIs from the current camera device. <code>getNBeforeLastImageAndMD</code> Return image taken <code>n</code> images ago along with associated metadata. <code>getNBeforeLastImageMD</code> Returns a pointer to the pixels of the image that was inserted n images ago. <code>getNumberOfCameraChannels</code> Returns the number of simultaneous channels the default camera is returning. <code>getNumberOfComponents</code> Returns the number of components the default camera is returning. <code>getNumberOfStates</code> Returns the total number of available positions (states). <code>getOrGuessChannelGroup</code> Get the channelGroup or find a likely set of candidates. <code>getParentLabel</code> Returns parent device. Returns empty string if no parent is found. <code>getPhysicalCameraDevice</code> Return the name of the actual camera device for a given channel index. <code>getPixelSizeAffine</code> <code>getPixelSizeAffineByID</code> Returns the Affine Transform to related camera pixels with stage movement for <code>getPixelSizeConfigData</code> Return the configuration object for a given pixel size preset <code>configName</code>. <code>getPixelSizeOptimalZUm</code> <code>getPixelSizeUm</code> <code>getPixelSizeUmByID</code> Returns the pixel size in um for the requested pixel size group <code>getPixelSizedxdz</code> <code>getPixelSizedydz</code> <code>getPosition</code> <code>getPrimaryLogFile</code> Return the name of the primary Core log file. <code>getProperty</code> Returns the property value for the specified device. <code>getPropertyFromCache</code> Returns the cached property value for the specified device. <code>getPropertyLowerLimit</code> Returns the property lower limit value, if the property has limits - 0 <code>getPropertyObject</code> Return a DeviceProperty object bound to a device/property on this core. <code>getPropertySequenceMaxLength</code> Queries device property for the maximum number of events that can be put <code>getPropertyType</code> Return the intrinsic property type for a given device and property. <code>getPropertyUpperLimit</code> Returns the property upper limit value, if the property has limits - 0 <code>getPumpFlowrate</code> Return the flowrate of the pump in uL per second <code>getPumpMaxVolume</code> Return max volume of the pump in uL <code>getPumpPressureKPa</code> Return the pressure of the pump in kPa. <code>getPumpVolume</code> Return the fluid volume in the pump in uL <code>getROI</code> <code>getRemainingImageCount</code> Returns number ofimages available in the Circular Buffer <code>getSLMBytesPerPixel</code> Returns the number of bytes per SLM pixel <code>getSLMDevice</code> Returns the label of the currently selected SLM device. <code>getSLMExposure</code> Returns the exposure time that will be used by the SLM for illumination <code>getSLMHeight</code> Returns the height (in \"pixels\") of the SLM <code>getSLMNumberOfComponents</code> Returns the number of components (usually these depict colors) of the SLM. <code>getSLMSequenceMaxLength</code> For SLMs that support sequences, returns the maximum length of the sequence <code>getSLMWidth</code> Returns the width (in \"pixels\") of the SLM <code>getSerialPortAnswer</code> Continuously read from the serial port until the terminating sequence is <code>getShutterDevice</code> Returns the label of the currently selected shutter device. <code>getShutterOpen</code> <code>getStageSequenceMaxLength</code> Gets the maximum length of a stage's position sequence. <code>getState</code> Returns the current state (position) on the specific device. <code>getStateFromLabel</code> Obtain the state for a given label. <code>getStateLabel</code> Returns the current state as the label (string). <code>getStateLabels</code> Return labels for all states <code>getSystemState</code> Return the entire system state. <code>getSystemStateCache</code> Return the entire system state from cache. <code>getTaggedImage</code> Return getImage as named tuple with metadata. <code>getTags</code> Return a dict of metadata tags for the state of the core. <code>getTimeoutMs</code> Get the timeout for all wait commands. <code>getVersionInfo</code> Displays core version. <code>getXPosition</code> <code>getXYPosition</code> <code>getXYStageDevice</code> Returns the label of the currently selected XYStage device. <code>getXYStageSequenceMaxLength</code> Gets the maximum length of an XY stage's position sequence. <code>getYPosition</code> <code>getZPosition</code> Obtains the current position of the Z axis of the Z stage in microns. <code>guessObjectiveDevices</code> Find any loaded devices that are likely to be an Objective/Nosepiece. <code>hasProperty</code> Checks if device has a property with a specified name. <code>hasPropertyLimits</code> Queries device if the specific property has limits. <code>home</code> Perform a hardware homing operation for an XY or focus/Z stage. <code>incrementalFocus</code> Performs incremental focus for the one-shot focusing device. <code>initializeAllDevices</code> Calls Initialize() method for each loaded device. <code>initializeCircularBuffer</code> Initialize circular buffer based on the current camera settings. <code>initializeDevice</code> Initializes specific device. <code>instance</code> Return the global singleton instance of <code>CMMCorePlus</code>. <code>invertPumpDirection</code> Sets whether the pump direction needs to be inverted <code>isBufferOverflowed</code> Indicates whether the circular buffer is overflowed <code>isConfigDefined</code> Checks if the configuration already exists within a group. <code>isContinuousFocusDrive</code> Check if a stage has continuous focusing capability. <code>isContinuousFocusEnabled</code> Checks if the continuous focusing hardware device is ON or OFF. <code>isContinuousFocusLocked</code> Returns the lock-in status of the continuous focusing device. <code>isExposureSequenceable</code> Queries camera if exposure can be used in a sequence <code>isFeatureEnabled</code> Return whether the given Core feature is currently enabled. <code>isGroupDefined</code> Checks if the group already exists. <code>isMultiROIEnabled</code> Queries the camera to determine if multiple ROIs are currently set. <code>isMultiROISupported</code> Queries the camera to determine if it supports multiple ROIs. <code>isPixelSizeConfigDefined</code> Checks if the Pixel Size Resolution already exists <code>isPropertyPreInit</code> Tells us whether the property must be defined prior to initialization. <code>isPropertyReadOnly</code> Tells us whether the property can be modified. <code>isPropertySequenceable</code> Queries device if the specified property can be used in a sequence <code>isPumpDirectionInverted</code> Return True if pump direction needs to be inverted <code>isSequenceRunning</code> <code>isStageLinearSequenceable</code> Queries if the stage can be used in a linear sequence. <code>isStageSequenceable</code> Queries stage if it can be used in a sequence <code>isStageUsingCallbacks</code> Queries whether the stage uses callbacks to signal position changes. <code>isXYStageSequenceable</code> Queries XY stage if it can be used in a sequence <code>isXYStageUsingCallbacks</code> Queries whether the XY stage uses callbacks to signal position changes. <code>iterConfigGroups</code> Iterate <code>ConfigGroup</code> objects for all configs. <code>iterDeviceAdapters</code> Iterate over all available device adapters. <code>iterDevices</code> Iterate over currently loaded devices. <code>iterProperties</code> Iterate over currently loaded (device_label, property_name) pairs. <code>loadDevice</code> Load a device from the plugin library. <code>loadExposureSequence</code> Transfer a sequence of exposure times to the camera. <code>loadGalvoPolygons</code> Load a set of galvo polygons to the device <code>loadPropertySequence</code> Transfer a sequence of events/states/whatever to the device. <code>loadSLMSequence</code> Load a sequence of images into the SLM <code>loadStageSequence</code> Transfer a sequence of events/states/whatever to the device. <code>loadSystemConfiguration</code> Load a system config file conforming to the MM <code>.cfg</code> format. <code>loadSystemState</code> Loads the system configuration from the text file conforming to the <code>loadXYStageSequence</code> Transfer a sequence of stage positions to the xy stage. <code>logMessage</code> <code>mda</code> Return the <code>MDARunner</code> for this <code>CMMCorePlus</code> instance. <code>noop</code> A static method that does nothing. <code>objective_device_pattern</code> Pattern used to guess objective device labels. <code>pointGalvoAndFire</code> Set the Galvo to an x,y position and fire the laser for a predetermined duration. <code>popNextImage</code> Gets and removes the next image from the circular buffer. <code>popNextImageAndMD</code> Gets and removes the next image (and metadata) from the circular buffer. <code>popNextImageMD</code> <code>popNextTaggedImage</code> Return popNextImageAndMD as named tuple with metadata. <code>prepareSequenceAcquisition</code> Prepare the camera for the sequence acquisition to save the time in the <code>pressurePumpCalibrate</code> Calibrates the pressure pump. <code>pressurePumpRequiresCalibration</code> Return True if pump requires calibration before operation. <code>pressurePumpStop</code> Stops the pressure pump. <code>pumpDispenseDurationSeconds</code> Dispenses for the provided duration (in seconds) at the set flowrate. <code>pumpDispenseVolumeUl</code> Dispenses the provided volume (in uL) at the set flowrate. <code>pumpStart</code> Start dispensing until syringe is empty, or manually stopped. <code>readFromSerialPort</code> Reads the contents of the Rx buffer. <code>registerCallback</code> registerCallback is disallowed in pymmcore-plus! <code>register_mda_engine</code> Set the MDA Engine to be used on <code>run_mda</code>. <code>renameConfig</code> Renames a configuration within a specified group. <code>renameConfigGroup</code> Renames a configuration group. <code>renamePixelSizeConfig</code> Renames a pixel size configuration. <code>reset</code> Unloads all devices from the core, clears all configuration data and property <code>runGalvoPolygons</code> Run a loop of galvo polygons <code>runGalvoSequence</code> Run a sequence of galvo positions <code>run_mda</code> Run a sequence of useq.MDAEvent on a new thread. <code>saveSystemConfiguration</code> Saves the current system configuration to a text file. <code>saveSystemState</code> Saves the current system state to a text file of the MM specific format. <code>setAdapterOrigin</code> <code>setAdapterOriginXY</code> <code>setAutoFocusDevice</code> Sets the current auto-focus device. <code>setAutoFocusOffset</code> Applies offset the one-shot focusing device. <code>setAutoShutter</code> Set shutter to automatically open and close when an image is acquired. <code>setBinning</code> <code>setCameraDevice</code> Sets the current camera device. <code>setChannelGroup</code> Specifies the group determining the channel selection. <code>setCircularBufferMemoryFootprint</code> Reserve memory for the circular buffer. <code>setConfig</code> Applies a configuration to a group. <code>setContext</code> Set core properties in a context restoring the initial values on exit. <code>setDeviceAdapterSearchPaths</code> Set the device adapter search paths. <code>setDeviceDelayMs</code> Overrides the built-in value for the action delay. <code>setExposure</code> <code>setFocusDevice</code> Set the current Focus Device and emit a <code>propertyChanged</code> signal. <code>setFocusDirection</code> Set the focus direction of a stage. <code>setGalvoDevice</code> Sets the current galvo device. <code>setGalvoIlluminationState</code> Set the galvo's illumination state to on or off <code>setGalvoPolygonRepetitions</code> Set the number of times to loop galvo polygons <code>setGalvoPosition</code> Set the Galvo to an x,y position. <code>setGalvoSpotInterval</code> Set the SpotInterval for the specified galvo device. <code>setImageProcessorDevice</code> Sets the current image processor device. <code>setMultiROI</code> Set multiple ROIs for the current camera device. <code>setOrigin</code> <code>setOriginX</code> <code>setOriginXY</code> <code>setOriginY</code> <code>setParentLabel</code> Sets parent device label <code>setPixelSizeAffine</code> Sets the raw affine transform for the specific pixel size configuration. <code>setPixelSizeConfig</code> Applies a Pixel Size Configuration. <code>setPixelSizeOptimalZUm</code> Sets the pixel size in the Z direction in microns. <code>setPixelSizeUm</code> Set pixel size in microns for the specified <code>resolutionID</code>. <code>setPixelSizedxdz</code> Sets the pixel size in the X direction in microns. <code>setPixelSizedydz</code> Sets the pixel size in the Y direction in microns. <code>setPosition</code> <code>setPrimaryLogFile</code> <code>setProperty</code> Set property named <code>propName</code> on device <code>label</code> to <code>propValue</code>. <code>setPumpFlowrate</code> Set the flowrate of the pump in uL per second <code>setPumpMaxVolume</code> Set the max volume of the pump in uL <code>setPumpPressureKPa</code> Sets the pressure of the pump in kPa. <code>setPumpVolume</code> Sets the volume of fluid in the pump in uL. <code>setROI</code> Set the camera Region of Interest (ROI). <code>setRelativePosition</code> <code>setRelativeXYPosition</code> <code>setRelativeXYZPosition</code> Sets the relative XYZ position in microns. <code>setSLMDevice</code> Sets the current slm device. <code>setSLMExposure</code> For SLM devices with build-in light source (such as projectors), <code>setSLMImage</code> <code>setSLMPixelsTo</code> <code>setSerialPortCommand</code> Send string to the serial device and return an answer. <code>setSerialProperties</code> Sets all com port properties in a single call. <code>setShutterDevice</code> the current shutter device. <code>setShutterOpen</code> Open or close the currently selected or <code>shutterLabel</code> shutter. <code>setStageLinearSequence</code> Loads a linear sequence (defined by stepsize and nr. of steps) into the device. <code>setState</code> Set state (by position) on <code>stateDeviceLabel</code>, with reliable event emission. <code>setStateLabel</code> Set state (by label) on <code>stateDeviceLabel</code>, with reliable event emission. <code>setSystemState</code> Sets all properties contained in the Configuration object. <code>setTimeoutMs</code> Sets the timeout for all wait commands. <code>setXYPosition</code> Sets the position of the XY stage in microns. <code>setXYStageDevice</code> Sets the current XY device. <code>setZPosition</code> Set the position of the current focus device in microns. <code>sleep</code> Waits (blocks the calling thread) for specified time in milliseconds. <code>snap</code> Snap and return an image. <code>snapImage</code> Acquires a single image with current settings. <code>startContinuousSequenceAcquisition</code> Start a ContinuousSequenceAcquisition. <code>startExposureSequence</code> Starts an ongoing sequence of triggered exposures in a camera. <code>startPropertySequence</code> Starts an ongoing sequence of triggered events in a property of a device. <code>startSLMSequence</code> Starts the sequence previously uploaded to the SLM <code>startSecondaryLogFile</code> <code>startSequenceAcquisition</code> Starts streaming camera sequence acquisition. <code>startStageSequence</code> Starts an ongoing sequence of triggered events in a stage. <code>startXYStageSequence</code> Starts an ongoing sequence of triggered events in an XY stage. <code>state</code> Return info on the current state of the core. <code>stderrLogEnabled</code> Indicates whether logging output goes to stdErr <code>stop</code> Stop the XY or focus/Z stage motors <code>stopExposureSequence</code> Stops an ongoing sequence of triggered exposures in a camera. <code>stopPropertySequence</code> Stops an ongoing sequence of triggered events in a property of a device. <code>stopSLMSequence</code> Stops the SLM sequence if previously started <code>stopSecondaryLogFile</code> Stop capturing logging output into an additional file. <code>stopSequenceAcquisition</code> Stops streaming camera sequence acquisition. <code>stopStageSequence</code> Stops an ongoing sequence of triggered events in a stage. <code>stopXYStageSequence</code> Stops an ongoing sequence of triggered events in an XY stage. <code>supportsDeviceDetection</code> Return whether or not the device supports automatic device detection (i.e. <code>systemBusy</code> Checks the busy status of the entire system. <code>systemConfigurationFile</code> Return the path to the last loaded system configuration file, or <code>None</code>. <code>this</code> <code>thisown</code> <code>unloadAllDevices</code> Unload all devices from the core and reset all configuration data. <code>unloadDevice</code> Unloads the device from the core and adjusts all configuration data. <code>unloadLibrary</code> Forcefully unload a library. <code>updateCoreProperties</code> Updates CoreProperties (currently all Core properties are devices types) with <code>updateSystemStateCache</code> Updates the state of the entire hardware. <code>usesDeviceDelay</code> Signals if the device will use the delay setting or not. <code>volumetricPumpHome</code> Homes the volumetric pump. <code>volumetricPumpRequiresHoming</code> Return True if the volumetric pump requires homing. <code>volumetricPumpStop</code> Stops the volumetric pump. <code>waitForConfig</code> Blocks until all devices included in the configuration become ready. <code>waitForDevice</code> Waits (blocks the calling thread) until the specified device becomes non-busy. <code>waitForDeviceType</code> Blocks until all devices of the specific type become ready (not-busy). <code>waitForSystem</code> Blocks until all devices in the system become ready (not-busy). <code>writeToSerialPort</code> Sends an array of characters to the serial port and returns immediately. <p>Info</p> <p>The <code>pymmcore.CMMCore</code> methods below are available as inherited methods, but are not reimplemented in the <code>CMMCorePlus</code> subclass.  They are documented here for completeness.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.CMMCorePlus","title":"<code>pymmcore_plus.CMMCorePlus</code>","text":"<p>Wrapper for CMMCore with extended functionality.</p> <p>Parameters:</p> Name Type Description Default <code>mm_path</code> <code>str | None, optional</code> <p>Path to the Micro-Manager installation. If <code>None</code> (default), will use the return value of <code>pymmcore_plus.find_micromanager</code>.</p> <code>None</code> <code>adapter_paths</code> <code>Sequence[str], optional</code> <p>Paths to search for device adapters, by default ()</p> <code>()</code>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.canSequenceEvents","title":"<code>canSequenceEvents(e1: MDAEvent, e2: MDAEvent, cur_length: int = -1) -&gt; bool</code>","text":"<p>Check whether two <code>useq.MDAEvent</code> are sequenceable by this core instance.</p> <p>Micro-manager calls hardware triggering \"sequencing\".  Two events can be sequenced if all device properties that are changing between the first and second event support sequencing.</p> <p>If <code>cur_length</code> is provided, it is used to determine if the sequence is \"full\" (i.e. the sequence is already at the maximum length) as determined by the <code>...SequenceMaxLength()</code> method corresponding to the device property.</p> <p>See: https://micro-manager.org/Hardware-based_Synchronization_in_Micro-Manager</p> <p> This method is new in <code>CMMCorePlus</code>.</p> <p>Parameters:</p> Name Type Description Default <code>e1</code> <code>MDAEvent</code> <p>The first event.</p> required <code>e2</code> <code>MDAEvent</code> <p>The second event.</p> required <code>cur_length</code> <code>int</code> <p>The current length of the sequence.  Used when checking <code>.get&lt;...&gt;SequenceMaxLength</code> for a given property. If the current length is greater than the max length, the events cannot be sequenced. By default -1, which means the current length is not checked.</p> <code>-1</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the events can be sequenced, False otherwise.</p> <p>Examples:</p> <p>Note</p> <p>The results here will depend on the current state of the core and devices.</p> <pre><code>&gt;&gt;&gt; from useq import MDAEvent\n&gt;&gt;&gt; core = CMMCorePlus.instance()\n&gt;&gt;&gt; core.loadSystemConfiguration()\n&gt;&gt;&gt; core.canSequenceEvents(MDAEvent(), MDAEvent())\nTrue\n&gt;&gt;&gt; core.canSequenceEvents(MDAEvent(x_pos=1), MDAEvent(x_pos=2))\nFalse\n&gt;&gt;&gt; core.canSequenceEvents(\n...     MDAEvent(channel={'config': 'DAPI'}),\n...     MDAEvent(channel={'config': 'FITC'})\n... )\nFalse\n</code></pre>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.channelGroup_pattern","title":"<code>channelGroup_pattern() -&gt; Pattern</code>  <code>writable</code> <code>property</code>","text":"<p>The regex pattern used to identify channel groups.</p> <p> *This property is new in <code>CMMCorePlus</code>.</p> <p>It is the regex used by <code>getOrGuessChannelGroup</code> to find a config group likely to be a channel group in <code>getAvailableConfigGroups</code> if <code>getChannelGroup</code> returns <code>None</code>.</p> <p>By default:</p> <pre><code>re.compile(\"(chan{1,2}(el)?|filt(er)?)s?\", re.IGNORECASE)\n</code></pre>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.defineConfig","title":"<code>defineConfig(groupName: str, configName: str, deviceLabel: str | None = None, propName: str | None = None, value: str | None = None) -&gt; None</code>","text":"<p>Defines a configuration.</p> <p>Why Override? To emit a <code>configDefined</code> event.  Also, if <code>groupName</code> is not a defined group, then <code>defineConfigGroup(groupName)</code> is called.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.definePixelSizeConfig","title":"<code>definePixelSizeConfig(*args: str, **kwargs: str) -&gt; None</code>","text":"<p>Defines an empty pixel size entry.</p> <p>Why Override? To emit a <code>pixelSizeChanged</code> event.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.deleteConfig","title":"<code>deleteConfig(groupName: str, configName: str, deviceLabel: str | None = None, propName: str | None = None) -&gt; None</code>","text":"<p>Delete <code>configName</code> from <code>groupName</code>.</p> <p>Why Override? To emit a <code>configDeleted</code> event.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.deleteConfigGroup","title":"<code>deleteConfigGroup(groupName: str) -&gt; None</code>","text":"<p>Deletes an entire configuration <code>group</code>.</p> <p>Why Override? To emit a <code>configGroupDeleted</code> event.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.deletePixelSizeConfig","title":"<code>deletePixelSizeConfig(resolutionID: str) -&gt; None</code>","text":"<p>Delete the pixel size configuration for the given <code>resolutionID</code>.</p> <p>Why Override? To emit a <code>pixelSizeChanged</code> event.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.describe","title":"<code>describe(sort: str | None = None, show_config_groups: bool = False, show_available: bool = False) -&gt; None</code>","text":"<p>Print information table with the current configuration.</p> <p>Intended to provide a quick overview of the microscope configuration during interactive terminal usage.</p> <p> This method is new in <code>CMMCorePlus</code>.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.detectDevice","title":"<code>detectDevice(deviceLabel: str) -&gt; DeviceDetectionStatus</code>","text":"<p>Tries to communicate to a device through a given serial port.</p> <p>Used to automate discovery of correct serial port. Also configures the serial port correctly.</p> <p>Why Override? The returned <code>pymmcore_plus.DeviceDetectionStatus</code> enum is more interpretable than the raw <code>int</code> returned by <code>pymmcore</code></p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.events","title":"<code>events() -&gt; PCoreSignaler</code>  <code>property</code>","text":"<p>Signaler for core events.</p> <p> This method is new in <code>CMMCorePlus</code>.</p> <p>This attribute allows connecting callbacks to various events that occur within the core. See <code>pymmcore_plus.core.events.PCoreSignaler</code> documentation for details of the available signals, and how to connect to them.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.fixImage","title":"<code>fixImage(img: np.ndarray, ncomponents: int | None = None) -&gt; np.ndarray</code>","text":"<p>Fix img shape/dtype based on <code>self.getNumberOfComponents()</code>.</p> <p> This method is new in <code>CMMCorePlus</code>.</p> <p>convert images with n_components &gt; 1 to a shape (w, h, num_components) and dtype <code>img.dtype.itemsize//ncomp</code></p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>np.ndarray</code> <p>input image</p> required <code>ncomponents</code> <code>int, optional</code> <p>number of components in the image, by default <code>self.getNumberOfComponents()</code></p> <code>None</code> <p>Returns:</p> Type Description <code>np.ndarray</code> <p>output image (possibly new shape and dtype)</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.getAdapterObject","title":"<code>getAdapterObject(library_name: str) -&gt; DeviceAdapter</code>","text":"<p>Return an <code>Adapter</code> object bound to library_name on this core.</p> <p> This method is new in <code>CMMCorePlus</code>.</p> <p><code>Adapter</code> objects are a convenient object oriented way to interact with device adapters. They allow you to call any method on <code>CMMCore</code> that normally requires a <code>library_name</code> as the first argument as an argument-free method on the <code>Adapter</code> object.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.getAutoFocusOffset","title":"<code>getAutoFocusOffset() -&gt; float</code>","text":""},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.getCameraChannelNames","title":"<code>getCameraChannelNames() -&gt; tuple[str, ...]</code>","text":"<p>Convenience method to call <code>getCameraChannelName</code> for all camera channels.</p> <p> This method is new in <code>CMMCorePlus</code>.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.getConfigData","title":"<code>getConfigData(configGroup: str, configName: str, *, native: bool = False) -&gt; Configuration | pymmcore.Configuration</code>","text":"<p>Return the configuration object for a given <code>configGroup</code> and <code>configName</code>.</p> <p>Why Override? The <code>pymmcore_plus.Configuration</code> object returned when <code>native=False</code> (the default) provides a nicer <code>Mapping</code> interface. Pass <code>native=True</code> to get the original <code>pymmcore.Configuration</code> object.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.getConfigGroupObject","title":"<code>getConfigGroupObject(group_name: str, allow_missing: bool = False) -&gt; ConfigGroup</code>","text":"<p>Return a <code>ConfigGroup</code> object bound to group_name on this core.</p> <p> This method is new in <code>CMMCorePlus</code>.</p> <p><code>ConfigGroup</code> objects are a convenient object oriented way to interact with configuration groups (i.e. groups of Configuration Presets in Micro-Manager). They allow you to call any method on <code>CMMCore</code> that normally requires a <code>groupName</code> as the first argument as an argument-free method on the <code>ConfigGroup</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>group_name</code> <code>str</code> <p>Configuration group name to get a config group object for.</p> required <code>allow_missing</code> <code>bool</code> <p>If <code>False</code> and the <code>ConfigGroup</code> does not exist, a <code>KeyError</code> will be raised. By default False.</p> <code>False</code> <p>Returns:</p> Type Description <code>ConfigGroup</code> <p><code>ConfigGroup</code> object bound to <code>group_name</code> on this core.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.getConfigGroupState","title":"<code>getConfigGroupState(group: str, *, native: bool = False) -&gt; Configuration | pymmcore.Configuration</code>","text":"<p>Return the state of the devices included in the specified <code>group</code>.</p> <p>Why Override? The <code>pymmcore_plus.Configuration</code> object returned when <code>native=False</code> (the default) provides a nicer <code>Mapping</code> interface. Pass <code>native=True</code> to get the original <code>pymmcore.Configuration</code> object.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.getConfigGroupStateFromCache","title":"<code>getConfigGroupStateFromCache(group: str, *, native: bool = False) -&gt; Configuration | pymmcore.Configuration</code>","text":"<p>Return the state of the system cache, for the devices in the specified group.</p> <p>Why Override? The <code>pymmcore_plus.Configuration</code> object returned when <code>native=False</code> (the default) provides a nicer <code>Mapping</code> interface. Pass <code>native=True</code> to get the original <code>pymmcore.Configuration</code> object.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.getConfigState","title":"<code>getConfigState(group: str, config: str, *, native: bool = False) -&gt; Configuration | pymmcore.Configuration</code>","text":"<p>Return state of devices included in the specified configuration.</p> <p>Why Override? The <code>pymmcore_plus.Configuration</code> object returned when <code>native=False</code> (the default) provides a nicer <code>Mapping</code> interface. Pass <code>native=True</code> to get the original <code>pymmcore.Configuration</code> object.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.getCurrentDeviceOfType","title":"<code>getCurrentDeviceOfType(device_type: DeviceTypesWithCurrent) -&gt; DeviceLabel | Literal['']</code>","text":"<p>Return the current device of type <code>device_type</code>.</p> <p>Only the following device types have a \"current\" device:     - CameraDevice     - ShutterDevice     - StageDevice     - XYStageDevice     - AutoFocusDevice     - SLMDevice     - GalvoDevice     - ImageProcessorDevice</p> <p>Calling this method with any other device type will raise a <code>ValueError</code>.</p> <p> This method is new in <code>CMMCorePlus</code>.</p> <p>Parameters:</p> Name Type Description Default <code>device_type</code> <code>DeviceType</code> <p>The type of device to get the current device for. See <code>DeviceType</code> for a list of device types.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The label of the current device of type <code>device_type</code>. If no device of that type is currently set, an empty string is returned.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the core does not have the concept of a \"current\" device of the provided <code>device_type</code>.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.getDeviceInitializationState","title":"<code>getDeviceInitializationState(label: str) -&gt; DeviceInitializationState</code>","text":"<p>Queries the initialization state of the given device.</p> <p>Why Override? The returned <code>pymmcore_plus.DeviceInitializationState</code> enum is more interpretable than the raw <code>int</code> returned by <code>pymmcore</code></p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.getDeviceObject","title":"<code>getDeviceObject(device_label: str, device_type: type[_DT] | DeviceType = DeviceType.Any) -&gt; _DT | _device.Device</code>","text":"<p>Return a <code>Device</code> object bound to device_label on this core.</p> <p> This method is new in <code>CMMCorePlus</code>.</p> <p><code>Device</code> objects are a convenient object oriented way to interact with devices. They allow you to call any method on <code>CMMCore</code> that normally requires a <code>deviceLabel</code> as the first argument as an argument-free method on the <code>Device</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>device_label</code> <code>str</code> <p>Device label to get a device object for.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; core = CMMCorePlus()\n&gt;&gt;&gt; cam = core.getDeviceObject(\"DemoCamera\")\n&gt;&gt;&gt; cam.isLoaded()\nFalse\n&gt;&gt;&gt; cam.load(\"DemoCamera\", \"DCam\")\n&gt;&gt;&gt; cam.isLoaded()\nTrue\n&gt;&gt;&gt; cam.initialize()\n</code></pre> <p>get the device schema</p> <pre><code>&gt;&gt;&gt; cam.schema()\n{\n    'title': 'DCam',\n    'description': 'Demo camera',\n    'type': 'object',\n    'properties': {\n        'HubID': {'type': 'string', 'readOnly': True, 'default': ''},\n        'MaximumExposureMs': {'type': 'number', 'preInit': True},\n        'TransposeCorrection': {'type': 'boolean'},\n        'TransposeMirrorX': {'type': 'boolean'},\n        'TransposeMirrorY': {'type': 'boolean'},\n        'TransposeXY': {'type': 'boolean'}\n    }\n}\n</code></pre>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.getDeviceSchema","title":"<code>getDeviceSchema(device_label: str) -&gt; DeviceSchema</code>","text":"<p>Return JSON-schema describing device <code>device_label</code> and its properties.</p> <p> This method is new in <code>CMMCorePlus</code>. It provides a convenient way to get all of the information about a device in a single call.</p> <p>Returns:</p> Type Description <code>DeviceSchema</code> <p>JSON-schema describing device <code>device_label</code> and its properties.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; core = CMMCorePlus()\n&gt;&gt;&gt; core.loadDevice(\"DemoCamera\", \"DemoCamera\", \"DCam\")\n&gt;&gt;&gt; core.getDeviceSchema(\"DemoCamera\")\n{\n    'title': 'DCam',\n    'description': 'Demo camera',\n    'type': 'object',\n    'properties': {\n        'HubID': {'type': 'string', 'readOnly': True, 'default': ''},\n        'MaximumExposureMs': {'type': 'number', 'preInit': True},\n        'TransposeCorrection': {'type': 'boolean'},\n        'TransposeMirrorX': {'type': 'boolean'},\n        'TransposeMirrorY': {'type': 'boolean'},\n        'TransposeXY': {'type': 'boolean'}\n    }\n}\n</code></pre>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.getDeviceType","title":"<code>getDeviceType(label: str) -&gt; DeviceType</code>","text":"<p>Return device type for a given device.</p> <p>Why Override? The returned <code>pymmcore_plus.Device</code> enum is more interpretable than the raw <code>int</code> returned by <code>pymmcore</code></p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.getFocusDirection","title":"<code>getFocusDirection(stageLabel: str) -&gt; FocusDirection</code>","text":"<p>Return device type for a given device.</p> <p>Why Override? The returned <code>pymmcore_plus.FocusDirection</code> enum is more interpretable than the raw <code>int</code> returned by <code>pymmcore</code></p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.getImage","title":"<code>getImage(numChannel: int | None = None, *, fix: bool = True) -&gt; np.ndarray</code>","text":"<p>Return the internal image buffer.</p> <p>Why Override? To fix the shape of images with n_components &gt; 1 (like RGB images)</p> <p>Parameters:</p> Name Type Description Default <code>numChannel</code> <code>int, optional</code> <p>The camera channel to get the image from.  If None, (the default), then Multi-Channel cameras will return the content of the first channel.</p> <code>None</code> <code>fix</code> <code>bool, default</code> <p>If <code>True</code> (the default), then images with n_components &gt; 1 (like RGB images) will be reshaped to (w, h, n_components) using <code>fixImage</code>.</p> <code>True</code>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.getLastImageAndMD","title":"<code>getLastImageAndMD(channel: int | None = None, slice: int | None = None, *, fix: bool = True) -&gt; tuple[np.ndarray, Metadata]</code>","text":"<p>Return last image from the circular buffer along with metadata.</p> <p> This method is new in <code>CMMCorePlus</code>.</p> <p>This is a convenience method that is very similar to <code>getLastImageMD</code>, except that it doesn't require instantiating a <code>MetaData</code> object first. It returns a tuple containing the image and a <code>pymmcore_plus.Metadata</code> object.</p> <p>It also adds a <code>fix</code> parameter, which reshapes multi-component images (like RGB images) to (w, h, n_components) using <code>fixImage</code> by default.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int, optional</code> <p>Channel index, by default None</p> <code>None</code> <code>slice</code> <code>int, optional</code> <p>Slice index, by default None</p> <code>None</code> <code>fix</code> <code>bool, default</code> <p>If <code>True</code> (the default), then images with n_components &gt; 1 (like RGB images) will be reshaped to (w, h, n_components) using <code>fixImage</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>tuple[np.ndarray, Metadata]</code> <p>Image and metadata</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.getMultiROI","title":"<code>getMultiROI(*_: Any) -&gt; tuple[list[int], list[int], list[int], list[int]]</code>","text":"<p>Get multiple ROIs from the current camera device.</p> <p>Will fail if the camera does not support multiple ROIs. Will return empty vectors if multiple ROIs are not currently being used.</p> <p>Why Override? So that the user doesn't need to pass in four empty pymmcore.UnsignedVector() objects.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.getNBeforeLastImageAndMD","title":"<code>getNBeforeLastImageAndMD(n: int, *, fix: bool = True) -&gt; tuple[np.ndarray, Metadata]</code>","text":"<p>Return image taken <code>n</code> images ago along with associated metadata.</p> <p> This method is new in <code>CMMCorePlus</code>.</p> <p>This is a convenience method that is very similar to <code>getNBeforeLastImageMD</code>, except that it doesn't require instantiating a <code>MetaData</code> object first. It returns a tuple containing the image and a <code>pymmcore_plus.Metadata</code> object.</p> <p>It also adds a <code>fix</code> parameter, which reshapes multi-component images (like RGB images) to (w, h, n_components) using <code>fixImage</code> by default.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>The number of images ago to retrieve. 0 is the last image, 1 is the image before that, etc.</p> required <code>fix</code> <code>bool, default</code> <p>If <code>True</code> (the default), then images with n_components &gt; 1 (like RGB images) will be reshaped to (w, h, n_components) using <code>fixImage</code>.</p> <code>True</code>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.getOrGuessChannelGroup","title":"<code>getOrGuessChannelGroup() -&gt; list[str]</code>","text":"<p>Get the channelGroup or find a likely set of candidates.</p> <p> This method is new in <code>CMMCorePlus</code>.</p> <p>If the group is not defined via <code>.getChannelGroup</code> then likely candidates will be found by searching for config groups with names that match this object's <code>channelGroup_pattern</code> property. This is a settable property with a default value of:</p> <pre><code>reg = re.compile(\"(chan{1,2}(el)?|filt(er)?)s?\", re.IGNORECASE)\n</code></pre>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.getPhysicalCameraDevice","title":"<code>getPhysicalCameraDevice(channel_index: int = 0) -&gt; str</code>","text":"<p>Return the name of the actual camera device for a given channel index.</p> <p> This method is new in <code>CMMCorePlus</code>. It provides a convenience for accessing the name of the actual camera device when using the multi-camera utility.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.getPixelSizeConfigData","title":"<code>getPixelSizeConfigData(configName: str, *, native: bool = False) -&gt; Configuration | pymmcore.Configuration</code>","text":"<p>Return the configuration object for a given pixel size preset <code>configName</code>.</p> <p>Why Override? The <code>pymmcore_plus.Configuration</code> object returned when <code>native=False</code> (the default) provides a nicer <code>Mapping</code> interface. Pass <code>native=True</code> to get the original <code>pymmcore.Configuration</code> object.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.getPropertyObject","title":"<code>getPropertyObject(device_label: str, property_name: str) -&gt; DeviceProperty</code>","text":"<p>Return a DeviceProperty object bound to a device/property on this core.</p> <p> This method is new in <code>CMMCorePlus</code>.</p> <p><code>DeviceProperty</code> objects are a convenient object oriented way to interact with a specific device properties. They allow you to call any method on <code>CMMCore</code> that normally requires a <code>deviceLabel</code> and <code>propertyName</code> as the first two arguments as an argument-free method on the <code>DeviceProperty</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>device_label</code> <code>str</code> <p>Device label to get a property object for.</p> required <code>property_name</code> <code>str</code> <p>Property name to get a property object for.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; core = CMMCorePlus()\n&gt;&gt;&gt; core.loadDevice(\"DemoCamera\", \"DemoCamera\", \"DCam\")\n&gt;&gt;&gt; core.initializeDevice(\"DemoCamera\")\n&gt;&gt;&gt; core.setCameraDevice(\"DemoCamera\")\n&gt;&gt;&gt; exposure = core.getPropertyObject(\"DemoCamera\", \"Exposure\")\n&gt;&gt;&gt; exposure.type()\n&lt;PropertyType.Float: 2&gt;\n&gt;&gt;&gt; exposure.upperLimit()\n10000.0\n</code></pre> <p>get/set property values easily:</p> <pre><code>&gt;&gt;&gt; exposure.value\n10.0\n&gt;&gt;&gt; exposure.value = 5.0\n&gt;&gt;&gt; exposure.value\n5.0\n&gt;&gt;&gt; core.getExposure()  # changes reflected in core\n5.0\n</code></pre>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.getPropertyType","title":"<code>getPropertyType(label: str, propName: str) -&gt; PropertyType</code>","text":"<p>Return the intrinsic property type for a given device and property.</p> <p>Why Override? The returned <code>pymmcore_plus.PropertyType</code> enum is more interpretable than the raw <code>int</code> returned by <code>pymmcore</code></p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.getSystemState","title":"<code>getSystemState(*, native: bool = False) -&gt; Configuration | pymmcore.Configuration</code>","text":"<p>Return the entire system state.</p> <p>Why Override? The <code>pymmcore_plus.Configuration</code> object returned when <code>native=False</code> (the default) provides a nicer <code>Mapping</code> interface. Pass <code>native=True</code> to get the original <code>pymmcore.Configuration</code> object.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.getSystemStateCache","title":"<code>getSystemStateCache(*, native: bool = False) -&gt; Configuration | pymmcore.Configuration</code>","text":"<p>Return the entire system state from cache.</p> <p>Why Override? The <code>pymmcore_plus.Configuration</code> object returned when <code>native=False</code> (the default) provides a nicer <code>Mapping</code> interface. Pass <code>native=True</code> to get the original <code>pymmcore.Configuration</code> object.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.getTaggedImage","title":"<code>getTaggedImage(channel_index: int = 0) -&gt; TaggedImage</code>","text":"<p>Return getImage as named tuple with metadata.</p> <p> This method is new in <code>CMMCorePlus</code>. It returns an object similar to MMCoreJ.getTaggedImage().</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.getTags","title":"<code>getTags(meta: Metadata | None = None, channel_index: int | None = None) -&gt; dict[str, Any]</code>","text":"<p>Return a dict of metadata tags for the state of the core.</p> <p>NOTE: this function is pretty slow, and is potentially called on every frame of an acquisition. It would be nice to determine what is absolutely necessary, and possible allow the user to specify what they want to include.</p> <p> This method is new in <code>CMMCorePlus</code>. It returns only the <code>.tags</code> attribute of what you would get with <code>getTaggedImage()</code> or <code>popNextTaggedImage()</code>.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.getZPosition","title":"<code>getZPosition() -&gt; float</code>","text":"<p>Obtains the current position of the Z axis of the Z stage in microns.</p> <p> This method is new in <code>CMMCorePlus</code>: added to complement <code>getXPosition</code> and <code>getYPosition</code></p> <p>Note</p> <p>This is simply an alias for <code>getPosition</code>], which returns the position of the current focus device when called without arguments.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.guessObjectiveDevices","title":"<code>guessObjectiveDevices() -&gt; list[str]</code>","text":"<p>Find any loaded devices that are likely to be an Objective/Nosepiece.</p> <p> This method is new in <code>CMMCorePlus</code>.</p> <p>Likely matches are loaded StateDevices with names that match this object's <code>objective_device_pattern</code> property. This is a settable property with a default value of::</p> <pre><code>re.compile(\"(.+)?(nosepiece|obj(ective)?)(turret)?s?\", re.IGNORECASE)\n</code></pre>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.instance","title":"<code>instance() -&gt; CMMCorePlus</code>  <code>classmethod</code>","text":"<p>Return the global singleton instance of <code>CMMCorePlus</code>.</p> <p> This method is new in <code>CMMCorePlus</code>.</p> <p>In many cases, a single instance of <code>CMMCorePlus</code> is all that will be created in a given session.  This class method provides a convenient way to access that instance.</p> <p>Tip</p> <p>Creating/accessing a <code>CMMCorePlus</code> object using <code>CMMCorePlus.instance()</code> is a convenient way to access the same core instance from multiple places in your code. All widgets in <code>pymmcore-widgets</code> also use <code>CMMCorePlus.instance()</code> by default, so any widgets you use will automatically connect to the same core instance without any additional configuration.</p> <p>Attempts are made to make it thread-safe.  But please open an issue if you find any problems.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.iterConfigGroups","title":"<code>iterConfigGroups() -&gt; Iterator[ConfigGroup]</code>","text":"<p>Iterate <code>ConfigGroup</code> objects for all configs.</p> <p> This method is new in <code>CMMCorePlus</code>.</p> <p>Yields:</p> Type Description <code>ConfigGroup</code> <p><code>ConfigGroup</code> objects</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.iterDeviceAdapters","title":"<code>iterDeviceAdapters(adapter_pattern: str | re.Pattern | None = None, *, as_object: bool = True) -&gt; Iterator[DeviceAdapter] | Iterator[str]</code>","text":"<p>Iterate over all available device adapters.</p> <p> This method is new in <code>CMMCorePlus</code>.</p> <p>It offers a convenient way to iterate over available device adaptor libraries, optionally filtering adapter library name. It can also yield <code>Adapter</code> objects if <code>as_object</code> is <code>True</code> (the default)</p> <p>Parameters:</p> Name Type Description Default <code>adapter_pattern</code> <code>str | None</code> <p>Device adapter name or pattern to filter by, by default all device adapters will be yielded.</p> <code>None</code> <code>as_object</code> <code>bool, optional</code> <p>If <code>True</code>, <code>Adapter</code> objects will be yielded instead of library name strings. By default True</p> <code>True</code> <p>Yields:</p> Type Description <code>Device | str</code> <p><code>Device</code> objects (if <code>as_object==True</code>) or device label strings.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.iterDevices","title":"<code>iterDevices(device_type: int | Iterable[int] | None = None, device_label: str | re.Pattern | None = None, device_adapter: str | re.Pattern | None = None, *, as_object: bool = True) -&gt; Iterator[_device.Device] | Iterator[str]</code>","text":"<p>Iterate over currently loaded devices.</p> <p> This method is new in <code>CMMCorePlus</code>.</p> <p>It offers a convenient way to iterate over loaded devices, optionally filtering by <code>DeviceType</code> and/or device label. It can also yield <code>Device</code> objects if <code>as_object</code> is <code>True</code> (the default).</p> <p>Parameters:</p> Name Type Description Default <code>device_type</code> <code>DeviceType | None</code> <p>DeviceType to filter by, by default all device types will be yielded.</p> <code>None</code> <code>device_label</code> <code>str | None</code> <p>Device label to filter by, by default all device labels will be yielded.</p> <code>None</code> <code>device_adapter</code> <code>str | None</code> <p>Device adapter library to filter by, by default devices from all libraries will be yielded.</p> <code>None</code> <code>as_object</code> <code>bool, optional</code> <p>If <code>True</code>, <code>Device</code> objects will be yielded instead of device label strings. By default True</p> <code>True</code> <p>Yields:</p> Type Description <code>Device | str</code> <p><code>Device</code> objects (if <code>as_object==True</code>) or device label strings.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.iterProperties","title":"<code>iterProperties(property_type: int | Iterable[int] | None = None, property_name_pattern: str | re.Pattern | None = None, *, device_type: int | Iterable[int] | None = None, device_label: str | re.Pattern | None = None, has_limits: bool | None = None, is_read_only: bool | None = None, is_sequenceable: bool | None = None, as_object: bool = True) -&gt; Iterator[DeviceProperty] | Iterator[tuple[str, str]]</code>","text":"<p>Iterate over currently loaded (device_label, property_name) pairs.</p> <p> This method is new in <code>CMMCorePlus</code>.</p> <p>It offers a convenient way to iterate over loaded devices, optionally filtering by <code>DeviceType</code> and/or device label. It can also yields <code>DeviceProperty</code> objects if <code>as_object</code> is <code>True</code> (the default).</p> <p>Parameters:</p> Name Type Description Default <code>property_type</code> <code>int | Sequence[int] | None</code> <p>PropertyType (or types) to filter by, by default all property types will be yielded.</p> <code>None</code> <code>property_name_pattern</code> <code>str | re.Pattern | None</code> <p>Property name to filter by, by default all property names will be yielded. May be a compiled regular expression or a string, in which case it will be compiled with <code>re.IGNORECASE</code>.</p> <code>None</code> <code>device_type</code> <code>DeviceType | None</code> <p>DeviceType to filter by, by default all device types will be yielded.</p> <code>None</code> <code>device_label</code> <code>str | None</code> <p>Device label to filter by, by default all device labels will be yielded.</p> <code>None</code> <code>has_limits</code> <code>bool | None</code> <p>If provided, only properties with <code>hasPropertyLimits</code> matching this value will be yielded.</p> <code>None</code> <code>is_read_only</code> <code>bool | None</code> <p>If provided, only properties with <code>isPropertyReadOnly</code> matching this value will be yielded.</p> <code>None</code> <code>is_sequenceable</code> <code>bool | None</code> <p>If provided only properties with <code>isPropertySequenceable</code> matching this value will be yielded.</p> <code>None</code> <code>as_object</code> <code>bool, optional</code> <p>If <code>True</code>, <code>DeviceProperty</code> objects will be yielded instead of <code>(device_label, property_name)</code> tuples. By default True</p> <code>True</code> <p>Yields:</p> Type Description <code>DeviceProperty | tuple[str, str]</code> <p><code>DeviceProperty</code> objects (if <code>as_object==True</code>) or 2-tuples of (device_name, property_name)</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.loadDevice","title":"<code>loadDevice(label: str, moduleName: str, deviceName: str) -&gt; None</code>","text":"<p>Load a device from the plugin library.</p> <p>Why Override? To add much better error messages in the case of failure.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>Name to be assigned to the device during this core session.</p> required <code>moduleName</code> <code>str</code> <p>The name of the device adapter module (short name, not full file name). See <code>pymmcore.CMMCore.getDeviceAdapterNames</code> for a list of valid module names.</p> required <code>deviceName</code> <code>str</code> <p>the name of the device. The name must correspond to one of the names recognized by the specific plugin library. See <code>pymmcore.CMMCore.getAvailableDevices</code> for a list of valid device names.</p> required"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.loadSystemConfiguration","title":"<code>loadSystemConfiguration(fileName: str | Path = 'MMConfig_demo.cfg') -&gt; None</code>","text":"<p>Load a system config file conforming to the MM <code>.cfg</code> format.</p> <p>https://micro-manager.org/Micro-Manager_Configuration_Guide#configuration-file-syntax</p> <p>For relative paths, the current working directory is first checked, then the then device adapter path is checked.</p> <p>Why Override? This method overrides the default implementation to A) allow loading the <code>MMConfig_demo.cfg</code> file by default, B) to provide more flexible path declarations and C) better error messages when the file cannot be found.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.mda","title":"<code>mda() -&gt; MDARunner</code>  <code>property</code>","text":"<p>Return the <code>MDARunner</code> for this <code>CMMCorePlus</code> instance.</p> <p> This method is new in <code>CMMCorePlus</code>.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.objective_device_pattern","title":"<code>objective_device_pattern() -&gt; Pattern</code>  <code>writable</code> <code>property</code>","text":"<p>Pattern used to guess objective device labels.</p> <p> *This property is new in <code>CMMCorePlus</code>.</p> <p>It is the regex used by <code>guessObjectiveDevices</code> to find any devices that are likely to be objective devices.</p> <p>By default:</p> <pre><code>re.compile(\"(.+)?(nosepiece|obj(ective)?)(turret)?s?\", re.IGNORECASE)\n</code></pre>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.popNextImage","title":"<code>popNextImage(*, fix: bool = True) -&gt; np.ndarray</code>","text":"<p>Gets and removes the next image from the circular buffer.</p> <p>Why Override? to add the <code>fix</code> parameter, which reshapes multi-component images (like RGB images) to (w, h, n_components) using <code>fixImage</code> by default.</p> <p>Parameters:</p> Name Type Description Default <code>fix</code> <code>bool, default</code> <p>If <code>True</code> (the default), then images with n_components &gt; 1 (like RGB images) will be reshaped to (w, h, n_components) using <code>fixImage</code>.</p> <code>True</code>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.popNextImageAndMD","title":"<code>popNextImageAndMD(channel: int = 0, slice: int = 0, *, fix: bool = True) -&gt; tuple[np.ndarray, Metadata]</code>","text":"<p>Gets and removes the next image (and metadata) from the circular buffer.</p> <p> This method is new in <code>CMMCorePlus</code>.</p> <p>This is a convenience method that is very similar to <code>popNextImageMD</code>, except that it doesn't require instantiating a <code>MetaData</code> object first. It returns a tuple containing the image and a <code>pymmcore_plus.Metadata</code> object.</p> <p>It also adds a <code>fix</code> parameter, which reshapes multi-component images (like RGB images) to (w, h, n_components) using <code>fixImage</code> by default.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int, optional</code> <p>Channel index, by default None</p> <code>0</code> <code>slice</code> <code>int, optional</code> <p>Slice index, by default None</p> <code>0</code> <code>fix</code> <code>bool, default</code> <p>If <code>True</code> (the default), then images with n_components &gt; 1 (like RGB images) will be reshaped to (w, h, n_components) using <code>fixImage</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>tuple[np.ndarray, Metadata]</code> <p>Image and metadata</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.popNextTaggedImage","title":"<code>popNextTaggedImage(channel_index: int = 0) -&gt; TaggedImage</code>","text":"<p>Return popNextImageAndMD as named tuple with metadata.</p> <p> This method is new in <code>CMMCorePlus</code>. It returns an object similar to MMCoreJ.popNextTaggedImage().</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.registerCallback","title":"<code>registerCallback(*_: Never) -&gt; Never</code>","text":"<p>registerCallback is disallowed in pymmcore-plus!</p> <p>If you want to connect callbacks to events, use the <code>CMMCorePlus.events</code> property instead.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.register_mda_engine","title":"<code>register_mda_engine(engine: PMDAEngine) -&gt; None</code>","text":"<p>Set the MDA Engine to be used on <code>run_mda</code>.</p> <p> This method is new in <code>CMMCorePlus</code>.</p> <p>This will unregister the previous engine and emit an <code>mdaEngineRegistered</code> signal. The current Engine must not be running an MDA in order to register a new engine.</p> <p>Parameters:</p> Name Type Description Default <code>engine</code> <code>PMDAEngine</code> <p>Any object conforming to the PMDAEngine protocol.</p> required"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.run_mda","title":"<code>run_mda(events: Iterable[MDAEvent], *, output: SingleOutput | Sequence[SingleOutput] | None = None, block: bool = False) -&gt; Thread</code>","text":"<p>Run a sequence of useq.MDAEvent on a new thread.</p> <p> This method is new in <code>CMMCorePlus</code>.</p> <p>The currently registered MDAEngine (<code>core.mda.engine</code>) will be responsible for executing the acquisition.</p> <p>After starting the sequence you can pause or cancel with the mda with the mda object's <code>toggle_pause</code> and <code>cancel</code> methods.</p> <p>Parameters:</p> Name Type Description Default <code>events</code> <code>Iterable[useq.MDAEvent]</code> <p>An iterable of useq.MDAEvent to execute.  This may be an instance of useq.MDASequence, or any other iterable of useq.MDAEvent.</p> required <code>output</code> <code>SingleOutput | Sequence[SingleOutput] | None, optional</code> <p>The output handler(s) to use.  If None, no output will be saved. \"SingleOutput\" can be any of the following:</p> <ul> <li>A string or Path to a directory to save images to. A handler will be created automatically based on the extension of the path.</li> <li>A handler object that implements the <code>DataHandler</code> protocol, currently meaning it has a <code>frameReady</code> method.  See <code>mda_listeners_connected</code> for more details.</li> <li>A sequence of either of the above. (all will be connected)</li> </ul> <code>None</code> <code>block</code> <code>bool, optional</code> <p>If True, block until the sequence is complete, by default False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Thread</code> <p>The thread the sequence is running on.  Use <code>thread.join()</code> to block until done, or <code>thread.is_alive()</code> to check if the sequence is complete.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.saveSystemConfiguration","title":"<code>saveSystemConfiguration(filename: str) -&gt; None</code>","text":"<p>Saves the current system configuration to a text file.</p> <p>Why Override? To also save pixel size configurations.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.setAutoFocusOffset","title":"<code>setAutoFocusOffset(offset: float) -&gt; None</code>","text":"<p>Applies offset the one-shot focusing device.</p> <p>In micro-manager, there is some variability in the way that autofocus devices are implemented.  Some have a separate offset device, while others can directly set the offset of an associated device.  As a result, calling <code>setAutoFocusOffset</code>, may or may not do anything depending on the current autofocus device.</p> <p>This method attempts to detect known autofocus devices and</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.setAutoShutter","title":"<code>setAutoShutter(state: bool) -&gt; None</code>","text":"<p>Set shutter to automatically open and close when an image is acquired.</p> <p>Why Override? To emit an <code>autoShutterSet</code> event.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.setChannelGroup","title":"<code>setChannelGroup(channelGroup: str) -&gt; None</code>","text":"<p>Specifies the group determining the channel selection.</p> <p>...and send a channelGroupChanged signal.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.setConfig","title":"<code>setConfig(groupName: str, configName: str) -&gt; None</code>","text":"<p>Applies a configuration to a group.</p> <p>Why Override? The native <code>onConfigGroupChanged</code> callback is not always called whenever <code>CMMCore.setConfig</code> has been called. We override here to emit a <code>configSet</code> event whenever <code>setConfig</code> is called. See https://github.com/micro-manager/mmCoreAndDevices/issues/25 for details.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.setContext","title":"<code>setContext(**kwargs: Unpack[SetContextKwargs]) -&gt; Iterator[None]</code>","text":"<p>Set core properties in a context restoring the initial values on exit.</p> <p> This method is new in <code>CMMCorePlus</code>.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Keyword arguments may be any <code>Name</code> for which <code>get&lt;Name&gt;</code> and <code>set&lt;Name&gt;</code> methods exist (where the first letter in <code>&lt;Name&gt;</code> may be either lower or upper case).  For example, <code>setContext(exposure=10)</code> will call <code>setExposure(10)</code> when entering the context and <code>setExposure(&lt;initial&gt;)</code> when exiting the context. If the property is not found, a warning is logged and the property is skipped. If the value is a tuple, it is unpacked and passed to the <code>set&lt;Name&gt;</code> method (but lists are not unpacked).</p> <code>{}</code> <p>Examples:</p> <pre><code>core = CMMCorePlus.instance()\n\nwith core.setContext(autoShutter=False):\n    assert not core.getAutoShutter()\n    # do other stuff\n    ...\n\n# autoShutter is restored to its original value when the context exits\nassert core.getAutoShutter()\n</code></pre>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.setDeviceAdapterSearchPaths","title":"<code>setDeviceAdapterSearchPaths(paths: Sequence[str]) -&gt; None</code>","text":"<p>Set the device adapter search paths.</p> <p>Why Override?  In cases where MM device adapters use dynamically loaded libraries, the device adapter search paths must also be added to the <code>PATH</code> environment variable (e.g. https://github.com/micro-manager/pymmcore/issues/28). This method overrides the default implementation to ensure that the <code>PATH</code> environment variable is updated when the device adapter search paths are changed.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.setFocusDevice","title":"<code>setFocusDevice(focusLabel: str) -&gt; None</code>","text":"<p>Set the current Focus Device and emit a <code>propertyChanged</code> signal.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.setPixelSizeUm","title":"<code>setPixelSizeUm(resolutionID: str, pixSize: float) -&gt; None</code>","text":"<p>Set pixel size in microns for the specified <code>resolutionID</code>.</p> <p>Why Override? To emit a <code>pixelSizeChanged</code> event.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.setProperty","title":"<code>setProperty(label: str, propName: str, propValue: bool | float | int | str) -&gt; None</code>","text":"<p>Set property named <code>propName</code> on device <code>label</code> to <code>propValue</code>.</p> <p>Why Override?  In <code>MMCore</code>, the calling of the <code>onPropertyChanged</code> callback is left to the underlying device adapter, which means it is not always called.  This method overrides the default implementation to ensure that <code>events.propertyChanged</code> is always emitted when <code>setProperty</code> has been called and the property Value has actually changed.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.setROI","title":"<code>setROI(*args: Any) -&gt; None</code>","text":"<p>Set the camera Region of Interest (ROI).</p> <p>Why Override? To emit a <code>roiSet</code> event.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.setRelativeXYZPosition","title":"<code>setRelativeXYZPosition(dx: float = 0, dy: float = 0, dz: float = 0) -&gt; None</code>","text":"<p>Sets the relative XYZ position in microns.</p> <p> This method is new in <code>CMMCorePlus</code>.</p> <p>This is a convenience method that calls <code>setXYPosition</code> and <code>setZPosition</code> with the current position as the starting point.</p> <p>Parameters:</p> Name Type Description Default <code>dx</code> <code>float, optional</code> <p>The relative change in X position, by default 0</p> <code>0</code> <code>dy</code> <code>float, optional</code> <p>The relative change in Y position, by default 0</p> <code>0</code> <code>dz</code> <code>float, optional</code> <p>The relative change in Z position, by default 0</p> <code>0</code>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.setShutterOpen","title":"<code>setShutterOpen(*args: Any) -&gt; None</code>","text":"<p>Open or close the currently selected or <code>shutterLabel</code> shutter.</p> <p>Why Override? To emit a <code>propertyChanged</code> event.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.setState","title":"<code>setState(stateDeviceLabel: str, state: int) -&gt; None</code>","text":"<p>Set state (by position) on <code>stateDeviceLabel</code>, with reliable event emission.</p> <p>Why Override?  In <code>MMCore</code>, the calling of the <code>onPropertyChanged</code> callback is left to the underlying device adapter, which means it is not always called.  This method overrides the default implementation to ensure that <code>events.propertyChanged</code> is always emitted when <code>setProperty</code> has been called and the property Value has actually changed.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.setStateLabel","title":"<code>setStateLabel(stateDeviceLabel: str, stateLabel: str) -&gt; None</code>","text":"<p>Set state (by label) on <code>stateDeviceLabel</code>, with reliable event emission.</p> <p>Why Override?  In <code>MMCore</code>, the calling of the <code>onPropertyChanged</code> callback is left to the underlying device adapter, which means it is not always called.  This method overrides the default implementation to ensure that <code>events.propertyChanged</code> is always emitted when <code>setProperty</code> has been called and the property Value has actually changed.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.setXYPosition","title":"<code>setXYPosition(*args: Any) -&gt; None</code>","text":"<p>Sets the position of the XY stage in microns.</p> <p>Why Override? to store the last commanded stage position internally.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.setZPosition","title":"<code>setZPosition(val: float) -&gt; None</code>","text":"<p>Set the position of the current focus device in microns.</p> <p> This method is new in <code>CMMCorePlus</code>: added to complement <code>setXYPosition</code></p> <p>Note</p> <p>This is simply an alias for <code>setPosition</code>, which returns the position of the current focus device when called with a single argument.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.snap","title":"<code>snap(numChannel: int | None = None, *, fix: bool = True) -&gt; np.ndarray</code>","text":"<p>Snap and return an image.</p> <p> This method is new in <code>CMMCorePlus</code>.</p> <p>Convenience for calling <code>self.snapImage()</code> followed by returning the value of <code>self.getImage()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>numChannel</code> <code>int, optional</code> <p>The camera channel to get the image from.  If None, (the default), then Multi-Channel cameras will return the content of the first channel.</p> <code>None</code> <code>fix</code> <code>bool, default</code> <p>If <code>True</code> (the default), then images with n_components &gt; 1 (like RGB images) will be reshaped to (w, h, n_components) using <code>fixImage</code>.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>img</code> <code>np.ndarray</code>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.snapImage","title":"<code>snapImage() -&gt; None</code>","text":"<p>Acquires a single image with current settings.</p> <p>Why Override? to emit the <code>imageSnapped</code> event after snapping an image. and to emit shutter property changes if <code>getAutoShutter</code> is <code>True</code>.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.startContinuousSequenceAcquisition","title":"<code>startContinuousSequenceAcquisition(intervalMs: float = 0) -&gt; None</code>","text":"<p>Start a ContinuousSequenceAcquisition.</p> <p>Why Override? To emit a <code>startContinuousSequenceAcquisition</code> event.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.startSequenceAcquisition","title":"<code>startSequenceAcquisition(*args: Any) -&gt; None</code>","text":"<p>Starts streaming camera sequence acquisition.</p> <p>This command does not block the calling thread for the duration of the acquisition.</p> <p>Why Override? To emit a <code>startSequenceAcquisition</code> event.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.state","title":"<code>state(*, cached: bool = True, include_time: bool = False, **_kwargs: Any) -&gt; SummaryMetaV1</code>","text":"<p>Return info on the current state of the core.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.stopSequenceAcquisition","title":"<code>stopSequenceAcquisition(cameraLabel: str | None = None) -&gt; None</code>","text":"<p>Stops streaming camera sequence acquisition.</p> <p>(for a specified camera if <code>cameraLabel</code> is provided.)</p> <p>Why Override? To emit a <code>stopSequenceAcquisition</code> event.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.systemConfigurationFile","title":"<code>systemConfigurationFile() -&gt; str | None</code>","text":"<p>Return the path to the last loaded system configuration file, or <code>None</code>.</p> <p> This method is new in <code>CMMCorePlus</code>.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.unloadAllDevices","title":"<code>unloadAllDevices() -&gt; None</code>","text":"<p>Unload all devices from the core and reset all configuration data.</p> <p>Why Override? To add logging.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore","title":"<code>pymmcore.CMMCore</code>","text":""},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.addGalvoPolygonVertex","title":"<code>addGalvoPolygonVertex(galvoLabel: str, polygonIndex: int, x: float, y: float) -&gt; None</code>","text":"<p>Add a vertex to a galvo polygon.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.clearCircularBuffer","title":"<code>clearCircularBuffer() -&gt; None</code>","text":"<p>Removes all images from the circular buffer.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.clearROI","title":"<code>clearROI() -&gt; None</code>","text":"<p>Set the region of interest of the current camera to the full frame.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.debugLogEnabled","title":"<code>debugLogEnabled() -&gt; bool</code>","text":"<p>Indicates if logging of debug messages is enabled</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.defineConfigGroup","title":"<code>defineConfigGroup(groupName: str) -&gt; None</code>","text":"<p>Creates an empty configuration group.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.defineStateLabel","title":"<code>defineStateLabel(stateDeviceLabel: DeviceLabel | str, state: int, stateLabel: str) -&gt; None</code>","text":"<p>Defines a label for the specific state.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.deleteGalvoPolygons","title":"<code>deleteGalvoPolygons(galvoLabel: DeviceLabel | str) -&gt; None</code>","text":"<p>Remove all added polygons</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.deviceBusy","title":"<code>deviceBusy(label: DeviceLabel | str) -&gt; bool</code>","text":"<p>Checks the busy status of the specific device.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.deviceTypeBusy","title":"<code>deviceTypeBusy(devType: DeviceType) -&gt; bool</code>","text":"<p>Checks the busy status for all devices of the specific type.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.displaySLMImage","title":"<code>displaySLMImage(slmLabel: DeviceLabel | str) -&gt; None</code>","text":"<p>Display the waiting image on the SLM.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.enableContinuousFocus","title":"<code>enableContinuousFocus(enable: bool) -&gt; None</code>","text":"<p>Enables or disables the operation of the continuous focusing hardware device.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.enableDebugLog","title":"<code>enableDebugLog(enable: bool) -&gt; None</code>","text":"<p>Enable or disable logging of debug messages.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.enableFeature","title":"<code>enableFeature(name: FeatureFlag | str, enable: bool) -&gt; None</code>","text":"<p>Enable or disable the given Core feature.</p> <p>Core features control whether experimental functionality (which is subject to breaking changes) is exposed, or whether stricter API usage is enforced.</p> <p>Currently switchable features:</p> <ul> <li>\"StrictInitializationChecks\" (default: disabled) When enabled, an   exception is thrown when an operation requiring an initialized device is   attempted on a device that is not successfully initialized. When disabled,   no exception is thrown and a warning is logged (and the operation may   potentially cause incorrect behavior or a crash).</li> <li>\"ParallelDeviceInitialization\" (default: enabled) When enabled, serial ports   are initialized in serial order, and all other devices are in parallel, using   multiple threads, one per device module.  Early testing shows this to be   reliable, but switch this off when issues are encountered during   device initialization.</li> </ul>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.enableStderrLog","title":"<code>enableStderrLog(enable: bool) -&gt; None</code>","text":"<p>Enables or disables log message display on the standard console.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.fullFocus","title":"<code>fullFocus() -&gt; None</code>","text":"<p>Performs focus acquisition and lock for the one-shot focusing device.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getAPIVersionInfo","title":"<code>getAPIVersionInfo() -&gt; str</code>","text":"<p>Returns the module and device interface versions.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getAllowedPropertyValues","title":"<code>getAllowedPropertyValues(label: DeviceLabel | str, propName: PropertyName | str) -&gt; Tuple[str, ...]</code>","text":"<p>Returns all valid values for the specified property.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getAutoFocusDevice","title":"<code>getAutoFocusDevice() -&gt; DeviceLabel | Literal['']</code>","text":"<p>Returns the label of the currently selected auto-focus device.</p> <p>Returns empty string if no auto-focus device is selected.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getAutoShutter","title":"<code>getAutoShutter() -&gt; bool</code>","text":"<p>Returns the current setting of the auto-shutter option.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getAvailableConfigGroups","title":"<code>getAvailableConfigGroups() -&gt; Tuple[ConfigGroupName, ...]</code>","text":"<p>Returns the names of all defined configuration groups</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getAvailableConfigs","title":"<code>getAvailableConfigs(configGroup: ConfigGroupName | str) -&gt; Tuple[ConfigPresetName, ...]</code>","text":"<p>Returns all defined configuration (preset) names in a given group</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getAvailableDeviceDescriptions","title":"<code>getAvailableDeviceDescriptions(library: AdapterName | str) -&gt; Tuple[str, ...]</code>","text":"<p>Get descriptions for available devices from the specified library.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getAvailableDeviceTypes","title":"<code>getAvailableDeviceTypes(library: AdapterName | str) -&gt; Tuple[int, ...]</code>","text":"<p>Get type information for available devices from the specified library.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getAvailableDevices","title":"<code>getAvailableDevices(library: AdapterName | str) -&gt; Tuple[DeviceName, ...]</code>","text":"<p>Get available devices from the specified device library.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getAvailablePixelSizeConfigs","title":"<code>getAvailablePixelSizeConfigs() -&gt; Tuple[PixelSizeConfigName, ...]</code>","text":"<p>Returns all defined resolution preset names</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getBufferFreeCapacity","title":"<code>getBufferFreeCapacity() -&gt; int</code>","text":"<p>Returns the number of images that can be added to the buffer without overflowing.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getBufferTotalCapacity","title":"<code>getBufferTotalCapacity() -&gt; int</code>","text":"<p>Returns the total number of images that can be stored in the buffer</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getBytesPerPixel","title":"<code>getBytesPerPixel() -&gt; int</code>","text":"<p>How many bytes for each pixel.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getCameraChannelName","title":"<code>getCameraChannelName(channelNr: int) -&gt; str</code>","text":"<p>Returns the name of the requested channel as known by the default camera</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getCameraDevice","title":"<code>getCameraDevice() -&gt; DeviceLabel | Literal['']</code>","text":"<p>Returns the label of the currently selected camera device.</p> <p>Returns empty string if no camera device is selected.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getChannelGroup","title":"<code>getChannelGroup() -&gt; ConfigGroupName | Literal['']</code>","text":"<p>Returns the group determining the channel selection.</p> <p>Returns empty string if no channel group is selected.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getCircularBufferMemoryFootprint","title":"<code>getCircularBufferMemoryFootprint() -&gt; int</code>","text":"<p>Returns the size of the Circular Buffer in MB</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getCoreErrorText","title":"<code>getCoreErrorText(code: int) -&gt; str</code>","text":"<p>Returns a pre-defined error test with the given error code</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getCurrentConfig","title":"<code>getCurrentConfig(groupName: ConfigGroupName | str) -&gt; ConfigPresetName | Literal['']</code>","text":"<p>Returns the current configuration (preset) for a given group.</p> <p>Returns empty string if no configuration is selected.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getCurrentConfigFromCache","title":"<code>getCurrentConfigFromCache(groupName: ConfigGroupName | str) -&gt; ConfigPresetName | Literal['']</code>","text":"<p>Returns the configuration for a given group based on the data in the cache.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getCurrentFocusScore","title":"<code>getCurrentFocusScore() -&gt; float</code>","text":"<p>Returns the focus score from the default focusing device measured at the current Z position.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getDeviceAdapterNames","title":"<code>getDeviceAdapterNames() -&gt; Tuple[AdapterName, ...]</code>","text":"<p>Return the names of discoverable device adapters.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getDeviceAdapterSearchPaths","title":"<code>getDeviceAdapterSearchPaths() -&gt; Tuple[str, ...]</code>","text":"<p>Return the current device adapter search paths.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getDeviceDelayMs","title":"<code>getDeviceDelayMs(label: DeviceLabel | str) -&gt; float</code>","text":"<p>Reports action delay in milliseconds for the specific device.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getDeviceDescription","title":"<code>getDeviceDescription(label: DeviceLabel | str) -&gt; str</code>","text":"<p>Returns description text for a given device label. \"Description\" is determined by the library and is immutable.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getDeviceLibrary","title":"<code>getDeviceLibrary(label: DeviceLabel | str) -&gt; AdapterName</code>","text":"<p>Returns device library (aka module, device adapter) name.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getDeviceName","title":"<code>getDeviceName(label: DeviceLabel | str) -&gt; DeviceName</code>","text":"<p>Returns device name for a given device label.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getDevicePropertyNames","title":"<code>getDevicePropertyNames(label: DeviceLabel | str) -&gt; Tuple[PropertyName, ...]</code>","text":"<p>Returns all property names supported by the device.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getExposureSequenceMaxLength","title":"<code>getExposureSequenceMaxLength(cameraLabel: DeviceLabel | str) -&gt; int</code>","text":"<p>Gets the maximum length of a camera's exposure sequence.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getFocusDevice","title":"<code>getFocusDevice() -&gt; DeviceLabel | Literal['']</code>","text":"<p>Returns the label of the currently selected focus device.</p> <p>Returns empty string if no focus device is selected.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getGalvoChannel","title":"<code>getGalvoChannel(galvoLabel: DeviceLabel | str) -&gt; str</code>","text":"<p>Get the name of the active galvo channel (for a multi-laser galvo device).</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getGalvoDevice","title":"<code>getGalvoDevice() -&gt; DeviceLabel | Literal['']</code>","text":"<p>Returns the label of the currently selected Galvo device.</p> <p>Returns empty string if no Galvo device is selected.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getGalvoXMinimum","title":"<code>getGalvoXMinimum(galvoLabel: DeviceLabel | str) -&gt; float</code>","text":"<p>Get the Galvo x minimum</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getGalvoXRange","title":"<code>getGalvoXRange(galvoLabel: DeviceLabel | str) -&gt; float</code>","text":"<p>Get the Galvo x range</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getGalvoYMinimum","title":"<code>getGalvoYMinimum(galvoLabel: DeviceLabel | str) -&gt; float</code>","text":"<p>Get the Galvo y minimum</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getGalvoYRange","title":"<code>getGalvoYRange(galvoLabel: DeviceLabel | str) -&gt; float</code>","text":"<p>Get the Galvo y range</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getImageBitDepth","title":"<code>getImageBitDepth() -&gt; int</code>","text":"<p>How many bits of dynamic range are to be expected from the camera.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getImageBufferSize","title":"<code>getImageBufferSize() -&gt; int</code>","text":"<p>Returns the size of the internal image buffer.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getImageHeight","title":"<code>getImageHeight() -&gt; int</code>","text":"<p>Vertical dimension of the image buffer in pixels.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getImageProcessorDevice","title":"<code>getImageProcessorDevice() -&gt; DeviceLabel | Literal['']</code>","text":"<p>Returns the label of the currently selected image processor device.</p> <p>Returns empty string if no image processor device is selected.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getImageWidth","title":"<code>getImageWidth() -&gt; int</code>","text":"<p>Horizontal dimension of the image buffer in pixels.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getInstalledDeviceDescription","title":"<code>getInstalledDeviceDescription(hubLabel: DeviceLabel | str, peripheralLabel: DeviceName | str) -&gt; str</code>","text":"<p>Returns description from the specified peripheral on <code>hubLabel</code> device.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getInstalledDevices","title":"<code>getInstalledDevices(hubLabel: DeviceLabel | str) -&gt; Tuple[DeviceName, ...]</code>","text":"<p>Performs auto-detection and loading of child devices that are attached to a Hub device.</p> <p>Raises RuntimeError if hubLabel is not a hub device.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getLastFocusScore","title":"<code>getLastFocusScore() -&gt; float</code>","text":"<p>Returns the latest focus score from the focusing device.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getLastImage","title":"<code>getLastImage() -&gt; np.ndarray</code>","text":"<p>Gets the last image from the circular buffer.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getLoadedDevices","title":"<code>getLoadedDevices() -&gt; Tuple[DeviceLabel, ...]</code>","text":"<p>Returns an array of labels for currently loaded devices.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getLoadedDevicesOfType","title":"<code>getLoadedDevicesOfType(devType: DeviceType) -&gt; Tuple[DeviceLabel, ...]</code>","text":"<p>Returns an array of labels for currently loaded devices of specific type.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getLoadedPeripheralDevices","title":"<code>getLoadedPeripheralDevices(hubLabel: DeviceLabel | str) -&gt; Tuple[DeviceLabel, ...]</code>","text":"<p>Return labels of all loaded peripherals of <code>hubLabel</code> device.</p> <p>Returns empty tuple if hubLabel is not a hub device, or even if hubLabel is not the name of any device.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getMagnificationFactor","title":"<code>getMagnificationFactor() -&gt; float</code>","text":"<p>Returns the product of all Magnifiers in the system or 1.0 when none is found. This is used internally by GetPixelSizeUm</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getNBeforeLastImageMD","title":"<code>getNBeforeLastImageMD(n: int, md: Metadata) -&gt; np.ndarray</code>","text":"<p>Returns a pointer to the pixels of the image that was inserted n images ago. Also provides all metadata associated with that image</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getNumberOfCameraChannels","title":"<code>getNumberOfCameraChannels() -&gt; int</code>","text":"<p>Returns the number of simultaneous channels the default camera is returning.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getNumberOfComponents","title":"<code>getNumberOfComponents() -&gt; int</code>","text":"<p>Returns the number of components the default camera is returning.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getNumberOfStates","title":"<code>getNumberOfStates(stateDeviceLabel: DeviceLabel | str) -&gt; int</code>","text":"<p>Returns the total number of available positions (states).</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getParentLabel","title":"<code>getParentLabel(peripheralLabel: DeviceLabel | str) -&gt; DeviceLabel | Literal['']</code>","text":"<p>Returns parent device. Returns empty string if no parent is found.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getPixelSizeAffineByID","title":"<code>getPixelSizeAffineByID(resolutionID: PixelSizeConfigName | str) -&gt; AffineTuple</code>","text":"<p>Returns the Affine Transform to related camera pixels with stage movement for the requested pixel size group. The raw affine transform without correction for binning and magnification will be returned.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getPixelSizeUmByID","title":"<code>getPixelSizeUmByID(resolutionID: PixelSizeConfigName | str) -&gt; float</code>","text":"<p>Returns the pixel size in um for the requested pixel size group</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getPrimaryLogFile","title":"<code>getPrimaryLogFile() -&gt; str</code>","text":"<p>Return the name of the primary Core log file.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getProperty","title":"<code>getProperty(label: DeviceLabel | str, propName: PropertyName | str) -&gt; str</code>","text":"<p>Returns the property value for the specified device.</p> <p>The return value will always be a string.  Use getPropertyType to determine the correct type.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getPropertyFromCache","title":"<code>getPropertyFromCache(deviceLabel: DeviceLabel | str, propName: PropertyName | str) -&gt; str</code>","text":"<p>Returns the cached property value for the specified device.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getPropertyLowerLimit","title":"<code>getPropertyLowerLimit(label: DeviceLabel | str, propName: PropertyName | str) -&gt; float</code>","text":"<p>Returns the property lower limit value, if the property has limits - 0 otherwise.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getPropertySequenceMaxLength","title":"<code>getPropertySequenceMaxLength(label: DeviceLabel | str, propName: PropertyName | str) -&gt; int</code>","text":"<p>Queries device property for the maximum number of events that can be put in a sequence</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getPropertyUpperLimit","title":"<code>getPropertyUpperLimit(label: DeviceLabel | str, propName: PropertyName | str) -&gt; float</code>","text":"<p>Returns the property upper limit value, if the property has limits - 0 otherwise.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getPumpFlowrate","title":"<code>getPumpFlowrate(pumpLabel: str) -&gt; float</code>","text":"<p>Return the flowrate of the pump in uL per second</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getPumpMaxVolume","title":"<code>getPumpMaxVolume(pumpLabel: str) -&gt; float</code>","text":"<p>Return max volume of the pump in uL</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getPumpPressureKPa","title":"<code>getPumpPressureKPa(pumpLabel: str) -&gt; float</code>","text":"<p>Return the pressure of the pump in kPa.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getPumpVolume","title":"<code>getPumpVolume(pumpLabel: str) -&gt; float</code>","text":"<p>Return the fluid volume in the pump in uL</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getRemainingImageCount","title":"<code>getRemainingImageCount() -&gt; int</code>","text":"<p>Returns number ofimages available in the Circular Buffer</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getSLMBytesPerPixel","title":"<code>getSLMBytesPerPixel(slmLabel: DeviceLabel | str) -&gt; int</code>","text":"<p>Returns the number of bytes per SLM pixel</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getSLMDevice","title":"<code>getSLMDevice() -&gt; DeviceLabel | Literal['']</code>","text":"<p>Returns the label of the currently selected SLM device.</p> <p>Returns empty string if no SLM device is selected.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getSLMExposure","title":"<code>getSLMExposure(slmLabel: DeviceLabel | str) -&gt; float</code>","text":"<p>Returns the exposure time that will be used by the SLM for illumination</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getSLMHeight","title":"<code>getSLMHeight(slmLabel: DeviceLabel | str) -&gt; int</code>","text":"<p>Returns the height (in \"pixels\") of the SLM</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getSLMNumberOfComponents","title":"<code>getSLMNumberOfComponents(slmLabel: DeviceLabel | str) -&gt; int</code>","text":"<p>Returns the number of components (usually these depict colors) of the SLM.</p> <p>For instance, an RGB projector will return 3, but a grey scale SLM returns 1</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getSLMSequenceMaxLength","title":"<code>getSLMSequenceMaxLength(slmLabel: DeviceLabel | str) -&gt; int</code>","text":"<p>For SLMs that support sequences, returns the maximum length of the sequence that can be uploaded to the device</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getSLMWidth","title":"<code>getSLMWidth(slmLabel: DeviceLabel | str) -&gt; int</code>","text":"<p>Returns the width (in \"pixels\") of the SLM</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getSerialPortAnswer","title":"<code>getSerialPortAnswer(portLabel: str, term: str) -&gt; str</code>","text":"<p>Continuously read from the serial port until the terminating sequence is encountered.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getShutterDevice","title":"<code>getShutterDevice() -&gt; DeviceLabel | Literal['']</code>","text":"<p>Returns the label of the currently selected shutter device.</p> <p>Returns empty string if no shutter device is selected.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getStageSequenceMaxLength","title":"<code>getStageSequenceMaxLength(stageLabel: DeviceLabel | str) -&gt; int</code>","text":"<p>Gets the maximum length of a stage's position sequence.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getState","title":"<code>getState(stateDeviceLabel: DeviceLabel | str) -&gt; int</code>","text":"<p>Returns the current state (position) on the specific device.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getStateFromLabel","title":"<code>getStateFromLabel(stateDeviceLabel: DeviceLabel | str, stateLabel: StateLabel | str) -&gt; int</code>","text":"<p>Obtain the state for a given label.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getStateLabel","title":"<code>getStateLabel(stateDeviceLabel: DeviceLabel | str) -&gt; StateLabel</code>","text":"<p>Returns the current state as the label (string).</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getStateLabels","title":"<code>getStateLabels(stateDeviceLabel: DeviceLabel | str) -&gt; Tuple[StateLabel, ...]</code>","text":"<p>Return labels for all states</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getTimeoutMs","title":"<code>getTimeoutMs() -&gt; int</code>","text":"<p>Get the timeout for all wait commands.</p> <p>(Default is 5000 ms)</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getVersionInfo","title":"<code>getVersionInfo() -&gt; str</code>","text":"<p>Displays core version.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getXYStageDevice","title":"<code>getXYStageDevice() -&gt; DeviceLabel | Literal['']</code>","text":"<p>Returns the label of the currently selected XYStage device.</p> <p>Returns empty string if no XYStage device is selected.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getXYStageSequenceMaxLength","title":"<code>getXYStageSequenceMaxLength(xyStageLabel: DeviceLabel | str) -&gt; int</code>","text":"<p>Gets the maximum length of an XY stage's position sequence.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.hasProperty","title":"<code>hasProperty(label: DeviceLabel | str, propName: PropertyName | str) -&gt; bool</code>","text":"<p>Checks if device has a property with a specified name.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.hasPropertyLimits","title":"<code>hasPropertyLimits(label: DeviceLabel | str, propName: PropertyName | str) -&gt; bool</code>","text":"<p>Queries device if the specific property has limits.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.home","title":"<code>home(xyOrZStageLabel: DeviceLabel | str) -&gt; None</code>","text":"<p>Perform a hardware homing operation for an XY or focus/Z stage.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.incrementalFocus","title":"<code>incrementalFocus() -&gt; None</code>","text":"<p>Performs incremental focus for the one-shot focusing device.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.initializeAllDevices","title":"<code>initializeAllDevices() -&gt; None</code>","text":"<p>Calls Initialize() method for each loaded device.</p> <p>See <code>ParallelDeviceInitialization</code> feature flag for controlling the order of initialization.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.initializeCircularBuffer","title":"<code>initializeCircularBuffer() -&gt; None</code>","text":"<p>Initialize circular buffer based on the current camera settings.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.initializeDevice","title":"<code>initializeDevice(label: DeviceLabel | str) -&gt; None</code>","text":"<p>Initializes specific device.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.invertPumpDirection","title":"<code>invertPumpDirection(pumpLabel: str, invert: bool) -&gt; None</code>","text":"<p>Sets whether the pump direction needs to be inverted</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.isBufferOverflowed","title":"<code>isBufferOverflowed() -&gt; bool</code>","text":"<p>Indicates whether the circular buffer is overflowed</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.isConfigDefined","title":"<code>isConfigDefined(groupName: str, configName: str) -&gt; bool</code>","text":"<p>Checks if the configuration already exists within a group.</p> <p>If either the groupName or configName are not recognized, returns False.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.isContinuousFocusDrive","title":"<code>isContinuousFocusDrive(stageLabel: DeviceLabel | str) -&gt; bool</code>","text":"<p>Check if a stage has continuous focusing capability.</p> <p>(positions can be set while continuous focus runs).</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.isContinuousFocusEnabled","title":"<code>isContinuousFocusEnabled() -&gt; bool</code>","text":"<p>Checks if the continuous focusing hardware device is ON or OFF.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.isContinuousFocusLocked","title":"<code>isContinuousFocusLocked() -&gt; bool</code>","text":"<p>Returns the lock-in status of the continuous focusing device.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.isExposureSequenceable","title":"<code>isExposureSequenceable(cameraLabel: DeviceLabel | str) -&gt; bool</code>","text":"<p>Queries camera if exposure can be used in a sequence</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.isFeatureEnabled","title":"<code>isFeatureEnabled(name: str) -&gt; bool</code>","text":"<p>Return whether the given Core feature is currently enabled.</p> <p>See <code>enableFeature()</code> for the available features.</p> <p>Raises RuntimeError if the feature name is not recognized.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.isGroupDefined","title":"<code>isGroupDefined(groupName: str) -&gt; bool</code>","text":"<p>Checks if the group already exists.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.isMultiROIEnabled","title":"<code>isMultiROIEnabled() -&gt; bool</code>","text":"<p>Queries the camera to determine if multiple ROIs are currently set.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.isMultiROISupported","title":"<code>isMultiROISupported() -&gt; bool</code>","text":"<p>Queries the camera to determine if it supports multiple ROIs.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.isPixelSizeConfigDefined","title":"<code>isPixelSizeConfigDefined(resolutionID: str) -&gt; bool</code>","text":"<p>Checks if the Pixel Size Resolution already exists</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.isPropertyPreInit","title":"<code>isPropertyPreInit(label: DeviceLabel | str, propName: PropertyName | str) -&gt; bool</code>","text":"<p>Tells us whether the property must be defined prior to initialization.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.isPropertyReadOnly","title":"<code>isPropertyReadOnly(label: DeviceLabel | str, propName: PropertyName | str) -&gt; bool</code>","text":"<p>Tells us whether the property can be modified.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.isPropertySequenceable","title":"<code>isPropertySequenceable(label: DeviceLabel | str, propName: PropertyName | str) -&gt; bool</code>","text":"<p>Queries device if the specified property can be used in a sequence</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.isPumpDirectionInverted","title":"<code>isPumpDirectionInverted(pumpLabel: str) -&gt; bool</code>","text":"<p>Return True if pump direction needs to be inverted</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.isStageLinearSequenceable","title":"<code>isStageLinearSequenceable(stageLabel: DeviceLabel | str) -&gt; bool</code>","text":"<p>Queries if the stage can be used in a linear sequence.</p> <p>A linear sequence is defined by a stepsize and number of slices</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.isStageSequenceable","title":"<code>isStageSequenceable(stageLabel: DeviceLabel | str) -&gt; bool</code>","text":"<p>Queries stage if it can be used in a sequence</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.isStageUsingCallbacks","title":"<code>isStageUsingCallbacks(stageLabel: DeviceLabel | str) -&gt; bool</code>","text":"<p>Queries whether the stage uses callbacks to signal position changes.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.isXYStageSequenceable","title":"<code>isXYStageSequenceable(xyStageLabel: DeviceLabel | str) -&gt; bool</code>","text":"<p>Queries XY stage if it can be used in a sequence</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.isXYStageUsingCallbacks","title":"<code>isXYStageUsingCallbacks(xyStageLabel: DeviceLabel | str) -&gt; bool</code>","text":"<p>Queries whether the XY stage uses callbacks to signal position changes.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.loadExposureSequence","title":"<code>loadExposureSequence(cameraLabel: DeviceLabel | str, exposureSequence_ms: Sequence[float]) -&gt; None</code>","text":"<p>Transfer a sequence of exposure times to the camera.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.loadGalvoPolygons","title":"<code>loadGalvoPolygons(galvoLabel: DeviceLabel | str) -&gt; None</code>","text":"<p>Load a set of galvo polygons to the device</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.loadPropertySequence","title":"<code>loadPropertySequence(label: DeviceLabel | str, propName: PropertyName | str, eventSequence: Sequence[str]) -&gt; None</code>","text":"<p>Transfer a sequence of events/states/whatever to the device.</p> <p>This should only be called for device-properties that are sequenceable</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.loadSLMSequence","title":"<code>loadSLMSequence(slmLabel: DeviceLabel | str, imageSequence: List[bytes]) -&gt; None</code>","text":"<p>Load a sequence of images into the SLM</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.loadStageSequence","title":"<code>loadStageSequence(stageLabel: DeviceLabel | str, positionSequence: Sequence[float]) -&gt; None</code>","text":"<p>Transfer a sequence of events/states/whatever to the device.</p> <p>This should only be called for device-properties that are sequenceable</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.loadSystemState","title":"<code>loadSystemState(fileName: str) -&gt; None</code>","text":"<p>Loads the system configuration from the text file conforming to the MM specific format.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.loadXYStageSequence","title":"<code>loadXYStageSequence(xyStageLabel: DeviceLabel | str, xSequence: Sequence[float], ySequence: Sequence[float]) -&gt; None</code>","text":"<p>Transfer a sequence of stage positions to the xy stage.</p> <p>xSequence and ySequence must have the same length. This should only be called for XY stages that are sequenceable</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.noop","title":"<code>noop() -&gt; None</code>","text":"<p>A static method that does nothing.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.pointGalvoAndFire","title":"<code>pointGalvoAndFire(galvoLabel: DeviceLabel | str, x: float, y: float, pulseTime_us: float) -&gt; None</code>","text":"<p>Set the Galvo to an x,y position and fire the laser for a predetermined duration.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.prepareSequenceAcquisition","title":"<code>prepareSequenceAcquisition(cameraLabel: DeviceLabel | str) -&gt; None</code>","text":"<p>Prepare the camera for the sequence acquisition to save the time in the</p> <p>StartSequenceAcqusition() call which is supposed to come next.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.pressurePumpCalibrate","title":"<code>pressurePumpCalibrate(pumpLabel: str) -&gt; None</code>","text":"<p>Calibrates the pressure pump.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.pressurePumpRequiresCalibration","title":"<code>pressurePumpRequiresCalibration(pumpLabel: str) -&gt; bool</code>","text":"<p>Return True if pump requires calibration before operation.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.pressurePumpStop","title":"<code>pressurePumpStop(pumpLabel: str) -&gt; None</code>","text":"<p>Stops the pressure pump.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.pumpDispenseDurationSeconds","title":"<code>pumpDispenseDurationSeconds(pumpLabel: str, seconds: float) -&gt; None</code>","text":"<p>Dispenses for the provided duration (in seconds) at the set flowrate.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.pumpDispenseVolumeUl","title":"<code>pumpDispenseVolumeUl(pumpLabel: str, microLiter: float) -&gt; None</code>","text":"<p>Dispenses the provided volume (in uL) at the set flowrate.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.pumpStart","title":"<code>pumpStart(pumpLabel: str) -&gt; None</code>","text":"<p>Start dispensing until syringe is empty, or manually stopped.</p> <p>(whichever occurs first).</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.readFromSerialPort","title":"<code>readFromSerialPort(portLabel: str) -&gt; List[str]</code>","text":"<p>Reads the contents of the Rx buffer.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.renameConfig","title":"<code>renameConfig(groupName: ConfigGroupName | str, oldConfigName: ConfigPresetName | str, newConfigName: str) -&gt; None</code>","text":"<p>Renames a configuration within a specified group.</p> <p>The command will fail if the configuration was not previously defined.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.renameConfigGroup","title":"<code>renameConfigGroup(oldGroupName: ConfigGroupName | str, newGroupName: str) -&gt; None</code>","text":"<p>Renames a configuration group.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.renamePixelSizeConfig","title":"<code>renamePixelSizeConfig(oldConfigName: PixelSizeConfigName | str, newConfigName: str) -&gt; None</code>","text":"<p>Renames a pixel size configuration.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.reset","title":"<code>reset() -&gt; None</code>","text":"<p>Unloads all devices from the core, clears all configuration data and property blocks.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.runGalvoPolygons","title":"<code>runGalvoPolygons(galvoLabel: DeviceLabel | str) -&gt; None</code>","text":"<p>Run a loop of galvo polygons</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.runGalvoSequence","title":"<code>runGalvoSequence(galvoLabel: DeviceLabel | str) -&gt; None</code>","text":"<p>Run a sequence of galvo positions</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.saveSystemState","title":"<code>saveSystemState(fileName: str) -&gt; None</code>","text":"<p>Saves the current system state to a text file of the MM specific format.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.setAutoFocusDevice","title":"<code>setAutoFocusDevice(focusLabel: DeviceLabel | str) -&gt; None</code>","text":"<p>Sets the current auto-focus device.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.setCameraDevice","title":"<code>setCameraDevice(cameraLabel: DeviceLabel | str) -&gt; None</code>","text":"<p>Sets the current camera device.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.setCircularBufferMemoryFootprint","title":"<code>setCircularBufferMemoryFootprint(sizeMB: int) -&gt; None</code>","text":"<p>Reserve memory for the circular buffer.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.setDeviceAdapterSearchPaths","title":"<code>setDeviceAdapterSearchPaths(paths: Sequence[str]) -&gt; None</code>","text":"<p>Set the device adapter search paths.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.setDeviceDelayMs","title":"<code>setDeviceDelayMs(label: DeviceLabel | str, delayMs: float) -&gt; None</code>","text":"<p>Overrides the built-in value for the action delay.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.setFocusDirection","title":"<code>setFocusDirection(stageLabel: DeviceLabel | str, sign: int) -&gt; None</code>","text":"<p>Set the focus direction of a stage.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.setGalvoDevice","title":"<code>setGalvoDevice(galvoLabel: DeviceLabel | str) -&gt; None</code>","text":"<p>Sets the current galvo device.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.setGalvoIlluminationState","title":"<code>setGalvoIlluminationState(galvoLabel: DeviceLabel | str, on: bool) -&gt; None</code>","text":"<p>Set the galvo's illumination state to on or off</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.setGalvoPolygonRepetitions","title":"<code>setGalvoPolygonRepetitions(galvoLabel: DeviceLabel | str, repetitions: int) -&gt; None</code>","text":"<p>Set the number of times to loop galvo polygons</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.setGalvoPosition","title":"<code>setGalvoPosition(galvoLabel: DeviceLabel | str, x: float, y: float) -&gt; None</code>","text":"<p>Set the Galvo to an x,y position.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.setGalvoSpotInterval","title":"<code>setGalvoSpotInterval(galvoLabel: DeviceLabel | str, pulseTime_us: float) -&gt; None</code>","text":"<p>Set the SpotInterval for the specified galvo device.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.setImageProcessorDevice","title":"<code>setImageProcessorDevice(procLabel: DeviceLabel | str) -&gt; None</code>","text":"<p>Sets the current image processor device.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.setMultiROI","title":"<code>setMultiROI(xs: Sequence[int], ys: Sequence[int], widths: Sequence[int], heights: Sequence[int]) -&gt; None</code>","text":"<p>Set multiple ROIs for the current camera device.</p> <p>Will fail if the camera does not support multiple ROIs, any widths or heights are non-positive, or if the vectors do not all have the same length.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.setParentLabel","title":"<code>setParentLabel(deviceLabel: DeviceLabel | str, parentHubLabel: DeviceLabel | str) -&gt; None</code>","text":"<p>Sets parent device label</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.setPixelSizeAffine","title":"<code>setPixelSizeAffine(resolutionID: PixelSizeConfigName | str, affine: Sequence[float]) -&gt; None</code>","text":"<p>Sets the raw affine transform for the specific pixel size configuration.</p> <p>The affine transform consists of the first two rows of a 3x3 matrix, the third row is always assumed to be 0.0 0.0 1.0.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.setPixelSizeConfig","title":"<code>setPixelSizeConfig(resolutionID: PixelSizeConfigName | str) -&gt; None</code>","text":"<p>Applies a Pixel Size Configuration.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.setPixelSizeOptimalZUm","title":"<code>setPixelSizeOptimalZUm(resolutionID: PixelSizeConfigName | str, optimalZ: float) -&gt; None</code>","text":"<p>Sets the pixel size in the Z direction in microns.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.setPixelSizedxdz","title":"<code>setPixelSizedxdz(resolutionID: PixelSizeConfigName | str, dXdZ: float) -&gt; None</code>","text":"<p>Sets the pixel size in the X direction in microns.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.setPixelSizedydz","title":"<code>setPixelSizedydz(resolutionID: PixelSizeConfigName | str, dYdZ: float) -&gt; None</code>","text":"<p>Sets the pixel size in the Y direction in microns.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.setPumpFlowrate","title":"<code>setPumpFlowrate(pumpLabel: str, volume: float) -&gt; None</code>","text":"<p>Set the flowrate of the pump in uL per second</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.setPumpMaxVolume","title":"<code>setPumpMaxVolume(pumpLabel: str, volume: float) -&gt; None</code>","text":"<p>Set the max volume of the pump in uL</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.setPumpPressureKPa","title":"<code>setPumpPressureKPa(pumpLabel: str, pressure: float) -&gt; None</code>","text":"<p>Sets the pressure of the pump in kPa.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.setPumpVolume","title":"<code>setPumpVolume(pumpLabel: str, volume: float) -&gt; None</code>","text":"<p>Sets the volume of fluid in the pump in uL.</p> <p>Note it does not withdraw upto this amount. It is merely to inform MM of the volume in a prefilled pump.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.setSLMDevice","title":"<code>setSLMDevice(slmLabel: DeviceLabel | str) -&gt; None</code>","text":"<p>Sets the current slm device.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.setSLMExposure","title":"<code>setSLMExposure(slmLabel: DeviceLabel | str, exposure_ms: float) -&gt; None</code>","text":"<p>For SLM devices with build-in light source (such as projectors), this will set the exposure time, but not (yet) start the illumination</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.setSerialPortCommand","title":"<code>setSerialPortCommand(portLabel: str, command: str, term: str) -&gt; None</code>","text":"<p>Send string to the serial device and return an answer.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.setSerialProperties","title":"<code>setSerialProperties(portName: str, answerTimeout: str, baudRate: str, delayBetweenCharsMs: str, handshaking: str, parity: str, stopBits: str) -&gt; None</code>","text":"<p>Sets all com port properties in a single call.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.setShutterDevice","title":"<code>setShutterDevice(shutterLabel: DeviceLabel | str) -&gt; None</code>","text":"<p>the current shutter device.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.setStageLinearSequence","title":"<code>setStageLinearSequence(stageLabel: DeviceLabel | str, dZ_um: float, nSlices: int) -&gt; None</code>","text":"<p>Loads a linear sequence (defined by stepsize and nr. of steps) into the device.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.setSystemState","title":"<code>setSystemState(conf: Configuration) -&gt; None</code>","text":"<p>Sets all properties contained in the Configuration object.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.setTimeoutMs","title":"<code>setTimeoutMs(timeoutMs: int) -&gt; None</code>","text":"<p>Sets the timeout for all wait commands.</p> <p>(Default is 5000 ms)</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.setXYStageDevice","title":"<code>setXYStageDevice(xyStageLabel: DeviceLabel | str) -&gt; None</code>","text":"<p>Sets the current XY device.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.sleep","title":"<code>sleep(intervalMs: float) -&gt; None</code>","text":"<p>Waits (blocks the calling thread) for specified time in milliseconds.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.startExposureSequence","title":"<code>startExposureSequence(cameraLabel: DeviceLabel | str) -&gt; None</code>","text":"<p>Starts an ongoing sequence of triggered exposures in a camera.</p> <p>This should only be called for cameras where exposure time is sequenceable</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.startPropertySequence","title":"<code>startPropertySequence(label: DeviceLabel | str, propName: PropertyName | str) -&gt; None</code>","text":"<p>Starts an ongoing sequence of triggered events in a property of a device.</p> <p>This should only be called for device-properties that are sequenceable</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.startSLMSequence","title":"<code>startSLMSequence(slmLabel: DeviceLabel | str) -&gt; None</code>","text":"<p>Starts the sequence previously uploaded to the SLM</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.startStageSequence","title":"<code>startStageSequence(stageLabel: DeviceLabel | str) -&gt; None</code>","text":"<p>Starts an ongoing sequence of triggered events in a stage.</p> <p>This should only be called for stages</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.startXYStageSequence","title":"<code>startXYStageSequence(xyStageLabel: DeviceLabel | str) -&gt; None</code>","text":"<p>Starts an ongoing sequence of triggered events in an XY stage.</p> <p>This should only be called for stages</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.stderrLogEnabled","title":"<code>stderrLogEnabled() -&gt; bool</code>","text":"<p>Indicates whether logging output goes to stdErr</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.stop","title":"<code>stop(xyOrZStageLabel: DeviceLabel | str) -&gt; None</code>","text":"<p>Stop the XY or focus/Z stage motors</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.stopExposureSequence","title":"<code>stopExposureSequence(cameraLabel: DeviceLabel | str) -&gt; None</code>","text":"<p>Stops an ongoing sequence of triggered exposures in a camera.</p> <p>This should only be called for cameras where exposure time is sequenceable</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.stopPropertySequence","title":"<code>stopPropertySequence(label: DeviceLabel | str, propName: PropertyName | str) -&gt; None</code>","text":"<p>Stops an ongoing sequence of triggered events in a property of a device.</p> <p>This should only be called for device-properties that are sequenceable</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.stopSLMSequence","title":"<code>stopSLMSequence(slmLabel: DeviceLabel | str) -&gt; None</code>","text":"<p>Stops the SLM sequence if previously started</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.stopSecondaryLogFile","title":"<code>stopSecondaryLogFile(handle: int) -&gt; None</code>","text":"<p>Stop capturing logging output into an additional file.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.stopStageSequence","title":"<code>stopStageSequence(stageLabel: DeviceLabel | str) -&gt; None</code>","text":"<p>Stops an ongoing sequence of triggered events in a stage.</p> <p>This should only be called for stages that are sequenceable</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.stopXYStageSequence","title":"<code>stopXYStageSequence(xyStageLabel: DeviceLabel | str) -&gt; None</code>","text":"<p>Stops an ongoing sequence of triggered events in an XY stage.</p> <p>This should only be called for stages that are sequenceable</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.supportsDeviceDetection","title":"<code>supportsDeviceDetection(deviceLabel: DeviceLabel | str) -&gt; bool</code>","text":"<p>Return whether or not the device supports automatic device detection (i.e.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.systemBusy","title":"<code>systemBusy() -&gt; bool</code>","text":"<p>Checks the busy status of the entire system.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.unloadDevice","title":"<code>unloadDevice(label: DeviceLabel | str) -&gt; None</code>","text":"<p>Unloads the device from the core and adjusts all configuration data.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.unloadLibrary","title":"<code>unloadLibrary(moduleName: AdapterName | str) -&gt; None</code>","text":"<p>Forcefully unload a library.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.updateCoreProperties","title":"<code>updateCoreProperties() -&gt; None</code>","text":"<p>Updates CoreProperties (currently all Core properties are devices types) with the loaded hardware.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.updateSystemStateCache","title":"<code>updateSystemStateCache() -&gt; None</code>","text":"<p>Updates the state of the entire hardware.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.usesDeviceDelay","title":"<code>usesDeviceDelay(label: DeviceLabel | str) -&gt; bool</code>","text":"<p>Signals if the device will use the delay setting or not.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.volumetricPumpHome","title":"<code>volumetricPumpHome(pumpLabel: str) -&gt; None</code>","text":"<p>Homes the volumetric pump.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.volumetricPumpRequiresHoming","title":"<code>volumetricPumpRequiresHoming(pumpLabel: str) -&gt; bool</code>","text":"<p>Return True if the volumetric pump requires homing.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.volumetricPumpStop","title":"<code>volumetricPumpStop(pumpLabel: str) -&gt; None</code>","text":"<p>Stops the volumetric pump.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.waitForConfig","title":"<code>waitForConfig(group: ConfigGroupName | str, configName: ConfigPresetName | str) -&gt; None</code>","text":"<p>Blocks until all devices included in the configuration become ready.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.waitForDevice","title":"<code>waitForDevice(label: DeviceLabel | str) -&gt; None</code>","text":"<p>Waits (blocks the calling thread) until the specified device becomes non-busy.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.waitForDeviceType","title":"<code>waitForDeviceType(devType: DeviceType) -&gt; None</code>","text":"<p>Blocks until all devices of the specific type become ready (not-busy).</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.waitForSystem","title":"<code>waitForSystem() -&gt; None</code>","text":"<p>Blocks until all devices in the system become ready (not-busy).</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.writeToSerialPort","title":"<code>writeToSerialPort(portLabel: str, data: bytes) -&gt; None</code>","text":"<p>Sends an array of characters to the serial port and returns immediately.</p>"},{"location":"api/cmmcoreplus/#typeddicts","title":"TypedDicts","text":""},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.DeviceSchema","title":"<code>pymmcore_plus.core._mmcore_plus.DeviceSchema</code>","text":"<p>JSON schema <code>dict</code> describing a device.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.DeviceSchema.description","title":"<code>description: str</code>  <code>class-attribute</code>","text":""},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.DeviceSchema.properties","title":"<code>properties: dict[str, PropertySchema]</code>  <code>class-attribute</code>","text":""},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.DeviceSchema.title","title":"<code>title: str</code>  <code>class-attribute</code>","text":""},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.DeviceSchema.type","title":"<code>type: str</code>  <code>class-attribute</code>","text":""},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.PropertySchema","title":"<code>pymmcore_plus.core._mmcore_plus.PropertySchema</code>","text":"<p>JSON schema <code>dict</code> describing a device property.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.PropertySchema.default","title":"<code>default: Any</code>  <code>class-attribute</code>","text":""},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.PropertySchema.enum","title":"<code>enum: list</code>  <code>class-attribute</code>","text":""},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.PropertySchema.maximum","title":"<code>maximum: float</code>  <code>class-attribute</code>","text":""},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.PropertySchema.minimum","title":"<code>minimum: float</code>  <code>class-attribute</code>","text":""},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.PropertySchema.preInit","title":"<code>preInit: bool</code>  <code>class-attribute</code>","text":""},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.PropertySchema.readOnly","title":"<code>readOnly: bool</code>  <code>class-attribute</code>","text":""},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.PropertySchema.sequenceMaxLength","title":"<code>sequenceMaxLength: int</code>  <code>class-attribute</code>","text":""},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.PropertySchema.sequenceable","title":"<code>sequenceable: bool</code>  <code>class-attribute</code>","text":""},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.PropertySchema.type","title":"<code>type: str</code>  <code>class-attribute</code>","text":""},{"location":"api/configuration/","title":"Configuration &amp; Groups","text":"<p>Configuring a microscope with micro-manager entails storing and retrieving a number of device parameters settings.  In general, a single setting comprises a device name, a property name, and a value.  A Configuration object represents a collection of individual settings; that is, it represents a number of device parameters all in a specific state, such as would be used to prepare the microscope to image a specific channel, like \"DAPI\", or \"FITC\".</p> <p>A Configuration Group is, in turn, a collection of <code>Configuration</code> objects; for example, all of the <code>Configuration</code> objects that represent different \"Channel\" settings.</p> <p>Conceptually, Configurations and Groups are organized like this:</p> <pre><code>ConfigGroupA:\n    Configuration1:\n        deviceA:\n            propertyA: 'value_a'\n            propertyB: 'value_b'\n        deviceB:\n            propertyC: 'value_c'\n        ...\n    Configuration2:\n        deviceA:\n            propertyA: 'value_d'\n            propertyB: 'value_e'\n        deviceB:\n            propertyC: 'value_f'\n        ...\n    ...\nConfigGroupB:\n    Configuration1:\n        deviceC:\n            propertyA: 'value_g'\n        ...\n    ...\n</code></pre>"},{"location":"api/configuration/#pymmcore-plus-objects","title":"<code>pymmcore-plus</code> Objects","text":"<p>MMCore and pymmcore's configuration object implements a basic mutable mapping interface, but with custom method names like <code>addSetting</code>, <code>getSetting</code>, and <code>deleteSetting</code> methods).</p> <p><code>pymmcore-plus</code> provides a <code>Configuration</code> subclass that implements a <code>MutableMapping</code> interface, allowing dict-like access to the configuration, where the keys are 2-tuples of <code>(deviceLabel, propertyLabel)</code> and the values are the property values. (Note, however, that iterating of a <code>Configuration</code> object behaves like iterating over a list of 3-tuples <code>(deviceLabel, propertyLabel, value)</code>, not a dict.)</p> <p><code>pymmcore-plus</code> also offers a <code>ConfigGroup</code> object, which is a <code>MutableMapping</code> where the keys are Configuration Preset names and the values are <code>Configuration</code> objects.</p>"},{"location":"api/configuration/#pymmcore_plus.Configuration","title":"<code>pymmcore_plus.Configuration</code>","text":"<p>Encapsulation of configuration information.</p> <p>This is the type of object returned by default (provided <code>native==False</code>) by: <code>getConfigData][pymmcore_plus.CMMCorePlus.getConfigData], [</code>getPixelSizeConfigData <code>getSystemState][pymmcore_plus.CMMCorePlus.getSystemState] [</code>getSystemStateCache <code>getConfigState][pymmcore_plus.CMMCorePlus.getConfigState] [</code>getConfigGroupState `getConfigGroupStateFromCache</p> <p>This class is a subclass of <code>pymmcore.Configuration</code> that implements an <code>collections.abc.MutableSequence</code> (i.e. it behaves like a Python list). It also behaves much like a <code>collections.abc.MutableMapping</code>, where the keys are 2-tuples of (deviceLabel, propertyLabel) and the values are the property values.</p> <p>Note that the \"order\" of this collection is not well-defined, so while you can index with an integer, you should not rely on the order of the items in the collection.  <code>__getitem__/__setitem__/__delitem__</code> all accept a 2-tuple of <code>(deviceLabel, propertyLabel)</code>.</p> <p>It adds a few convenience methods:</p> <p>Tip</p> <p>All of the methods in <code>pymmcore_plus.CMMCorePlus</code> that would have returned a <code>pymmcore.Configuration</code> in <code>pymmcore</code> (e.g. <code>getConfigData</code>, <code>getConfigState</code>, etc...). have been reimplemented to return a <code>pymmcore_plus.Configuration</code> object. This object has the same API as <code>pymmcore.Configuration</code>, but you can request a \"native\" (unenhanced) <code>pymmcore</code> object by passing <code>native=True</code> to the method.</p>"},{"location":"api/configuration/#pymmcore_plus.core._config.Configuration.append","title":"<code>append(setting: pymmcore.PropertySetting | DevPropValueTuple) -&gt; None</code>","text":"<p>Add a setting to the configuration.</p>"},{"location":"api/configuration/#pymmcore_plus.core._config.Configuration.create","title":"<code>create(*args: Any, **kwargs: Any) -&gt; Configuration</code>  <code>classmethod</code>","text":"<p>More flexible init to create a <code>Configuration</code>.</p> <p>Can create from: 1. A dict of dicts (outer key is device, inner key is prop) 2. A sequence of 3-tuple 3. kwargs: where the key is the device, and the value is a {prop: value} map</p>"},{"location":"api/configuration/#pymmcore_plus.core._config.Configuration.dict","title":"<code>dict() -&gt; dict[str, dict[str, str]]</code>","text":"<p>Return config as a nested dict {Device: {Property: Value}}.</p>"},{"location":"api/configuration/#pymmcore_plus.core._config.Configuration.extend","title":"<code>extend(other: pymmcore.Configuration | Iterable[pymmcore.PropertySetting | DevPropValueTuple]) -&gt; None</code>","text":"<p>Add all settings from another Configuration.</p>"},{"location":"api/configuration/#pymmcore_plus.core._config.Configuration.from_configuration","title":"<code>from_configuration(config: pymmcore.Configuration) -&gt; Configuration</code>  <code>classmethod</code>","text":"<p>Create Configuration (Plus) from pymmcore.Configuration.</p>"},{"location":"api/configuration/#pymmcore_plus.core._config.Configuration.html","title":"<code>html() -&gt; str</code>","text":"<p>Return config representation as HTML.</p>"},{"location":"api/configuration/#pymmcore_plus.core._config.Configuration.remove","title":"<code>remove(key: DevPropTuple) -&gt; None</code>","text":"<p>Remove setting for <code>(devLabel, propLabel)</code> from the configuration.</p>"},{"location":"api/configuration/#pymmcore_plus.ConfigGroup","title":"<code>pymmcore_plus.ConfigGroup</code>","text":"<p>Convenience object for dealing with a set of related Configuration objects.</p> <p>This object behaves as a <code>collections.abc.MutableMapping</code> of <code>str</code> (configuration group name) to <code>Configuration</code> objects.</p> <p>It is object type returned by <code>pymmcore_plus.CMMCorePlus.getConfigGroupObject</code>.</p> <p>Parameters:</p> Name Type Description Default <code>group_name</code> <code>str</code> <p>The name of the configuration group to manage.  (It needn't exist yet)</p> required <code>mmcore</code> <code>CMMCorePlus</code> <p>The core object managing this config group.</p> required"},{"location":"api/configuration/#pymmcore_plus.core._config_group.ConfigGroup.core","title":"<code>core() -&gt; CMMCorePlus</code>  <code>property</code>","text":"<p>Return the <code>CMMCorePlus</code> instance to which this Device is bound.</p>"},{"location":"api/configuration/#pymmcore_plus.core._config_group.ConfigGroup.create","title":"<code>create() -&gt; None</code>","text":"<p>Create this configuration group in core (as an empty group).</p> <p>If the group already exists, this is a no-op.</p>"},{"location":"api/configuration/#pymmcore_plus.core._config_group.ConfigGroup.delete","title":"<code>delete() -&gt; None</code>","text":"<p>Delete this entire configuration group and all presets in it.</p>"},{"location":"api/configuration/#pymmcore_plus.core._config_group.ConfigGroup.exists","title":"<code>exists() -&gt; bool</code>","text":"<p>Return <code>True</code> if this ConfigGroup exists in the current configuration.</p>"},{"location":"api/configuration/#pymmcore_plus.core._config_group.ConfigGroup.getCurrentConfig","title":"<code>getCurrentConfig(as_object: bool = False) -&gt; str | Configuration</code>","text":"<p>Returns the current configuration for a given group.</p>"},{"location":"api/configuration/#pymmcore_plus.core._config_group.ConfigGroup.getCurrentConfigFromCache","title":"<code>getCurrentConfigFromCache(as_object: bool = False) -&gt; str | Configuration</code>","text":"<p>Returns the current configuration for a given group from the cache.</p>"},{"location":"api/configuration/#pymmcore_plus.core._config_group.ConfigGroup.is_consistent","title":"<code>is_consistent() -&gt; bool</code>  <code>property</code>","text":"<p>Return <code>True</code> if all presets in this group have the same properties.</p> <p>Note that a group with 0 or 1 presets is always considered consistent.  If two or more presets are present, they must all have the same device properties. (values of course may vary.)</p>"},{"location":"api/configuration/#pymmcore_plus.core._config_group.ConfigGroup.iterDeviceProperties","title":"<code>iterDeviceProperties() -&gt; Iterator[DeviceProperty]</code>","text":"<p>Iterate <code>DeviceProperty</code> for all properties in this ConfigGroup.</p> <p>Note, this only iterates over properties that are defined in the first preset of this ConfigGroup. This should be the same for all presets in this ConfigGroup, but it is not guaranteed.  Use <code>is_consistent</code> to check if all presets in this ConfigGroup have the same properties.</p>"},{"location":"api/configuration/#pymmcore_plus.core._config_group.ConfigGroup.name","title":"<code>name() -&gt; str</code>  <code>property</code>","text":"<p>Return the name of this ConfigGroup.</p>"},{"location":"api/configuration/#pymmcore_plus.core._config_group.ConfigGroup.rename","title":"<code>rename(newGroupName: str) -&gt; None</code>","text":"<p>Rename this configuration group.</p>"},{"location":"api/configuration/#pymmcore_plus.core._config_group.ConfigGroup.renameConfig","title":"<code>renameConfig(oldConfigName: str, newConfigName: str) -&gt; None</code>","text":"<p>Rename a configuration in this group.</p> <p>If the configuration does not exist, a KeyError is thrown.</p>"},{"location":"api/configuration/#pymmcore_plus.core._config_group.ConfigGroup.setConfig","title":"<code>setConfig(configName: str) -&gt; None</code>","text":"<p>Set the current configuration to <code>configName</code>.</p> <p>This actually updates the hardware state to match what is stored in the preset <code>configName</code>.</p>"},{"location":"api/configuration/#pymmcore_plus.core._config_group.ConfigGroup.wait","title":"<code>wait(configName: str | None = None) -&gt; None</code>","text":"<p>Blocks until all devices included in the configuration group ready.</p> <p>If <code>configName</code> not provided, then the first configuration in the group is used.</p>"},{"location":"api/constants/","title":"Constants","text":"<p>All of the constants in the <code>pymmcore</code> library are in the top level <code>pymmcore</code> namespace, making it a bit difficult to know what type or enumeration they refer to.</p> <p>All of these constants are reimplemened in the <code>pymmcore_plus</code> library as <code>enum.IntEnum</code> and are available in the <code>pymmcore_plus</code> namespace.</p> <p>For example, the integer corresponding to the <code>AfterLoadSequence</code> action type could be accessed as <code>pymmcore.AfterLoadSequence</code> or <code>pymmcore_plus.ActionType.AfterLoadSequence</code>.</p> <pre><code>In [1]: import pymmcore\n\nIn [2]: pymmcore.AfterLoadSequence\nOut[2]: 4\n\nIn [3]: from pymmcore_plus import ActionType\n\nIn [4]: ActionType.AfterLoadSequence\nOut[4]: &lt;ActionType.AfterLoadSequence: 4&gt;\n\nIn [5]: int(ActionType.AfterLoadSequence)\nOut[5]: 4\n</code></pre> <p>Additionally, it becomes easier to see what constants are available for each type or enumeration.</p> <pre><code>In [6]: list(ActionType)\nOut[6]:\n[\n    &lt;ActionType.NoAction: 0&gt;,\n    &lt;ActionType.BeforeGet: 1&gt;,\n    &lt;ActionType.AfterSet: 2&gt;,\n    &lt;ActionType.IsSequenceable: 3&gt;,\n    &lt;ActionType.AfterLoadSequence: 4&gt;,\n    &lt;ActionType.StartSequence: 5&gt;,\n    &lt;ActionType.StopSequence: 6&gt;\n]\n</code></pre> <p>Lastly, many of the methods that return integers in <code>pymmcore.CMMCore</code> have been re-implemented in <code>pymmcore_plus.CMMCorePlus</code> to return the appropriate enumeration.</p> <pre><code>import pymmcore\n\ncore = pymmcore.CMMCore()\n# ...  load config and devices\ncore.getDeviceType(\"Camera\")  # 2\n\n\nimport pymmcore_plus\n\ncore = pymmcore_plus.CMMCorePlus()\n# ...  load config and devices\ncore.getDeviceType(\"Camera\")  # &lt;DeviceType.CameraDevice: 2&gt;\n</code></pre>"},{"location":"api/constants/#pymmcore_plus.core._constants.PIXEL_FORMATS","title":"<code>PIXEL_FORMATS: dict[int, dict[int, PixelFormat]] = {1: {8: PixelFormat.MONO8, 10: PixelFormat.MONO10, 12: PixelFormat.MONO12, 14: PixelFormat.MONO14, 16: PixelFormat.MONO16, 32: PixelFormat.MONO32}, 3: {8: PixelFormat.RGB8, 10: PixelFormat.RGB10, 12: PixelFormat.RGB12, 14: PixelFormat.RGB14, 16: PixelFormat.RGB16}}</code>  <code>module-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.ActionType","title":"<code>ActionType</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.ActionType.AfterLoadSequence","title":"<code>AfterLoadSequence = pymmcore.AfterLoadSequence</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.ActionType.AfterSet","title":"<code>AfterSet = pymmcore.AfterSet</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.ActionType.BeforeGet","title":"<code>BeforeGet = pymmcore.BeforeGet</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.ActionType.IsSequenceable","title":"<code>IsSequenceable = pymmcore.IsSequenceable</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.ActionType.NoAction","title":"<code>NoAction = pymmcore.NoAction</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.ActionType.StartSequence","title":"<code>StartSequence = pymmcore.StartSequence</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.ActionType.StopSequence","title":"<code>StopSequence = pymmcore.StopSequence</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.CFGCommand","title":"<code>CFGCommand</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.CFGCommand.ConfigGroup","title":"<code>ConfigGroup = pymmcore.g_CFGCommand_ConfigGroup</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.CFGCommand.ConfigPixelSize","title":"<code>ConfigPixelSize = pymmcore.g_CFGCommand_ConfigPixelSize</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.CFGCommand.Configuration","title":"<code>Configuration = pymmcore.g_CFGCommand_Configuration</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.CFGCommand.Delay","title":"<code>Delay = pymmcore.g_CFGCommand_Delay</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.CFGCommand.Device","title":"<code>Device = pymmcore.g_CFGCommand_Device</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.CFGCommand.Equipment","title":"<code>Equipment = pymmcore.g_CFGCommand_Equipment</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.CFGCommand.FieldDelimiters","title":"<code>FieldDelimiters = pymmcore.g_FieldDelimiters</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.CFGCommand.FocusDirection","title":"<code>FocusDirection = pymmcore.g_CFGCommand_FocusDirection</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.CFGCommand.ImageSynchro","title":"<code>ImageSynchro = pymmcore.g_CFGCommand_ImageSynchro</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.CFGCommand.Label","title":"<code>Label = pymmcore.g_CFGCommand_Label</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.CFGCommand.ParentID","title":"<code>ParentID = pymmcore.g_CFGCommand_ParentID</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.CFGCommand.PixelSizeAffine","title":"<code>PixelSizeAffine = pymmcore.g_CFGCommand_PixelSizeAffine</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.CFGCommand.PixelSize_OptimalZUm","title":"<code>PixelSize_OptimalZUm = pymmcore.g_CFGCommand_PixelSizeOptimalZUm</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.CFGCommand.PixelSize_dxdz","title":"<code>PixelSize_dxdz = pymmcore.g_CFGCommand_PixelSizedxdz</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.CFGCommand.PixelSize_dydz","title":"<code>PixelSize_dydz = pymmcore.g_CFGCommand_PixelSizedydz</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.CFGCommand.PixelSize_um","title":"<code>PixelSize_um = pymmcore.g_CFGCommand_PixelSize_um</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.CFGCommand.Property","title":"<code>Property = pymmcore.g_CFGCommand_Property</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.CFGGroup","title":"<code>CFGGroup</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.CFGGroup.PixelSizeUm","title":"<code>PixelSizeUm = pymmcore.g_CFGGroup_PixelSizeUm</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.CFGGroup.System","title":"<code>System = pymmcore.g_CFGGroup_System</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.CFGGroup.System_Shutdown","title":"<code>System_Shutdown = pymmcore.g_CFGGroup_System_Shutdown</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.CFGGroup.System_Startup","title":"<code>System_Startup = pymmcore.g_CFGGroup_System_Startup</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceDetectionStatus","title":"<code>DeviceDetectionStatus</code>","text":"<p>DeviceDetectionStatus from device discovery.</p>"},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceDetectionStatus.CanCommunicate","title":"<code>CanCommunicate = pymmcore.CanCommunicate</code>  <code>class-attribute</code>","text":"<p>Communication verified, parameters have been set to valid values.</p>"},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceDetectionStatus.CanNotCommunicate","title":"<code>CanNotCommunicate = pymmcore.CanNotCommunicate</code>  <code>class-attribute</code>","text":"<p>Communication attributes are valid, but the device does not respond.</p>"},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceDetectionStatus.Misconfigured","title":"<code>Misconfigured = pymmcore.Misconfigured</code>  <code>class-attribute</code>","text":"<p>Some information needed to communicate with the device is invalid.</p>"},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceDetectionStatus.Unimplemented","title":"<code>Unimplemented = pymmcore.Unimplemented</code>  <code>class-attribute</code>","text":"<p>There is as yet no mechanism to programmatically detect the device.</p>"},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceInitializationState","title":"<code>DeviceInitializationState</code>","text":"<p>DeviceInitializationState returned by getDeviceInitializationState.</p>"},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceInitializationState.InitializationFailed","title":"<code>InitializationFailed = pymmcore.InitializationFailed</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceInitializationState.InitializedSuccessfully","title":"<code>InitializedSuccessfully = pymmcore.InitializedSuccessfully</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceInitializationState.Uninitialized","title":"<code>Uninitialized = pymmcore.Uninitialized</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceNotification","title":"<code>DeviceNotification</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceNotification.Attention","title":"<code>Attention = pymmcore.Attention</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceNotification.Done","title":"<code>Done = pymmcore.Done</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceNotification.StatusChanged","title":"<code>StatusChanged = pymmcore.StatusChanged</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType","title":"<code>DeviceType</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.Any","title":"<code>Any = AnyType</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.AnyType","title":"<code>AnyType = pymmcore.AnyType</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.AutoFocus","title":"<code>AutoFocus = AutoFocusDevice</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.AutoFocusDevice","title":"<code>AutoFocusDevice = pymmcore.AutoFocusDevice</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.Camera","title":"<code>Camera = CameraDevice</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.CameraDevice","title":"<code>CameraDevice = pymmcore.CameraDevice</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.Core","title":"<code>Core = CoreDevice</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.CoreDevice","title":"<code>CoreDevice = pymmcore.CoreDevice</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.Galvo","title":"<code>Galvo = GalvoDevice</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.GalvoDevice","title":"<code>GalvoDevice = pymmcore.GalvoDevice</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.Generic","title":"<code>Generic = GenericDevice</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.GenericDevice","title":"<code>GenericDevice = pymmcore.GenericDevice</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.Hub","title":"<code>Hub = HubDevice</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.HubDevice","title":"<code>HubDevice = pymmcore.HubDevice</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.ImageProcessor","title":"<code>ImageProcessor = ImageProcessorDevice</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.ImageProcessorDevice","title":"<code>ImageProcessorDevice = pymmcore.ImageProcessorDevice</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.Magnifier","title":"<code>Magnifier = MagnifierDevice</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.MagnifierDevice","title":"<code>MagnifierDevice = pymmcore.MagnifierDevice</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.PressurePump","title":"<code>PressurePump = PressurePumpDevice</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.PressurePumpDevice","title":"<code>PressurePumpDevice = pymmcore.PressurePumpDevice</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.SLM","title":"<code>SLM = SLMDevice</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.SLMDevice","title":"<code>SLMDevice = pymmcore.SLMDevice</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.Serial","title":"<code>Serial = SerialDevice</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.SerialDevice","title":"<code>SerialDevice = pymmcore.SerialDevice</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.Shutter","title":"<code>Shutter = ShutterDevice</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.ShutterDevice","title":"<code>ShutterDevice = pymmcore.ShutterDevice</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.SignalIO","title":"<code>SignalIO = SignalIODevice</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.SignalIODevice","title":"<code>SignalIODevice = pymmcore.SignalIODevice</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.Stage","title":"<code>Stage = StageDevice</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.StageDevice","title":"<code>StageDevice = pymmcore.StageDevice</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.State","title":"<code>State = StateDevice</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.StateDevice","title":"<code>StateDevice = pymmcore.StateDevice</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.Unknown","title":"<code>Unknown = UnknownType</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.UnknownType","title":"<code>UnknownType = pymmcore.UnknownType</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.VolumetricPump","title":"<code>VolumetricPump = VolumetricPumpDevice</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.VolumetricPumpDevice","title":"<code>VolumetricPumpDevice = pymmcore.VolumetricPumpDevice</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.XYStage","title":"<code>XYStage = XYStageDevice</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.XYStageDevice","title":"<code>XYStageDevice = pymmcore.XYStageDevice</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.FocusDirection","title":"<code>FocusDirection</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.FocusDirection.AwayFromSample","title":"<code>AwayFromSample = -1</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.FocusDirection.FocusDirectionAwayFromSample","title":"<code>FocusDirectionAwayFromSample = AwayFromSample</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.FocusDirection.FocusDirectionTowardSample","title":"<code>FocusDirectionTowardSample = TowardSample</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.FocusDirection.FocusDirectionUnknown","title":"<code>FocusDirectionUnknown = Unknown</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.FocusDirection.TowardSample","title":"<code>TowardSample = 1</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.FocusDirection.Unknown","title":"<code>Unknown = 0</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword","title":"<code>Keyword</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.ActualExposure","title":"<code>ActualExposure = pymmcore.g_Keyword_ActualExposure</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.ActualInterval_ms","title":"<code>ActualInterval_ms = pymmcore.g_Keyword_ActualInterval_ms</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.AnswerTimeout","title":"<code>AnswerTimeout = pymmcore.g_Keyword_AnswerTimeout</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.BaudRate","title":"<code>BaudRate = pymmcore.g_Keyword_BaudRate</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.Binning","title":"<code>Binning = pymmcore.g_Keyword_Binning</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.CCDTemperature","title":"<code>CCDTemperature = pymmcore.g_Keyword_CCDTemperature</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.CCDTemperatureSetPoint","title":"<code>CCDTemperatureSetPoint = pymmcore.g_Keyword_CCDTemperatureSetPoint</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.CameraChannelIndex","title":"<code>CameraChannelIndex = pymmcore.g_Keyword_CameraChannelIndex</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.CameraChannelName","title":"<code>CameraChannelName = pymmcore.g_Keyword_CameraChannelName</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.CameraID","title":"<code>CameraID = pymmcore.g_Keyword_CameraID</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.CameraName","title":"<code>CameraName = pymmcore.g_Keyword_CameraName</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.Channel","title":"<code>Channel = pymmcore.g_Keyword_Channel</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.Closed_Position","title":"<code>Closed_Position = pymmcore.g_Keyword_Closed_Position</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.ColorMode","title":"<code>ColorMode = pymmcore.g_Keyword_ColorMode</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.CoreAutoFocus","title":"<code>CoreAutoFocus = pymmcore.g_Keyword_CoreAutoFocus</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.CoreAutoShutter","title":"<code>CoreAutoShutter = pymmcore.g_Keyword_CoreAutoShutter</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.CoreCamera","title":"<code>CoreCamera = pymmcore.g_Keyword_CoreCamera</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.CoreChannelGroup","title":"<code>CoreChannelGroup = pymmcore.g_Keyword_CoreChannelGroup</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.CoreDevice","title":"<code>CoreDevice = pymmcore.g_Keyword_CoreDevice</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.CoreFocus","title":"<code>CoreFocus = pymmcore.g_Keyword_CoreFocus</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.CoreGalvo","title":"<code>CoreGalvo = pymmcore.g_Keyword_CoreGalvo</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.CoreImageProcessor","title":"<code>CoreImageProcessor = pymmcore.g_Keyword_CoreImageProcessor</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.CoreInitialize","title":"<code>CoreInitialize = pymmcore.g_Keyword_CoreInitialize</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.CoreSLM","title":"<code>CoreSLM = pymmcore.g_Keyword_CoreSLM</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.CoreShutter","title":"<code>CoreShutter = pymmcore.g_Keyword_CoreShutter</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.CoreTimeoutMs","title":"<code>CoreTimeoutMs = pymmcore.g_Keyword_CoreTimeoutMs</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.CoreXYStage","title":"<code>CoreXYStage = pymmcore.g_Keyword_CoreXYStage</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.DataBits","title":"<code>DataBits = pymmcore.g_Keyword_DataBits</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.Delay","title":"<code>Delay = pymmcore.g_Keyword_Delay</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.DelayBetweenCharsMs","title":"<code>DelayBetweenCharsMs = pymmcore.g_Keyword_DelayBetweenCharsMs</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.Description","title":"<code>Description = pymmcore.g_Keyword_Description</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.EMGain","title":"<code>EMGain = pymmcore.g_Keyword_EMGain</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.Elapsed_Time_ms","title":"<code>Elapsed_Time_ms = pymmcore.g_Keyword_Elapsed_Time_ms</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.Exposure","title":"<code>Exposure = pymmcore.g_Keyword_Exposure</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.Gain","title":"<code>Gain = pymmcore.g_Keyword_Gain</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.Handshaking","title":"<code>Handshaking = pymmcore.g_Keyword_Handshaking</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.HubID","title":"<code>HubID = pymmcore.g_Keyword_HubID</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.Interval_ms","title":"<code>Interval_ms = pymmcore.g_Keyword_Interval_ms</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.Label","title":"<code>Label = pymmcore.g_Keyword_Label</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.Metadata_CameraLabel","title":"<code>Metadata_CameraLabel = pymmcore.g_Keyword_Metadata_CameraLabel</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.Metadata_Exposure","title":"<code>Metadata_Exposure = pymmcore.g_Keyword_Metadata_Exposure</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.Metadata_Height","title":"<code>Metadata_Height = pymmcore.g_Keyword_Metadata_Height</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.Metadata_ImageNumber","title":"<code>Metadata_ImageNumber = pymmcore.g_Keyword_Metadata_ImageNumber</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.Metadata_ROI_X","title":"<code>Metadata_ROI_X = pymmcore.g_Keyword_Metadata_ROI_X</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.Metadata_ROI_Y","title":"<code>Metadata_ROI_Y = pymmcore.g_Keyword_Metadata_ROI_Y</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.Metadata_Score","title":"<code>Metadata_Score = pymmcore.g_Keyword_Metadata_Score</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.Metadata_TimeInCore","title":"<code>Metadata_TimeInCore = pymmcore.g_Keyword_Metadata_TimeInCore</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.Metadata_Width","title":"<code>Metadata_Width = pymmcore.g_Keyword_Metadata_Width</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.Name","title":"<code>Name = pymmcore.g_Keyword_Name</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.Offset","title":"<code>Offset = pymmcore.g_Keyword_Offset</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.Parity","title":"<code>Parity = pymmcore.g_Keyword_Parity</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.PixelType","title":"<code>PixelType = pymmcore.g_Keyword_PixelType</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.Port","title":"<code>Port = pymmcore.g_Keyword_Port</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.Position","title":"<code>Position = pymmcore.g_Keyword_Position</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.ReadoutMode","title":"<code>ReadoutMode = pymmcore.g_Keyword_ReadoutMode</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.ReadoutTime","title":"<code>ReadoutTime = pymmcore.g_Keyword_ReadoutTime</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.Speed","title":"<code>Speed = pymmcore.g_Keyword_Speed</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.State","title":"<code>State = pymmcore.g_Keyword_State</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.StopBits","title":"<code>StopBits = pymmcore.g_Keyword_StopBits</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.Transpose_Correction","title":"<code>Transpose_Correction = pymmcore.g_Keyword_Transpose_Correction</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.Transpose_MirrorX","title":"<code>Transpose_MirrorX = pymmcore.g_Keyword_Transpose_MirrorX</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.Transpose_MirrorY","title":"<code>Transpose_MirrorY = pymmcore.g_Keyword_Transpose_MirrorY</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.Transpose_SwapXY","title":"<code>Transpose_SwapXY = pymmcore.g_Keyword_Transpose_SwapXY</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.Type","title":"<code>Type = pymmcore.g_Keyword_Type</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.Version","title":"<code>Version = pymmcore.g_Keyword_Version</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.PixelFormat","title":"<code>PixelFormat</code>","text":"<p>Subset of GeniCam Pixel Format names used by pymmcore-plus.</p> <p>(This is similar to PixelType, but follows GeniCam standards.)</p> <p>See https://docs.baslerweb.com/pixel-format#unpacked-and-packed-pixel-formats for helpful clarifications.  Note that unpacked pixel formats (like Mono8, Mono12, Mono16) are always 8-bit aligned. Meaning Mono12 is actually a 16-bit buffer.</p> <p>Attributes:</p> Name Type Description <code>MONO8</code> <code>str</code> <p>8-bit (unpacked) monochrome pixel format.</p> <code>MONO10</code> <code>str</code> <p>10-bit (unpacked) monochrome pixel format. (16-bit buffer)</p> <code>MONO12</code> <code>str</code> <p>12-bit (unpacked) monochrome pixel format. (16-bit buffer)</p> <code>MONO14</code> <code>str</code> <p>14-bit (unpacked) monochrome pixel format. (16-bit buffer)</p> <code>MONO16</code> <code>str</code> <p>16-bit (unpacked) monochrome pixel format</p> <code>MONO32</code> <code>str</code> <p>32-bit (unpacked) monochrome pixel format</p> <code>RGB8</code> <code>str</code> <p>8-bit RGB pixel format. (24-bit buffer)</p> <code>RGB10</code> <code>str</code> <p>10-bit RGB pixel format. (48-bit buffer)</p> <code>RGB12</code> <code>str</code> <p>12-bit RGB pixel format. (48-bit buffer)</p> <code>RGB14</code> <code>str</code> <p>14-bit RGB pixel format. (48-bit buffer)</p> <code>RGB16</code> <code>str</code> <p>16-bit RGB pixel format. (48-bit buffer)</p>"},{"location":"api/constants/#pymmcore_plus.core._constants.PixelFormat.MONO10","title":"<code>MONO10 = 'Mono10'</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.PixelFormat.MONO12","title":"<code>MONO12 = 'Mono12'</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.PixelFormat.MONO14","title":"<code>MONO14 = 'Mono14'</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.PixelFormat.MONO16","title":"<code>MONO16 = 'Mono16'</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.PixelFormat.MONO32","title":"<code>MONO32 = 'Mono32'</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.PixelFormat.MONO8","title":"<code>MONO8 = 'Mono8'</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.PixelFormat.RGB10","title":"<code>RGB10 = 'RGB10'</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.PixelFormat.RGB12","title":"<code>RGB12 = 'RGB12'</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.PixelFormat.RGB14","title":"<code>RGB14 = 'RGB14'</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.PixelFormat.RGB16","title":"<code>RGB16 = 'RGB16'</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.PixelFormat.RGB8","title":"<code>RGB8 = 'RGB8'</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.PixelFormat.for_current_camera","title":"<code>for_current_camera(core: pymmcore.CMMCore) -&gt; PixelFormat</code>  <code>classmethod</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.PixelFormat.pick","title":"<code>pick(bit_depth: int, n_comp: int = 1) -&gt; PixelFormat</code>  <code>classmethod</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.PixelType","title":"<code>PixelType</code>","text":"<p>These are pixel types, as used in MMStudio and MMCoreJ wrapper.</p> <p>They are only here for supporting the legacy (and probably to-be-deprecated) taggedImages.</p>"},{"location":"api/constants/#pymmcore_plus.core._constants.PixelType.GRAY16","title":"<code>GRAY16 = 'GRAY16'</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.PixelType.GRAY32","title":"<code>GRAY32 = 'GRAY32'</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.PixelType.GRAY8","title":"<code>GRAY8 = 'GRAY8'</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.PixelType.RGB32","title":"<code>RGB32 = 'RGB32'</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.PixelType.RGB64","title":"<code>RGB64 = 'RGB64'</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.PixelType.UNKNOWN","title":"<code>UNKNOWN = ''</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.PixelType.for_bytes","title":"<code>for_bytes(depth: int, n_comp: int = 1) -&gt; PixelType</code>  <code>classmethod</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.PixelType.to_pixel_format","title":"<code>to_pixel_format() -&gt; PixelFormat</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.PortType","title":"<code>PortType</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.PortType.HIDPort","title":"<code>HIDPort = pymmcore.HIDPort</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.PortType.InvalidPort","title":"<code>InvalidPort = pymmcore.InvalidPort</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.PortType.SerialPort","title":"<code>SerialPort = pymmcore.SerialPort</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.PortType.USBPort","title":"<code>USBPort = pymmcore.USBPort</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.PropertyType","title":"<code>PropertyType</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.PropertyType.Boolean","title":"<code>Boolean = auto()</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.PropertyType.Enum","title":"<code>Enum = auto()</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.PropertyType.Float","title":"<code>Float = pymmcore.Float</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.PropertyType.Integer","title":"<code>Integer = pymmcore.Integer</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.PropertyType.String","title":"<code>String = pymmcore.String</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.PropertyType.Undef","title":"<code>Undef = pymmcore.Undef</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.PropertyType.create","title":"<code>create(value: Any) -&gt; PropertyType</code>  <code>classmethod</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.PropertyType.to_json","title":"<code>to_json() -&gt; str</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.PropertyType.to_python","title":"<code>to_python() -&gt; type | None</code>","text":""},{"location":"api/device/","title":"Device &amp; Property objects","text":"<p><code>pymmcore-plus</code> offers two classes that provide a more object-oriented interface to common operations and queries performed on devices and their properties.</p> <p>In the original <code>CMMCore</code> API, there are a lot of methods that accept a <code>deviceLabel</code> string as the first argument (and perhaps additional arguments) and query something about that device (e.g. <code>getDeviceLibrary</code>, <code>getDeviceType</code>, <code>waitForDevice</code>, etc...).  In <code>pymmcore-plus</code>, the <code>Device</code> class acts as a \"view\" onto a specific device, and these methods are implemented as methods (that no longer require the <code>deviceLabel</code> argument), and the <code>deviceLabel</code> is passed to the constructor.</p> <p>Similarly, there are many methods in the <code>CMMCore</code> API that require both a device label and a device property name, and modify that specific property (e.g. <code>isPropertySequenceable</code>, <code>getProperty</code>, <code>isPropertyReadOnly</code>, etc...).  Here, the <code>DeviceProperty</code> class acts as a \"view\" onto a specific device property, with an object-oriented interface to these methods.</p>"},{"location":"api/device/#pymmcore_plus.DeviceAdapter","title":"<code>pymmcore_plus.DeviceAdapter</code>","text":"<p>Convenience view onto a device-adapter library.</p> <p>This is the type of object that is returned by <code>pymmcore_plus.CMMCorePlus.getAdapterObject</code></p> <p>Parameters:</p> Name Type Description Default <code>library_name</code> <code>str</code> <p>Device this property belongs to</p> required <code>mmcore</code> <code>CMMCorePlus</code> <p>CMMCorePlus instance</p> required Source code in <code>pymmcore_plus/core/_adapter.py</code> <pre><code>class DeviceAdapter:\n    \"\"\"Convenience view onto a device-adapter library.\n\n    This is the type of object that is returned by\n    [`pymmcore_plus.CMMCorePlus.getAdapterObject`][]\n\n    Parameters\n    ----------\n    library_name : str\n        Device this property belongs to\n    mmcore : CMMCorePlus\n        CMMCorePlus instance\n    \"\"\"\n\n    def __init__(self, library_name: str, mmcore: CMMCorePlus) -&gt; None:\n        self._name = library_name\n        self._mmc = mmcore\n        # self.propertyChanged = _DevicePropValueSignal(device_label, None, mmcore)\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"Return the short name of this device adapter library.\"\"\"\n        return self._name\n\n    @property\n    def core(self) -&gt; CMMCorePlus:\n        \"\"\"Return the `CMMCorePlus` instance to which this Device is bound.\"\"\"\n        return self._mmc\n\n    @property\n    def available_devices(self) -&gt; tuple[Device, ...]:\n        \"\"\"Get available devices offered by this device adapter.\n\n        Returns\n        -------\n        tuple[Device, ...]\n            Tuple of `Device` objects, with the name, type, and description\n            of each device.  These objects also have a `load` method that can be used\n            to load the device under a given label.\n        \"\"\"\n        try:\n            devs = self._mmc.getAvailableDevices(self.name)\n        except RuntimeError:\n            return ()\n\n        types = self._mmc.getAvailableDeviceTypes(self.name)\n        descriptions = self._mmc.getAvailableDeviceDescriptions(self.name)\n        return tuple(\n            Device(\n                mmcore=self._mmc,\n                adapter_name=self.name,\n                device_name=dev_name,\n                type=DeviceType(dt),\n                description=desc,\n            )\n            for dev_name, dt, desc in zip(devs, types, descriptions, strict=False)\n        )\n\n    @property\n    def loaded_devices(self) -&gt; tuple[Device, ...]:\n        \"\"\"Get currently loaded devices controlled this adapter.\n\n        Returns\n        -------\n        tuple[Device, ...]\n            Tuple of loaded `Device` objects.\n        \"\"\"\n        return tuple(self._mmc.iterDevices(device_adapter=self.name))\n\n    def unload(self) -&gt; None:\n        \"\"\"Forcefully unload this library.\"\"\"\n        self._mmc.unloadLibrary(self.name)\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return string representation of this adapter.\"\"\"\n        core = repr(self._mmc).strip(\"&lt;&gt;\")\n        try:\n            ndevs = str(len(self._mmc.getAvailableDevices(self.name)))\n        except Exception:\n            ndevs = \"ERR\"\n        return f\"&lt;Adapter {self.name!r} on {core}: {ndevs} devices&gt;\"\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._adapter.DeviceAdapter.available_devices","title":"<code>available_devices() -&gt; tuple[Device, ...]</code>  <code>property</code>","text":"<p>Get available devices offered by this device adapter.</p> <p>Returns:</p> Type Description <code>tuple[Device, ...]</code> <p>Tuple of <code>Device</code> objects, with the name, type, and description of each device.  These objects also have a <code>load</code> method that can be used to load the device under a given label.</p> Source code in <code>pymmcore_plus/core/_adapter.py</code> <pre><code>@property\ndef available_devices(self) -&gt; tuple[Device, ...]:\n    \"\"\"Get available devices offered by this device adapter.\n\n    Returns\n    -------\n    tuple[Device, ...]\n        Tuple of `Device` objects, with the name, type, and description\n        of each device.  These objects also have a `load` method that can be used\n        to load the device under a given label.\n    \"\"\"\n    try:\n        devs = self._mmc.getAvailableDevices(self.name)\n    except RuntimeError:\n        return ()\n\n    types = self._mmc.getAvailableDeviceTypes(self.name)\n    descriptions = self._mmc.getAvailableDeviceDescriptions(self.name)\n    return tuple(\n        Device(\n            mmcore=self._mmc,\n            adapter_name=self.name,\n            device_name=dev_name,\n            type=DeviceType(dt),\n            description=desc,\n        )\n        for dev_name, dt, desc in zip(devs, types, descriptions, strict=False)\n    )\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._adapter.DeviceAdapter.core","title":"<code>core() -&gt; CMMCorePlus</code>  <code>property</code>","text":"<p>Return the <code>CMMCorePlus</code> instance to which this Device is bound.</p> Source code in <code>pymmcore_plus/core/_adapter.py</code> <pre><code>@property\ndef core(self) -&gt; CMMCorePlus:\n    \"\"\"Return the `CMMCorePlus` instance to which this Device is bound.\"\"\"\n    return self._mmc\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._adapter.DeviceAdapter.loaded_devices","title":"<code>loaded_devices() -&gt; tuple[Device, ...]</code>  <code>property</code>","text":"<p>Get currently loaded devices controlled this adapter.</p> <p>Returns:</p> Type Description <code>tuple[Device, ...]</code> <p>Tuple of loaded <code>Device</code> objects.</p> Source code in <code>pymmcore_plus/core/_adapter.py</code> <pre><code>@property\ndef loaded_devices(self) -&gt; tuple[Device, ...]:\n    \"\"\"Get currently loaded devices controlled this adapter.\n\n    Returns\n    -------\n    tuple[Device, ...]\n        Tuple of loaded `Device` objects.\n    \"\"\"\n    return tuple(self._mmc.iterDevices(device_adapter=self.name))\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._adapter.DeviceAdapter.name","title":"<code>name() -&gt; str</code>  <code>property</code>","text":"<p>Return the short name of this device adapter library.</p> Source code in <code>pymmcore_plus/core/_adapter.py</code> <pre><code>@property\ndef name(self) -&gt; str:\n    \"\"\"Return the short name of this device adapter library.\"\"\"\n    return self._name\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._adapter.DeviceAdapter.unload","title":"<code>unload() -&gt; None</code>","text":"<p>Forcefully unload this library.</p> Source code in <code>pymmcore_plus/core/_adapter.py</code> <pre><code>def unload(self) -&gt; None:\n    \"\"\"Forcefully unload this library.\"\"\"\n    self._mmc.unloadLibrary(self.name)\n</code></pre>"},{"location":"api/device/#pymmcore_plus.Device","title":"<code>pymmcore_plus.Device</code>","text":"<p>Convenience object-oriented device API.</p> <p>This is the type of object that is returned by <code>pymmcore_plus.CMMCorePlus.getDeviceObject</code></p> <p>Parameters:</p> Name Type Description Default <code>device_label</code> <code>str</code> <p>Device label assigned to this device.</p> <code>UNASSIGNED</code> <code>mmcore</code> <code>CMMCorePlus</code> <p>CMMCorePlus instance that owns this device.</p> <code>None</code> <code>device_type</code> <code>DeviceType or Device subclass, optional</code> <p>The type of device to create. If not specified, the type will be inferred from the core if the device is already loaded. If the device is not loaded, an error will be raised. This parameter is mainly intended for usage when calling from <code>CMMCorePlus.getDeviceObject()</code>.  Otherwise, prefer using <code>[SpecificDeviceSubclass].create()</code>.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; core = CMMCorePlus()\n&gt;&gt;&gt; device = Device(\"Camera\", core)\n&gt;&gt;&gt; device.isLoaded()\n&gt;&gt;&gt; device.load(\"NotALib\", \"DCam\")  # useful error\n&gt;&gt;&gt; device.load(\"DemoCamera\", \"DCam\")\n&gt;&gt;&gt; device.initialize()\n&gt;&gt;&gt; device.load(\"DemoCamera\", \"DCam\")  # no-op w/ useful warning\n&gt;&gt;&gt; device.properties  # tuple of DeviceProperty objects\n&gt;&gt;&gt; device.description()\n&gt;&gt;&gt; device.isBusy()\n&gt;&gt;&gt; device.wait()\n&gt;&gt;&gt; device.type()\n&gt;&gt;&gt; device.schema()  # JSON schema of device properties\n</code></pre> Source code in <code>pymmcore_plus/core/_device.py</code> <pre><code>class Device:\n    \"\"\"Convenience object-oriented device API.\n\n    This is the type of object that is returned by\n    [`pymmcore_plus.CMMCorePlus.getDeviceObject`][]\n\n    Parameters\n    ----------\n    device_label : str\n        Device label assigned to this device.\n    mmcore : CMMCorePlus\n        CMMCorePlus instance that owns this device.\n    device_type : DeviceType or Device subclass, optional\n        The type of device to create. If not specified, the type will be inferred\n        from the core if the device is already loaded. If the device is not loaded,\n        an error will be raised. This parameter is mainly intended for usage when\n        calling from `CMMCorePlus.getDeviceObject()`.  Otherwise, prefer using\n        `[SpecificDeviceSubclass].create()`.\n\n    Examples\n    --------\n    &gt;&gt;&gt; core = CMMCorePlus()\n    &gt;&gt;&gt; device = Device(\"Camera\", core)\n    &gt;&gt;&gt; device.isLoaded()\n    &gt;&gt;&gt; device.load(\"NotALib\", \"DCam\")  # useful error\n    &gt;&gt;&gt; device.load(\"DemoCamera\", \"DCam\")\n    &gt;&gt;&gt; device.initialize()\n    &gt;&gt;&gt; device.load(\"DemoCamera\", \"DCam\")  # no-op w/ useful warning\n    &gt;&gt;&gt; device.properties  # tuple of DeviceProperty objects\n    &gt;&gt;&gt; device.description()\n    &gt;&gt;&gt; device.isBusy()\n    &gt;&gt;&gt; device.wait()\n    &gt;&gt;&gt; device.type()\n    &gt;&gt;&gt; device.schema()  # JSON schema of device properties\n    \"\"\"\n\n    UNASSIGNED = \"__UNASSIGNED__\"\n    propertyChanged: PSignalInstance\n\n    @classmethod\n    def create(\n        cls,\n        device_label: str,\n        mmcore: CMMCorePlus,\n        device_type: type[Device] | DeviceType = DeviceType.Any,\n    ) -&gt; Self:\n        if device_type in {DeviceType.Any, DeviceType.Unknown}:\n            try:\n                sub_cls = cls.get_subclass(device_label, mmcore)\n            except RuntimeError as e:\n                raise RuntimeError(\n                    f\"Could not determine device type for {device_label}. \"\n                    \"If you are preloading a device object, \"\n                    \"please specify `device_type` as a `pymmcore_plus.DeviceType`.\"\n                ) from e\n        else:\n            if isinstance(device_type, type) and issubclass(device_type, Device):\n                sub_cls = device_type\n            elif isinstance(device_type, DeviceType):\n                sub_cls = _TYPE_MAP[device_type]\n            else:\n                raise TypeError(\n                    f\"Invalid device_type: {device_type!r}.  Must be a \"\n                    \"pymmcore_plus `DeviceType` or `Device` subclass.\"\n                )\n\n        # make sure it's an error to call this class method on a subclass with\n        # a non-matching type\n        if not issubclass(sub_cls, cls):\n            dev_type = mmcore.getDeviceType(device_label).name\n            raise TypeError(f\"Cannot cast {dev_type} {device_label!r} to {cls}\")\n\n        return sub_cls(device_label, mmcore)\n\n    @classmethod\n    def get_subclass(cls, device_label: str, mmcore: CMMCorePlus) -&gt; type[Device]:\n        dev_type = mmcore.getDeviceType(device_label)\n        return _TYPE_MAP[dev_type]\n\n    def __init__(\n        self,\n        device_label: str = UNASSIGNED,\n        mmcore: CMMCorePlus | None = None,\n        adapter_name: str = \"\",\n        device_name: str = \"\",\n        type: DeviceType = DeviceType.UnknownType,\n        description: str = \"\",\n    ) -&gt; None:\n        if mmcore is None:\n            from ._mmcore_plus import CMMCorePlus\n\n            mmcore = CMMCorePlus.instance()\n        else:\n            mmcore = mmcore\n\n        self._mmc_ref = weakref.ref(mmcore)\n        self._label = device_label\n        self._type = None\n        if self.isLoaded():\n            adapter_name = mmcore.getDeviceLibrary(device_label)\n            device_name = mmcore.getDeviceName(device_label)\n            description = mmcore.getDeviceDescription(device_label)\n            type = mmcore.getDeviceType(device_label)  # noqa: A001\n            if self.type() != type:\n                raise TypeError(\n                    f\"Cannot create loaded device with label {device_label!r} and type \"\n                    f\"{type.name!r} as an instance of {self.__class__.__name__!r}\"\n                )\n\n        self._adapter_name = adapter_name\n        self._device_name = device_name\n        self._type = type\n        self._description = description\n        self.propertyChanged = _DevicePropValueSignal(device_label, None, mmcore)\n\n    @property\n    def _mmc(self) -&gt; CMMCorePlus:\n        \"\"\"Return the `CMMCorePlus` instance to which this Device is bound.\"\"\"\n        mmc = self._mmc_ref()\n        if mmc is None:  # pragma: no cover\n            raise RuntimeError(\n                \"The CMMCorePlus instance to which this Device \"\n                \"is bound has been garbage collected.\"\n            )\n        return mmc\n\n    @property\n    def label(self) -&gt; str:\n        \"\"\"Return the assigned label of this device.\"\"\"\n        return self._label\n\n    @label.setter\n    def label(self, value: str) -&gt; None:\n        if self.isLoaded():\n            raise RuntimeError(f\"Cannot change label of loaded device {self.label!r}.\")\n        if value in self._mmc.getLoadedDevices():  # pragma: no cover\n            raise RuntimeError(f\"Label {value!r} is already in use.\")\n        self._label = value\n\n    @property\n    def core(self) -&gt; CMMCorePlus:\n        \"\"\"Return the `CMMCorePlus` instance to which this Device is bound.\"\"\"\n        return self._mmc\n\n    def isBusy(self) -&gt; bool:\n        \"\"\"Return busy status for this device.\"\"\"\n        return self._mmc.deviceBusy(self.label)\n\n    def delayMs(self) -&gt; float:\n        \"\"\"Return action delay in ms for this device.\"\"\"\n        return self._mmc.getDeviceDelayMs(self.label)\n\n    def setDelayMs(self, delayMs: float) -&gt; None:\n        \"\"\"Override the built-in value for the action delay.\"\"\"\n        self._mmc.setDeviceDelayMs(self.label, delayMs)\n\n    def usesDelay(self) -&gt; bool:\n        \"\"\"Return `True` if the device will use the delay setting or not.\"\"\"\n        return self._mmc.usesDeviceDelay(self.label)\n\n    def description(self) -&gt; str:\n        \"\"\"Return device description.\"\"\"\n        return self._description or self._mmc.getDeviceDescription(self.label)\n\n    def library(self) -&gt; str:\n        \"\"\"Return device library (aka module, device adapter) name.\"\"\"\n        return self._adapter_name or self._mmc.getDeviceLibrary(self.label)\n\n    def name(self) -&gt; str:\n        \"\"\"Return the device name (this is not the same as the assigned label).\"\"\"\n        return self._device_name or self._mmc.getDeviceName(self.label)\n\n    def propertyNames(self) -&gt; tuple[str, ...]:\n        \"\"\"Return all property names supported by this device.\"\"\"\n        return self._mmc.getDevicePropertyNames(self.label)\n\n    @property\n    def properties(self) -&gt; tuple[DeviceProperty, ...]:\n        \"\"\"Get all properties supported by device as DeviceProperty objects.\"\"\"\n        return tuple(self.getPropertyObject(name) for name in self.propertyNames())\n\n    def getPropertyObject(self, property_name: str) -&gt; DeviceProperty:\n        \"\"\"Return a `DeviceProperty` object bound to this device on this core.\"\"\"\n        if not self._mmc.hasProperty(self.label, property_name):\n            raise ValueError(f\"Device {self.label!r} has no property {property_name!r}\")\n        return DeviceProperty(self.label, property_name, self._mmc)\n\n    def setProperty(self, property_name: str, value: bool | float | int | str) -&gt; None:\n        \"\"\"Set a device property value.\n\n        See also,\n        [`Device.getPropertyObject`][pymmcore_plus.core.Device.getPropertyObject].\n\n        Examples\n        --------\n        &gt;&gt;&gt; camera = Device(\"Camera\")\n        &gt;&gt;&gt; camera.setProperty(\"Exposure\", 100)\n        &gt;&gt;&gt; print(camera.getProperty(\"Exposure\"))\n        # or\n        &gt;&gt;&gt; exposure = camera.getPropertyObject(\"Exposure\")\n        &gt;&gt;&gt; exposure.value = 100\n        &gt;&gt;&gt; print(exposure.value)\n        \"\"\"\n        return self._mmc.setProperty(self.label, property_name, value)\n\n    def getProperty(self, property_name: str) -&gt; str:\n        \"\"\"Get a device property value.\"\"\"\n        return self._mmc.getProperty(self.label, property_name)\n\n    def initialize(self) -&gt; None:\n        \"\"\"Initialize device.\"\"\"\n        return self._mmc.initializeDevice(self.label)\n\n    def unload(self) -&gt; None:\n        \"\"\"Unload device from the core and adjust all configuration data.\"\"\"\n        return self._mmc.unloadDevice(self.label)\n\n    def isLoaded(self) -&gt; bool:\n        \"\"\"Return `True` if device is loaded.\"\"\"\n        return self.label in self._mmc.getLoadedDevices()\n\n    def load(\n        self,\n        adapter_name: str = \"\",\n        device_name: str = \"\",\n        device_label: str = \"\",\n    ) -&gt; Device:\n        \"\"\"Load device from the plugin library.\n\n        Parameters\n        ----------\n        adapter_name : str\n            The name of the device adapter module (short name, not full file name).\n            (This is what is returned by `Device.library()`). Must be specified if\n            `adapter_name` was not provided to the `Device` constructor.\n        device_name : str\n            The name of the device. The name must correspond to one of the names\n            recognized by the specific plugin library. (This is what is returned by\n            `Device.name()`). Must be specified if `device_name` was not provided to\n            the `Device` constructor.\n        device_label : str\n            The name to assign to the device. If not specified, the device will be\n            assigned a default name: `adapter_name-device_name`, unless this Device\n            instance was initialized with a label.\n        \"\"\"\n        # if self.isLoaded():\n        # raise RuntimeError(f\"Device {self.label!r} is already loaded.\")\n\n        if not (adapter_name := adapter_name or self._adapter_name):\n            raise TypeError(\"Must specify adapter_name\")\n        if not (device_name := device_name or self._device_name):\n            raise TypeError(\"Must specify device_name\")\n        if device_label:\n            self.label = device_label\n        elif self.label == self.UNASSIGNED:\n            self.label = f\"{adapter_name}-{device_name}\"\n\n        # note: this method takes care of label already being loaded and only\n        # warns if the exact label, adapter, and device are in use\n        self._mmc.loadDevice(self.label, adapter_name, device_name)\n        return Device.create(self.label, self._mmc)\n\n    def detect(self) -&gt; DeviceDetectionStatus:\n        \"\"\"Tries to communicate to device through a given serial port.\n\n        Used to automate discovery of correct serial port. Also configures the\n        serial port correctly.\n        \"\"\"\n        return self._mmc.detectDevice(self.label)\n\n    def supportsDetection(self) -&gt; bool:\n        \"\"\"Return whether or not the device supports automatic device detection.\n\n        (i.e. whether or not detectDevice() may be safely called).\n        \"\"\"\n        try:\n            return self._mmc.supportsDeviceDetection(self.label)\n        except RuntimeError:\n            return False  # e.g. core devices\n\n    def type(self) -&gt; DeviceType:\n        \"\"\"Return device type.\"\"\"\n        return self._type or self._mmc.getDeviceType(self.label)\n\n    def schema(self) -&gt; DeviceSchema:\n        \"\"\"Return dict in JSON-schema format for properties of `device_label`.\"\"\"\n        return self._mmc.getDeviceSchema(self.label)\n\n    def wait(self) -&gt; None:\n        \"\"\"Block the calling thread until device becomes non-busy.\"\"\"\n        self._mmc.waitForDevice(self.label)\n\n    def getParentLabel(self) -&gt; str:\n        \"\"\"Return the parent device label of this device.\"\"\"\n        return self._mmc.getParentLabel(self.label)\n\n    def setParentLabel(self, parent_label: str) -&gt; None:\n        \"\"\"Set the parent device label of this device.\"\"\"\n        self._mmc.setParentLabel(self.label, parent_label)\n\n    def __repr__(self) -&gt; str:\n        if self.isLoaded():\n            n = len(self.propertyNames())\n            props = f\"{n} {'properties' if n &gt; 1 else 'property'}\"\n            lib = f\"({self.library()}::{self.name()}) \"\n        else:\n            props = \"NOT LOADED\"\n            lib = \"\"\n        core = repr(self._mmc).strip(\"&lt;&gt;\")\n        return f\"&lt;{self.__class__.__name__} {self.label!r} {lib}on {core}: {props}&gt;\"\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._device.Device.UNASSIGNED","title":"<code>UNASSIGNED = '__UNASSIGNED__'</code>  <code>class-attribute</code>","text":""},{"location":"api/device/#pymmcore_plus.core._device.Device.propertyChanged","title":"<code>propertyChanged = _DevicePropValueSignal(device_label, None, mmcore)</code>  <code>instance-attribute</code>","text":""},{"location":"api/device/#pymmcore_plus.core._device.Device.core","title":"<code>core() -&gt; CMMCorePlus</code>  <code>property</code>","text":"<p>Return the <code>CMMCorePlus</code> instance to which this Device is bound.</p> Source code in <code>pymmcore_plus/core/_device.py</code> <pre><code>@property\ndef core(self) -&gt; CMMCorePlus:\n    \"\"\"Return the `CMMCorePlus` instance to which this Device is bound.\"\"\"\n    return self._mmc\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._device.Device.create","title":"<code>create(device_label: str, mmcore: CMMCorePlus, device_type: type[Device] | DeviceType = DeviceType.Any) -&gt; Self</code>  <code>classmethod</code>","text":"Source code in <code>pymmcore_plus/core/_device.py</code> <pre><code>@classmethod\ndef create(\n    cls,\n    device_label: str,\n    mmcore: CMMCorePlus,\n    device_type: type[Device] | DeviceType = DeviceType.Any,\n) -&gt; Self:\n    if device_type in {DeviceType.Any, DeviceType.Unknown}:\n        try:\n            sub_cls = cls.get_subclass(device_label, mmcore)\n        except RuntimeError as e:\n            raise RuntimeError(\n                f\"Could not determine device type for {device_label}. \"\n                \"If you are preloading a device object, \"\n                \"please specify `device_type` as a `pymmcore_plus.DeviceType`.\"\n            ) from e\n    else:\n        if isinstance(device_type, type) and issubclass(device_type, Device):\n            sub_cls = device_type\n        elif isinstance(device_type, DeviceType):\n            sub_cls = _TYPE_MAP[device_type]\n        else:\n            raise TypeError(\n                f\"Invalid device_type: {device_type!r}.  Must be a \"\n                \"pymmcore_plus `DeviceType` or `Device` subclass.\"\n            )\n\n    # make sure it's an error to call this class method on a subclass with\n    # a non-matching type\n    if not issubclass(sub_cls, cls):\n        dev_type = mmcore.getDeviceType(device_label).name\n        raise TypeError(f\"Cannot cast {dev_type} {device_label!r} to {cls}\")\n\n    return sub_cls(device_label, mmcore)\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._device.Device.delayMs","title":"<code>delayMs() -&gt; float</code>","text":"<p>Return action delay in ms for this device.</p> Source code in <code>pymmcore_plus/core/_device.py</code> <pre><code>def delayMs(self) -&gt; float:\n    \"\"\"Return action delay in ms for this device.\"\"\"\n    return self._mmc.getDeviceDelayMs(self.label)\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._device.Device.description","title":"<code>description() -&gt; str</code>","text":"<p>Return device description.</p> Source code in <code>pymmcore_plus/core/_device.py</code> <pre><code>def description(self) -&gt; str:\n    \"\"\"Return device description.\"\"\"\n    return self._description or self._mmc.getDeviceDescription(self.label)\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._device.Device.detect","title":"<code>detect() -&gt; DeviceDetectionStatus</code>","text":"<p>Tries to communicate to device through a given serial port.</p> <p>Used to automate discovery of correct serial port. Also configures the serial port correctly.</p> Source code in <code>pymmcore_plus/core/_device.py</code> <pre><code>def detect(self) -&gt; DeviceDetectionStatus:\n    \"\"\"Tries to communicate to device through a given serial port.\n\n    Used to automate discovery of correct serial port. Also configures the\n    serial port correctly.\n    \"\"\"\n    return self._mmc.detectDevice(self.label)\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._device.Device.getParentLabel","title":"<code>getParentLabel() -&gt; str</code>","text":"<p>Return the parent device label of this device.</p> Source code in <code>pymmcore_plus/core/_device.py</code> <pre><code>def getParentLabel(self) -&gt; str:\n    \"\"\"Return the parent device label of this device.\"\"\"\n    return self._mmc.getParentLabel(self.label)\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._device.Device.getProperty","title":"<code>getProperty(property_name: str) -&gt; str</code>","text":"<p>Get a device property value.</p> Source code in <code>pymmcore_plus/core/_device.py</code> <pre><code>def getProperty(self, property_name: str) -&gt; str:\n    \"\"\"Get a device property value.\"\"\"\n    return self._mmc.getProperty(self.label, property_name)\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._device.Device.getPropertyObject","title":"<code>getPropertyObject(property_name: str) -&gt; DeviceProperty</code>","text":"<p>Return a <code>DeviceProperty</code> object bound to this device on this core.</p> Source code in <code>pymmcore_plus/core/_device.py</code> <pre><code>def getPropertyObject(self, property_name: str) -&gt; DeviceProperty:\n    \"\"\"Return a `DeviceProperty` object bound to this device on this core.\"\"\"\n    if not self._mmc.hasProperty(self.label, property_name):\n        raise ValueError(f\"Device {self.label!r} has no property {property_name!r}\")\n    return DeviceProperty(self.label, property_name, self._mmc)\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._device.Device.get_subclass","title":"<code>get_subclass(device_label: str, mmcore: CMMCorePlus) -&gt; type[Device]</code>  <code>classmethod</code>","text":"Source code in <code>pymmcore_plus/core/_device.py</code> <pre><code>@classmethod\ndef get_subclass(cls, device_label: str, mmcore: CMMCorePlus) -&gt; type[Device]:\n    dev_type = mmcore.getDeviceType(device_label)\n    return _TYPE_MAP[dev_type]\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._device.Device.initialize","title":"<code>initialize() -&gt; None</code>","text":"<p>Initialize device.</p> Source code in <code>pymmcore_plus/core/_device.py</code> <pre><code>def initialize(self) -&gt; None:\n    \"\"\"Initialize device.\"\"\"\n    return self._mmc.initializeDevice(self.label)\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._device.Device.isBusy","title":"<code>isBusy() -&gt; bool</code>","text":"<p>Return busy status for this device.</p> Source code in <code>pymmcore_plus/core/_device.py</code> <pre><code>def isBusy(self) -&gt; bool:\n    \"\"\"Return busy status for this device.\"\"\"\n    return self._mmc.deviceBusy(self.label)\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._device.Device.isLoaded","title":"<code>isLoaded() -&gt; bool</code>","text":"<p>Return <code>True</code> if device is loaded.</p> Source code in <code>pymmcore_plus/core/_device.py</code> <pre><code>def isLoaded(self) -&gt; bool:\n    \"\"\"Return `True` if device is loaded.\"\"\"\n    return self.label in self._mmc.getLoadedDevices()\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._device.Device.label","title":"<code>label() -&gt; str</code>  <code>writable</code> <code>property</code>","text":"<p>Return the assigned label of this device.</p> Source code in <code>pymmcore_plus/core/_device.py</code> <pre><code>@property\ndef label(self) -&gt; str:\n    \"\"\"Return the assigned label of this device.\"\"\"\n    return self._label\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._device.Device.library","title":"<code>library() -&gt; str</code>","text":"<p>Return device library (aka module, device adapter) name.</p> Source code in <code>pymmcore_plus/core/_device.py</code> <pre><code>def library(self) -&gt; str:\n    \"\"\"Return device library (aka module, device adapter) name.\"\"\"\n    return self._adapter_name or self._mmc.getDeviceLibrary(self.label)\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._device.Device.load","title":"<code>load(adapter_name: str = '', device_name: str = '', device_label: str = '') -&gt; Device</code>","text":"<p>Load device from the plugin library.</p> <p>Parameters:</p> Name Type Description Default <code>adapter_name</code> <code>str</code> <p>The name of the device adapter module (short name, not full file name). (This is what is returned by <code>Device.library()</code>). Must be specified if <code>adapter_name</code> was not provided to the <code>Device</code> constructor.</p> <code>''</code> <code>device_name</code> <code>str</code> <p>The name of the device. The name must correspond to one of the names recognized by the specific plugin library. (This is what is returned by <code>Device.name()</code>). Must be specified if <code>device_name</code> was not provided to the <code>Device</code> constructor.</p> <code>''</code> <code>device_label</code> <code>str</code> <p>The name to assign to the device. If not specified, the device will be assigned a default name: <code>adapter_name-device_name</code>, unless this Device instance was initialized with a label.</p> <code>''</code> Source code in <code>pymmcore_plus/core/_device.py</code> <pre><code>def load(\n    self,\n    adapter_name: str = \"\",\n    device_name: str = \"\",\n    device_label: str = \"\",\n) -&gt; Device:\n    \"\"\"Load device from the plugin library.\n\n    Parameters\n    ----------\n    adapter_name : str\n        The name of the device adapter module (short name, not full file name).\n        (This is what is returned by `Device.library()`). Must be specified if\n        `adapter_name` was not provided to the `Device` constructor.\n    device_name : str\n        The name of the device. The name must correspond to one of the names\n        recognized by the specific plugin library. (This is what is returned by\n        `Device.name()`). Must be specified if `device_name` was not provided to\n        the `Device` constructor.\n    device_label : str\n        The name to assign to the device. If not specified, the device will be\n        assigned a default name: `adapter_name-device_name`, unless this Device\n        instance was initialized with a label.\n    \"\"\"\n    # if self.isLoaded():\n    # raise RuntimeError(f\"Device {self.label!r} is already loaded.\")\n\n    if not (adapter_name := adapter_name or self._adapter_name):\n        raise TypeError(\"Must specify adapter_name\")\n    if not (device_name := device_name or self._device_name):\n        raise TypeError(\"Must specify device_name\")\n    if device_label:\n        self.label = device_label\n    elif self.label == self.UNASSIGNED:\n        self.label = f\"{adapter_name}-{device_name}\"\n\n    # note: this method takes care of label already being loaded and only\n    # warns if the exact label, adapter, and device are in use\n    self._mmc.loadDevice(self.label, adapter_name, device_name)\n    return Device.create(self.label, self._mmc)\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._device.Device.name","title":"<code>name() -&gt; str</code>","text":"<p>Return the device name (this is not the same as the assigned label).</p> Source code in <code>pymmcore_plus/core/_device.py</code> <pre><code>def name(self) -&gt; str:\n    \"\"\"Return the device name (this is not the same as the assigned label).\"\"\"\n    return self._device_name or self._mmc.getDeviceName(self.label)\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._device.Device.properties","title":"<code>properties() -&gt; tuple[DeviceProperty, ...]</code>  <code>property</code>","text":"<p>Get all properties supported by device as DeviceProperty objects.</p> Source code in <code>pymmcore_plus/core/_device.py</code> <pre><code>@property\ndef properties(self) -&gt; tuple[DeviceProperty, ...]:\n    \"\"\"Get all properties supported by device as DeviceProperty objects.\"\"\"\n    return tuple(self.getPropertyObject(name) for name in self.propertyNames())\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._device.Device.propertyNames","title":"<code>propertyNames() -&gt; tuple[str, ...]</code>","text":"<p>Return all property names supported by this device.</p> Source code in <code>pymmcore_plus/core/_device.py</code> <pre><code>def propertyNames(self) -&gt; tuple[str, ...]:\n    \"\"\"Return all property names supported by this device.\"\"\"\n    return self._mmc.getDevicePropertyNames(self.label)\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._device.Device.schema","title":"<code>schema() -&gt; DeviceSchema</code>","text":"<p>Return dict in JSON-schema format for properties of <code>device_label</code>.</p> Source code in <code>pymmcore_plus/core/_device.py</code> <pre><code>def schema(self) -&gt; DeviceSchema:\n    \"\"\"Return dict in JSON-schema format for properties of `device_label`.\"\"\"\n    return self._mmc.getDeviceSchema(self.label)\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._device.Device.setDelayMs","title":"<code>setDelayMs(delayMs: float) -&gt; None</code>","text":"<p>Override the built-in value for the action delay.</p> Source code in <code>pymmcore_plus/core/_device.py</code> <pre><code>def setDelayMs(self, delayMs: float) -&gt; None:\n    \"\"\"Override the built-in value for the action delay.\"\"\"\n    self._mmc.setDeviceDelayMs(self.label, delayMs)\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._device.Device.setParentLabel","title":"<code>setParentLabel(parent_label: str) -&gt; None</code>","text":"<p>Set the parent device label of this device.</p> Source code in <code>pymmcore_plus/core/_device.py</code> <pre><code>def setParentLabel(self, parent_label: str) -&gt; None:\n    \"\"\"Set the parent device label of this device.\"\"\"\n    self._mmc.setParentLabel(self.label, parent_label)\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._device.Device.setProperty","title":"<code>setProperty(property_name: str, value: bool | float | int | str) -&gt; None</code>","text":"<p>Set a device property value.</p> <p>See also, <code>Device.getPropertyObject</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; camera = Device(\"Camera\")\n&gt;&gt;&gt; camera.setProperty(\"Exposure\", 100)\n&gt;&gt;&gt; print(camera.getProperty(\"Exposure\"))\n# or\n&gt;&gt;&gt; exposure = camera.getPropertyObject(\"Exposure\")\n&gt;&gt;&gt; exposure.value = 100\n&gt;&gt;&gt; print(exposure.value)\n</code></pre> Source code in <code>pymmcore_plus/core/_device.py</code> <pre><code>def setProperty(self, property_name: str, value: bool | float | int | str) -&gt; None:\n    \"\"\"Set a device property value.\n\n    See also,\n    [`Device.getPropertyObject`][pymmcore_plus.core.Device.getPropertyObject].\n\n    Examples\n    --------\n    &gt;&gt;&gt; camera = Device(\"Camera\")\n    &gt;&gt;&gt; camera.setProperty(\"Exposure\", 100)\n    &gt;&gt;&gt; print(camera.getProperty(\"Exposure\"))\n    # or\n    &gt;&gt;&gt; exposure = camera.getPropertyObject(\"Exposure\")\n    &gt;&gt;&gt; exposure.value = 100\n    &gt;&gt;&gt; print(exposure.value)\n    \"\"\"\n    return self._mmc.setProperty(self.label, property_name, value)\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._device.Device.supportsDetection","title":"<code>supportsDetection() -&gt; bool</code>","text":"<p>Return whether or not the device supports automatic device detection.</p> <p>(i.e. whether or not detectDevice() may be safely called).</p> Source code in <code>pymmcore_plus/core/_device.py</code> <pre><code>def supportsDetection(self) -&gt; bool:\n    \"\"\"Return whether or not the device supports automatic device detection.\n\n    (i.e. whether or not detectDevice() may be safely called).\n    \"\"\"\n    try:\n        return self._mmc.supportsDeviceDetection(self.label)\n    except RuntimeError:\n        return False  # e.g. core devices\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._device.Device.type","title":"<code>type() -&gt; DeviceType</code>","text":"<p>Return device type.</p> Source code in <code>pymmcore_plus/core/_device.py</code> <pre><code>def type(self) -&gt; DeviceType:\n    \"\"\"Return device type.\"\"\"\n    return self._type or self._mmc.getDeviceType(self.label)\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._device.Device.unload","title":"<code>unload() -&gt; None</code>","text":"<p>Unload device from the core and adjust all configuration data.</p> Source code in <code>pymmcore_plus/core/_device.py</code> <pre><code>def unload(self) -&gt; None:\n    \"\"\"Unload device from the core and adjust all configuration data.\"\"\"\n    return self._mmc.unloadDevice(self.label)\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._device.Device.usesDelay","title":"<code>usesDelay() -&gt; bool</code>","text":"<p>Return <code>True</code> if the device will use the delay setting or not.</p> Source code in <code>pymmcore_plus/core/_device.py</code> <pre><code>def usesDelay(self) -&gt; bool:\n    \"\"\"Return `True` if the device will use the delay setting or not.\"\"\"\n    return self._mmc.usesDeviceDelay(self.label)\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._device.Device.wait","title":"<code>wait() -&gt; None</code>","text":"<p>Block the calling thread until device becomes non-busy.</p> Source code in <code>pymmcore_plus/core/_device.py</code> <pre><code>def wait(self) -&gt; None:\n    \"\"\"Block the calling thread until device becomes non-busy.\"\"\"\n    self._mmc.waitForDevice(self.label)\n</code></pre>"},{"location":"api/device/#pymmcore_plus.DeviceProperty","title":"<code>pymmcore_plus.DeviceProperty</code>","text":"<p>Convenience view onto a device property.</p> <p>This is the type of object that is returned by <code>pymmcore_plus.CMMCorePlus.getPropertyObject</code></p> <p>Parameters:</p> Name Type Description Default <code>device_label</code> <code>str</code> <p>Device this property belongs to</p> required <code>property_name</code> <code>str</code> <p>Name of this property</p> required <code>mmcore</code> <code>CMMCorePlus</code> <p>CMMCorePlus instance</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; core = CMMCorePlus()\n&gt;&gt;&gt; prop = DeviceProperty(\"Objective\", \"Label\", core)\n&gt;&gt;&gt; prop.isValid()  # points to a loaded device property in core\n&gt;&gt;&gt; prop.value\n&gt;&gt;&gt; prop.value = \"Objective-2\"  # setter\n&gt;&gt;&gt; prop.isReadOnly()\n&gt;&gt;&gt; prop.hasLimits()\n&gt;&gt;&gt; prop.range()\n&gt;&gt;&gt; prop.dict()  # all the info in one dict.\n</code></pre> Source code in <code>pymmcore_plus/core/_property.py</code> <pre><code>class DeviceProperty:\n    \"\"\"Convenience view onto a device property.\n\n    This is the type of object that is returned by\n    [`pymmcore_plus.CMMCorePlus.getPropertyObject`][]\n\n    Parameters\n    ----------\n    device_label : str\n        Device this property belongs to\n    property_name : str\n        Name of this property\n    mmcore : CMMCorePlus\n        CMMCorePlus instance\n\n    Examples\n    --------\n    &gt;&gt;&gt; core = CMMCorePlus()\n    &gt;&gt;&gt; prop = DeviceProperty(\"Objective\", \"Label\", core)\n    &gt;&gt;&gt; prop.isValid()  # points to a loaded device property in core\n    &gt;&gt;&gt; prop.value\n    &gt;&gt;&gt; prop.value = \"Objective-2\"  # setter\n    &gt;&gt;&gt; prop.isReadOnly()\n    &gt;&gt;&gt; prop.hasLimits()\n    &gt;&gt;&gt; prop.range()\n    &gt;&gt;&gt; prop.dict()  # all the info in one dict.\n    \"\"\"\n\n    def __init__(\n        self, device_label: str, property_name: str, mmcore: CMMCorePlus\n    ) -&gt; None:\n        self.device = device_label\n        self.name = property_name\n        self._mmc_ref = weakref.ref(mmcore)\n\n    @property\n    def core(self) -&gt; CMMCorePlus:\n        \"\"\"Return the `CMMCorePlus` instance to which this Property is bound.\"\"\"\n        if (mmc := self._mmc_ref()) is None:  # pragma: no cover\n            raise RuntimeError(\n                \"The CMMCorePlus instance to which this Property \"\n                \"is bound has been deleted.\"\n            )\n        return mmc\n\n    @cached_property\n    def valueChanged(self) -&gt; _DevicePropValueSignal:\n        return _DevicePropValueSignal(self.device, self.name, self.core)\n\n    def isValid(self) -&gt; bool:\n        \"\"\"Return `True` if device is loaded and has a property by this name.\"\"\"\n        return self.isLoaded() and self.core.hasProperty(self.device, self.name)\n\n    def isLoaded(self) -&gt; bool:\n        \"\"\"Return true if the device name is loaded.\"\"\"\n        return self.core is not None and self.device in self.core.getLoadedDevices()\n\n    @property\n    def value(self) -&gt; Any:\n        \"\"\"Return current property value, cast to appropriate type if applicable.\"\"\"\n        v = self.core.getProperty(self.device, self.name)\n        if type_ := self.type().to_python():\n            v = type_(v)\n        return v\n\n    @value.setter\n    def value(self, val: Any) -&gt; None:\n        \"\"\"Set current property value.\"\"\"\n        self.setValue(val)\n\n    def fromCache(self) -&gt; Any:\n        \"\"\"Return cached property value.\"\"\"\n        return self.core.getPropertyFromCache(self.device, self.name)\n\n    def setValue(self, val: Any) -&gt; None:\n        \"\"\"Functional alternate to property setter.\"\"\"\n        if self.isReadOnly():\n            import warnings\n\n            warnings.warn(\n                f\"'{self.device}::{self.name}' is a read-only property.\", stacklevel=2\n            )\n        try:\n            self.core.setProperty(self.device, self.name, val)\n        except RuntimeError as e:\n            msg = str(e)\n            if allowed := self.allowedValues():\n                msg += f\". Allowed values: {allowed}\"\n            raise RuntimeError(msg) from None\n\n    def isReadOnly(self) -&gt; bool:\n        \"\"\"Return `True` if property is read only.\"\"\"\n        return self.core.isPropertyReadOnly(self.device, self.name)\n\n    def isPreInit(self) -&gt; bool:\n        \"\"\"Return `True` if property must be defined prior to initialization.\"\"\"\n        return self.core.isPropertyPreInit(self.device, self.name)\n\n    def hasLimits(self) -&gt; bool:\n        \"\"\"Return `True` if property has limits.\"\"\"\n        return self.core.hasPropertyLimits(self.device, self.name)\n\n    def lowerLimit(self) -&gt; float:\n        \"\"\"Return lower limit if property has limits, or 0 otherwise.\"\"\"\n        return self.core.getPropertyLowerLimit(self.device, self.name)\n\n    def upperLimit(self) -&gt; float:\n        \"\"\"Return upper limit if property has limits, or 0 otherwise.\"\"\"\n        return self.core.getPropertyUpperLimit(self.device, self.name)\n\n    def range(self) -&gt; tuple[float, float]:\n        \"\"\"Return (lowerLimit, upperLimit) range tuple.\"\"\"\n        return (self.lowerLimit(), self.upperLimit())\n\n    def type(self) -&gt; PropertyType:\n        \"\"\"Return `PropertyType` of this property.\"\"\"\n        return self.core.getPropertyType(self.device, self.name)\n\n    def deviceType(self) -&gt; DeviceType:\n        \"\"\"Return `DeviceType` of the device owning this property.\"\"\"\n        return self.core.getDeviceType(self.device)\n\n    def allowedValues(self) -&gt; tuple[str, ...]:\n        \"\"\"Return allowed values for this property, if constrained.\"\"\"\n        # https://github.com/micro-manager/mmCoreAndDevices/issues/172\n        allowed = self.core.getAllowedPropertyValues(self.device, self.name)\n        if not allowed and self.deviceType() is DeviceType.StateDevice:\n            if self.name == Keyword.State:\n                n_states = self.core.getNumberOfStates(self.device)\n                allowed = tuple(str(i) for i in range(n_states))\n            elif self.name == Keyword.Label:\n                allowed = self.core.getStateLabels(self.device)\n        return allowed\n\n    def isSequenceable(self) -&gt; bool:\n        \"\"\"Return `True` if property can be used in a sequence.\"\"\"\n        return self.core.isPropertySequenceable(self.device, self.name)\n\n    def sequenceMaxLength(self) -&gt; int:\n        \"\"\"Return maximum number of property events that can be put in a sequence.\"\"\"\n        return self.core.getPropertySequenceMaxLength(self.device, self.name)\n\n    def loadSequence(self, eventSequence: Sequence[str]) -&gt; None:\n        \"\"\"Transfer a sequence of events/states/whatever to the device.\n\n        Parameters\n        ----------\n        eventSequence : Sequence[str]\n            The sequence of events/states that the device will execute in response\n            to external triggers\n        \"\"\"\n        self.core.loadPropertySequence(self.device, self.name, eventSequence)\n\n    def startSequence(self) -&gt; None:\n        \"\"\"Start an ongoing sequence of triggered events in a property.\"\"\"\n        self.core.startPropertySequence(self.device, self.name)\n\n    def stopSequence(self) -&gt; None:\n        \"\"\"Stop an ongoing sequence of triggered events in a property.\"\"\"\n        self.core.stopPropertySequence(self.device, self.name)\n\n    def dict(self) -&gt; InfoDict:\n        \"\"\"Return dict of info about this Property.\n\n        Returns an [`InfoDict`][pymmcore_plus.core._property.InfoDict] with the\n        following keys: `\"valid\", \"value\", \"type\", \"device_type\", \"read_only\",\n        \"pre_init\", \"range\", \"allowed\"`.\n\n        If the device is invalid or not loaded, the `\"valid\"` key will be `False`\n        and the rest of the keys will be `None`.\n        \"\"\"\n        if self.isValid():\n            return {\n                \"valid\": True,\n                \"value\": self.value,\n                \"type\": self.type().to_json(),\n                \"device_type\": self.deviceType().name,\n                \"read_only\": self.isReadOnly(),\n                \"sequenceable\": self.isSequenceable(),\n                \"sequence_max_length\": (\n                    self.sequenceMaxLength() if self.isSequenceable() else None\n                ),\n                \"pre_init\": self.isPreInit(),\n                \"range\": self.range() if self.hasLimits() else None,\n                \"allowed_values\": self.allowedValues(),\n            }\n        else:\n            return {\n                \"valid\": False,\n                \"value\": None,\n                \"type\": None,\n                \"device_type\": None,\n                \"read_only\": None,\n                \"sequenceable\": None,\n                \"sequence_max_length\": None,\n                \"pre_init\": None,\n                \"range\": None,\n                \"allowed_values\": None,\n            }\n\n    InfoDict = InfoDict\n\n    def __repr__(self) -&gt; str:\n        v = f\"value={self.value!r}\" if self.isValid() else \"INVALID\"\n        core = repr(self.core).strip(\"&lt;&gt;\")\n        return f\"&lt;Property '{self.device}::{self.name}' on {core}: {v}&gt;\"\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._property.DeviceProperty.InfoDict","title":"<code>InfoDict = InfoDict</code>  <code>class-attribute</code>","text":""},{"location":"api/device/#pymmcore_plus.core._property.DeviceProperty.device","title":"<code>device = device_label</code>  <code>instance-attribute</code>","text":""},{"location":"api/device/#pymmcore_plus.core._property.DeviceProperty.name","title":"<code>name = property_name</code>  <code>instance-attribute</code>","text":""},{"location":"api/device/#pymmcore_plus.core._property.DeviceProperty.allowedValues","title":"<code>allowedValues() -&gt; tuple[str, ...]</code>","text":"<p>Return allowed values for this property, if constrained.</p> Source code in <code>pymmcore_plus/core/_property.py</code> <pre><code>def allowedValues(self) -&gt; tuple[str, ...]:\n    \"\"\"Return allowed values for this property, if constrained.\"\"\"\n    # https://github.com/micro-manager/mmCoreAndDevices/issues/172\n    allowed = self.core.getAllowedPropertyValues(self.device, self.name)\n    if not allowed and self.deviceType() is DeviceType.StateDevice:\n        if self.name == Keyword.State:\n            n_states = self.core.getNumberOfStates(self.device)\n            allowed = tuple(str(i) for i in range(n_states))\n        elif self.name == Keyword.Label:\n            allowed = self.core.getStateLabels(self.device)\n    return allowed\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._property.DeviceProperty.core","title":"<code>core() -&gt; CMMCorePlus</code>  <code>property</code>","text":"<p>Return the <code>CMMCorePlus</code> instance to which this Property is bound.</p> Source code in <code>pymmcore_plus/core/_property.py</code> <pre><code>@property\ndef core(self) -&gt; CMMCorePlus:\n    \"\"\"Return the `CMMCorePlus` instance to which this Property is bound.\"\"\"\n    if (mmc := self._mmc_ref()) is None:  # pragma: no cover\n        raise RuntimeError(\n            \"The CMMCorePlus instance to which this Property \"\n            \"is bound has been deleted.\"\n        )\n    return mmc\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._property.DeviceProperty.deviceType","title":"<code>deviceType() -&gt; DeviceType</code>","text":"<p>Return <code>DeviceType</code> of the device owning this property.</p> Source code in <code>pymmcore_plus/core/_property.py</code> <pre><code>def deviceType(self) -&gt; DeviceType:\n    \"\"\"Return `DeviceType` of the device owning this property.\"\"\"\n    return self.core.getDeviceType(self.device)\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._property.DeviceProperty.dict","title":"<code>dict() -&gt; InfoDict</code>","text":"<p>Return dict of info about this Property.</p> <p>Returns an <code>InfoDict</code> with the following keys: <code>\"valid\", \"value\", \"type\", \"device_type\", \"read_only\", \"pre_init\", \"range\", \"allowed\"</code>.</p> <p>If the device is invalid or not loaded, the <code>\"valid\"</code> key will be <code>False</code> and the rest of the keys will be <code>None</code>.</p> Source code in <code>pymmcore_plus/core/_property.py</code> <pre><code>def dict(self) -&gt; InfoDict:\n    \"\"\"Return dict of info about this Property.\n\n    Returns an [`InfoDict`][pymmcore_plus.core._property.InfoDict] with the\n    following keys: `\"valid\", \"value\", \"type\", \"device_type\", \"read_only\",\n    \"pre_init\", \"range\", \"allowed\"`.\n\n    If the device is invalid or not loaded, the `\"valid\"` key will be `False`\n    and the rest of the keys will be `None`.\n    \"\"\"\n    if self.isValid():\n        return {\n            \"valid\": True,\n            \"value\": self.value,\n            \"type\": self.type().to_json(),\n            \"device_type\": self.deviceType().name,\n            \"read_only\": self.isReadOnly(),\n            \"sequenceable\": self.isSequenceable(),\n            \"sequence_max_length\": (\n                self.sequenceMaxLength() if self.isSequenceable() else None\n            ),\n            \"pre_init\": self.isPreInit(),\n            \"range\": self.range() if self.hasLimits() else None,\n            \"allowed_values\": self.allowedValues(),\n        }\n    else:\n        return {\n            \"valid\": False,\n            \"value\": None,\n            \"type\": None,\n            \"device_type\": None,\n            \"read_only\": None,\n            \"sequenceable\": None,\n            \"sequence_max_length\": None,\n            \"pre_init\": None,\n            \"range\": None,\n            \"allowed_values\": None,\n        }\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._property.DeviceProperty.fromCache","title":"<code>fromCache() -&gt; Any</code>","text":"<p>Return cached property value.</p> Source code in <code>pymmcore_plus/core/_property.py</code> <pre><code>def fromCache(self) -&gt; Any:\n    \"\"\"Return cached property value.\"\"\"\n    return self.core.getPropertyFromCache(self.device, self.name)\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._property.DeviceProperty.hasLimits","title":"<code>hasLimits() -&gt; bool</code>","text":"<p>Return <code>True</code> if property has limits.</p> Source code in <code>pymmcore_plus/core/_property.py</code> <pre><code>def hasLimits(self) -&gt; bool:\n    \"\"\"Return `True` if property has limits.\"\"\"\n    return self.core.hasPropertyLimits(self.device, self.name)\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._property.DeviceProperty.isLoaded","title":"<code>isLoaded() -&gt; bool</code>","text":"<p>Return true if the device name is loaded.</p> Source code in <code>pymmcore_plus/core/_property.py</code> <pre><code>def isLoaded(self) -&gt; bool:\n    \"\"\"Return true if the device name is loaded.\"\"\"\n    return self.core is not None and self.device in self.core.getLoadedDevices()\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._property.DeviceProperty.isPreInit","title":"<code>isPreInit() -&gt; bool</code>","text":"<p>Return <code>True</code> if property must be defined prior to initialization.</p> Source code in <code>pymmcore_plus/core/_property.py</code> <pre><code>def isPreInit(self) -&gt; bool:\n    \"\"\"Return `True` if property must be defined prior to initialization.\"\"\"\n    return self.core.isPropertyPreInit(self.device, self.name)\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._property.DeviceProperty.isReadOnly","title":"<code>isReadOnly() -&gt; bool</code>","text":"<p>Return <code>True</code> if property is read only.</p> Source code in <code>pymmcore_plus/core/_property.py</code> <pre><code>def isReadOnly(self) -&gt; bool:\n    \"\"\"Return `True` if property is read only.\"\"\"\n    return self.core.isPropertyReadOnly(self.device, self.name)\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._property.DeviceProperty.isSequenceable","title":"<code>isSequenceable() -&gt; bool</code>","text":"<p>Return <code>True</code> if property can be used in a sequence.</p> Source code in <code>pymmcore_plus/core/_property.py</code> <pre><code>def isSequenceable(self) -&gt; bool:\n    \"\"\"Return `True` if property can be used in a sequence.\"\"\"\n    return self.core.isPropertySequenceable(self.device, self.name)\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._property.DeviceProperty.isValid","title":"<code>isValid() -&gt; bool</code>","text":"<p>Return <code>True</code> if device is loaded and has a property by this name.</p> Source code in <code>pymmcore_plus/core/_property.py</code> <pre><code>def isValid(self) -&gt; bool:\n    \"\"\"Return `True` if device is loaded and has a property by this name.\"\"\"\n    return self.isLoaded() and self.core.hasProperty(self.device, self.name)\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._property.DeviceProperty.loadSequence","title":"<code>loadSequence(eventSequence: Sequence[str]) -&gt; None</code>","text":"<p>Transfer a sequence of events/states/whatever to the device.</p> <p>Parameters:</p> Name Type Description Default <code>eventSequence</code> <code>Sequence[str]</code> <p>The sequence of events/states that the device will execute in response to external triggers</p> required Source code in <code>pymmcore_plus/core/_property.py</code> <pre><code>def loadSequence(self, eventSequence: Sequence[str]) -&gt; None:\n    \"\"\"Transfer a sequence of events/states/whatever to the device.\n\n    Parameters\n    ----------\n    eventSequence : Sequence[str]\n        The sequence of events/states that the device will execute in response\n        to external triggers\n    \"\"\"\n    self.core.loadPropertySequence(self.device, self.name, eventSequence)\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._property.DeviceProperty.lowerLimit","title":"<code>lowerLimit() -&gt; float</code>","text":"<p>Return lower limit if property has limits, or 0 otherwise.</p> Source code in <code>pymmcore_plus/core/_property.py</code> <pre><code>def lowerLimit(self) -&gt; float:\n    \"\"\"Return lower limit if property has limits, or 0 otherwise.\"\"\"\n    return self.core.getPropertyLowerLimit(self.device, self.name)\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._property.DeviceProperty.range","title":"<code>range() -&gt; tuple[float, float]</code>","text":"<p>Return (lowerLimit, upperLimit) range tuple.</p> Source code in <code>pymmcore_plus/core/_property.py</code> <pre><code>def range(self) -&gt; tuple[float, float]:\n    \"\"\"Return (lowerLimit, upperLimit) range tuple.\"\"\"\n    return (self.lowerLimit(), self.upperLimit())\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._property.DeviceProperty.sequenceMaxLength","title":"<code>sequenceMaxLength() -&gt; int</code>","text":"<p>Return maximum number of property events that can be put in a sequence.</p> Source code in <code>pymmcore_plus/core/_property.py</code> <pre><code>def sequenceMaxLength(self) -&gt; int:\n    \"\"\"Return maximum number of property events that can be put in a sequence.\"\"\"\n    return self.core.getPropertySequenceMaxLength(self.device, self.name)\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._property.DeviceProperty.setValue","title":"<code>setValue(val: Any) -&gt; None</code>","text":"<p>Functional alternate to property setter.</p> Source code in <code>pymmcore_plus/core/_property.py</code> <pre><code>def setValue(self, val: Any) -&gt; None:\n    \"\"\"Functional alternate to property setter.\"\"\"\n    if self.isReadOnly():\n        import warnings\n\n        warnings.warn(\n            f\"'{self.device}::{self.name}' is a read-only property.\", stacklevel=2\n        )\n    try:\n        self.core.setProperty(self.device, self.name, val)\n    except RuntimeError as e:\n        msg = str(e)\n        if allowed := self.allowedValues():\n            msg += f\". Allowed values: {allowed}\"\n        raise RuntimeError(msg) from None\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._property.DeviceProperty.startSequence","title":"<code>startSequence() -&gt; None</code>","text":"<p>Start an ongoing sequence of triggered events in a property.</p> Source code in <code>pymmcore_plus/core/_property.py</code> <pre><code>def startSequence(self) -&gt; None:\n    \"\"\"Start an ongoing sequence of triggered events in a property.\"\"\"\n    self.core.startPropertySequence(self.device, self.name)\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._property.DeviceProperty.stopSequence","title":"<code>stopSequence() -&gt; None</code>","text":"<p>Stop an ongoing sequence of triggered events in a property.</p> Source code in <code>pymmcore_plus/core/_property.py</code> <pre><code>def stopSequence(self) -&gt; None:\n    \"\"\"Stop an ongoing sequence of triggered events in a property.\"\"\"\n    self.core.stopPropertySequence(self.device, self.name)\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._property.DeviceProperty.type","title":"<code>type() -&gt; PropertyType</code>","text":"<p>Return <code>PropertyType</code> of this property.</p> Source code in <code>pymmcore_plus/core/_property.py</code> <pre><code>def type(self) -&gt; PropertyType:\n    \"\"\"Return `PropertyType` of this property.\"\"\"\n    return self.core.getPropertyType(self.device, self.name)\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._property.DeviceProperty.upperLimit","title":"<code>upperLimit() -&gt; float</code>","text":"<p>Return upper limit if property has limits, or 0 otherwise.</p> Source code in <code>pymmcore_plus/core/_property.py</code> <pre><code>def upperLimit(self) -&gt; float:\n    \"\"\"Return upper limit if property has limits, or 0 otherwise.\"\"\"\n    return self.core.getPropertyUpperLimit(self.device, self.name)\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._property.DeviceProperty.value","title":"<code>value() -&gt; Any</code>  <code>writable</code> <code>property</code>","text":"<p>Return current property value, cast to appropriate type if applicable.</p> Source code in <code>pymmcore_plus/core/_property.py</code> <pre><code>@property\ndef value(self) -&gt; Any:\n    \"\"\"Return current property value, cast to appropriate type if applicable.\"\"\"\n    v = self.core.getProperty(self.device, self.name)\n    if type_ := self.type().to_python():\n        v = type_(v)\n    return v\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._property.DeviceProperty.valueChanged","title":"<code>valueChanged() -&gt; _DevicePropValueSignal</code>  <code>property</code> <code>cached</code>","text":"Source code in <code>pymmcore_plus/core/_property.py</code> <pre><code>@cached_property\ndef valueChanged(self) -&gt; _DevicePropValueSignal:\n    return _DevicePropValueSignal(self.device, self.name, self.core)\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._property.InfoDict","title":"<code>pymmcore_plus.core._property.InfoDict</code>","text":""},{"location":"api/device/#pymmcore_plus.core._property.InfoDict.allowed_values","title":"<code>allowed_values: tuple[str, ...] | None</code>  <code>class-attribute</code>","text":""},{"location":"api/device/#pymmcore_plus.core._property.InfoDict.device_type","title":"<code>device_type: str | None</code>  <code>class-attribute</code>","text":""},{"location":"api/device/#pymmcore_plus.core._property.InfoDict.pre_init","title":"<code>pre_init: bool | None</code>  <code>class-attribute</code>","text":""},{"location":"api/device/#pymmcore_plus.core._property.InfoDict.range","title":"<code>range: tuple[float, float] | None</code>  <code>class-attribute</code>","text":""},{"location":"api/device/#pymmcore_plus.core._property.InfoDict.read_only","title":"<code>read_only: bool | None</code>  <code>class-attribute</code>","text":""},{"location":"api/device/#pymmcore_plus.core._property.InfoDict.sequence_max_length","title":"<code>sequence_max_length: int | None</code>  <code>class-attribute</code>","text":""},{"location":"api/device/#pymmcore_plus.core._property.InfoDict.sequenceable","title":"<code>sequenceable: bool | None</code>  <code>class-attribute</code>","text":""},{"location":"api/device/#pymmcore_plus.core._property.InfoDict.type","title":"<code>type: str | None</code>  <code>class-attribute</code>","text":""},{"location":"api/device/#pymmcore_plus.core._property.InfoDict.valid","title":"<code>valid: bool</code>  <code>class-attribute</code>","text":""},{"location":"api/device/#pymmcore_plus.core._property.InfoDict.value","title":"<code>value: Any | None</code>  <code>class-attribute</code>","text":""},{"location":"api/events/","title":"Events","text":"<p>There are two objects that emit events in <code>pymmcore-plus</code>:</p> <ol> <li>The <code>CMMCorePlus</code> object emits events at <code>CMMCorePlus.events</code> when the state    of the microscope changes.</li> <li>The <code>MDARunner</code> object emits events at <code>CMMCorePlus.mda.events</code> as an    acquisition sequence progresses.</li> </ol> <p>The events emitted by these two objects are defined by the following protocols:</p>"},{"location":"api/events/#pymmcore_plus.core.events.PCoreSignaler","title":"<code>pymmcore_plus.core.events.PCoreSignaler</code>","text":"<p>Declares the protocol for all signals that will be emitted from CMMCorePlus.</p> <p>The main instance of this interface is available on the <code>CMMCorePlus</code> object at the <code>events</code> attribute. Each signal on <code>events</code> is an object has a <code>connect</code> and a <code>disconnect</code> method that you can use to connect/disconnect your own callback functions.  <code>connect</code> and <code>disconnect</code> accept a single argument, which is a callable that will be called when the signal is emitted. The callable should accept no more positional arguments than the signal emits (noted for each signal below), but may accept fewer.</p> <p>Note</p> <p>These events are a superset of those emitted by MMEventCallback in the MMCore C++ library.  The \"on\" prefix has been removed from the names here and the first letter lower cased.</p> <p>Important</p> <p>In the core C++ library (and in <code>pymmcore</code>), the emission of many of these events is left to the discretion of the device adapter.  In <code>pymmcore_plus</code>, we attempt to emit these events in a more consistent manner (e.g. by checking a particular value before and after calling into the C++ library).  So, the emission of these events is not guaranteed to be 1:1 with the C++ library; however, it should be easier to follow the state of the core when using <code>pymmcore_plus.CMMCorePlus</code>.</p> <p>Examples:</p> <p>To connect to the <code>onExposureChanged</code> event emitted by MMCore, you would connect to the <code>exposureChanged</code> signal on this class:</p> <pre><code>from pymmcore_plus import CMMCorePlus\n\ncore = CMMCorePlus()\n\n\ndef on_exposure_changed(device: str, new_exposure: float):\n    print(f\"Exposure changed for {device} to {new_exposure}\")\n\n\ncore.events.exposureChanged.connect(my_callback)\n</code></pre> <p>Events may also be connected as a decorator:</p> <pre><code>@core.events.exposureChanged.connect\ndef on_exposure_changed(device: str, new_exposure: float): ...\n</code></pre>"},{"location":"api/events/#pymmcore_plus.core.events._protocol.PCoreSignaler.SLMExposureChanged","title":"<code>SLMExposureChanged: ClassVar[PSignal]</code>  <code>class-attribute</code>","text":"<p>Emits <code>(name: str, newExposure: float)</code> when the exposure of the SLM device changes.</p>"},{"location":"api/events/#pymmcore_plus.core.events._protocol.PCoreSignaler.XYStagePositionChanged","title":"<code>XYStagePositionChanged: ClassVar[PSignal]</code>  <code>class-attribute</code>","text":"<p>Emits <code>(name: str, xpos: float, ypos: float)</code> when an XY stage position has changed.</p>"},{"location":"api/events/#pymmcore_plus.core.events._protocol.PCoreSignaler.autoShutterSet","title":"<code>autoShutterSet: ClassVar[PSignal]</code>  <code>class-attribute</code>","text":"<p>Emits <code>(bool)</code> when the auto shutter setting is changed.</p>"},{"location":"api/events/#pymmcore_plus.core.events._protocol.PCoreSignaler.channelGroupChanged","title":"<code>channelGroupChanged: ClassVar[PSignal]</code>  <code>class-attribute</code>","text":"<p>Emits <code>(newChannelGroupName: str)</code> when a channel group has changed.</p>"},{"location":"api/events/#pymmcore_plus.core.events._protocol.PCoreSignaler.configDefined","title":"<code>configDefined: ClassVar[PSignal]</code>  <code>class-attribute</code>","text":"<p>Emits <code>(str, str, str, str, str)</code> when a config is defined.</p> <p> This signal is unique to <code>pymmcore-plus</code>.</p>"},{"location":"api/events/#pymmcore_plus.core.events._protocol.PCoreSignaler.configDeleted","title":"<code>configDeleted: ClassVar[PSignal]</code>  <code>class-attribute</code>","text":"<p>Emits <code>(str, str)</code> when a config is deleted.</p> <p> This signal is unique to <code>pymmcore-plus</code>.</p>"},{"location":"api/events/#pymmcore_plus.core.events._protocol.PCoreSignaler.configGroupChanged","title":"<code>configGroupChanged: ClassVar[PSignal]</code>  <code>class-attribute</code>","text":"<p>Emits <code>(groupName: str, newConfigName: str)</code> when a config group has changed.</p>"},{"location":"api/events/#pymmcore_plus.core.events._protocol.PCoreSignaler.configGroupDeleted","title":"<code>configGroupDeleted: ClassVar[PSignal]</code>  <code>class-attribute</code>","text":"<p>Emits <code>(str)</code> when a config group is deleted.</p> <p> This signal is unique to <code>pymmcore-plus</code>.</p>"},{"location":"api/events/#pymmcore_plus.core.events._protocol.PCoreSignaler.configSet","title":"<code>configSet: ClassVar[PSignal]</code>  <code>class-attribute</code>","text":"<p>Emits <code>(str, str)</code> when a config has been set.</p> <p> This signal is unique to <code>pymmcore-plus</code>.</p>"},{"location":"api/events/#pymmcore_plus.core.events._protocol.PCoreSignaler.continuousSequenceAcquisitionStarted","title":"<code>continuousSequenceAcquisitionStarted: ClassVar[PSignal]</code>  <code>class-attribute</code>","text":"<p>Emits with no arguments after continuous sequence acquisition has started.</p> <p> This signal is unique to <code>pymmcore-plus</code>.</p>"},{"location":"api/events/#pymmcore_plus.core.events._protocol.PCoreSignaler.continuousSequenceAcquisitionStarting","title":"<code>continuousSequenceAcquisitionStarting: ClassVar[PSignal]</code>  <code>class-attribute</code>","text":"<p>Emits with no arguments before continuous sequence acquisition is started.</p> <p> This signal is unique to <code>pymmcore-plus</code>.</p>"},{"location":"api/events/#pymmcore_plus.core.events._protocol.PCoreSignaler.exposureChanged","title":"<code>exposureChanged: ClassVar[PSignal]</code>  <code>class-attribute</code>","text":"<p>Emits <code>(name: str, newExposure: float)</code> when an exposure has changed.</p>"},{"location":"api/events/#pymmcore_plus.core.events._protocol.PCoreSignaler.imageSnapped","title":"<code>imageSnapped: ClassVar[PSignal]</code>  <code>class-attribute</code>","text":"<p>Emits with no arguments whenever snap is called.</p> <p> This signal is unique to <code>pymmcore-plus</code>.</p>"},{"location":"api/events/#pymmcore_plus.core.events._protocol.PCoreSignaler.mdaEngineRegistered","title":"<code>mdaEngineRegistered: ClassVar[PSignal]</code>  <code>class-attribute</code>","text":"<p>Emits <code>(MDAEngine, MDAEngine)</code> when an MDAEngine is registered.</p> <p> This signal is unique to <code>pymmcore-plus</code>.</p>"},{"location":"api/events/#pymmcore_plus.core.events._protocol.PCoreSignaler.pixelSizeAffineChanged","title":"<code>pixelSizeAffineChanged: ClassVar[PSignal]</code>  <code>class-attribute</code>","text":"<p>Emits <code>(float, float, float, float, float, float)</code> when the pixel size affine has changed.</p>"},{"location":"api/events/#pymmcore_plus.core.events._protocol.PCoreSignaler.pixelSizeChanged","title":"<code>pixelSizeChanged: ClassVar[PSignal]</code>  <code>class-attribute</code>","text":"<p>Emits <code>(newPixelSizeUm: float)</code> when the pixel size has changed.</p>"},{"location":"api/events/#pymmcore_plus.core.events._protocol.PCoreSignaler.propertiesChanged","title":"<code>propertiesChanged: ClassVar[PSignal]</code>  <code>class-attribute</code>","text":"<p>Emits with no arguments when properties have changed.</p>"},{"location":"api/events/#pymmcore_plus.core.events._protocol.PCoreSignaler.propertyChanged","title":"<code>propertyChanged: ClassVar[PSignal]</code>  <code>class-attribute</code>","text":"<p>Emits <code>(name: str, propName: str, propValue: str)</code> when a specific property has changed.</p>"},{"location":"api/events/#pymmcore_plus.core.events._protocol.PCoreSignaler.roiSet","title":"<code>roiSet: ClassVar[PSignal]</code>  <code>class-attribute</code>","text":"<p>Emits <code>(str, int, int, int, int)</code> when an ROI is set.</p> <p> This signal is unique to <code>pymmcore-plus</code>.</p>"},{"location":"api/events/#pymmcore_plus.core.events._protocol.PCoreSignaler.sequenceAcquisitionStarted","title":"<code>sequenceAcquisitionStarted: ClassVar[PSignal]</code>  <code>class-attribute</code>","text":"<p>Emits <code>(str)</code> after sequence acquisition has started.</p> <p>Breaking Change</p> <p>In <code>pymmcore-plus</code> version 0.16.0, the <code>sequenceAcquisitionStarted</code> signal was reduced from <code>(str, int, float, bool)</code> to <code>(str,)</code> to match the signature emitted by the C++ MMCore library.</p> <p>(cameraLabel,)</p> <p> This signal is unique to <code>pymmcore-plus</code>.</p>"},{"location":"api/events/#pymmcore_plus.core.events._protocol.PCoreSignaler.sequenceAcquisitionStarting","title":"<code>sequenceAcquisitionStarting: ClassVar[PSignal]</code>  <code>class-attribute</code>","text":"<p>Emits <code>(str,)</code> before sequence acquisition is started.</p> <p>Breaking Change</p> <p>In <code>pymmcore-plus</code> version 0.16.0, the <code>sequenceAcquisitionStarting</code> signal was reduced from <code>(str, int, float, bool)</code> to <code>(str,)</code> to match the signature emitted by the C++ MMCore library.</p> <p><code>(cameraLabel,)</code></p> <p> This signal is unique to <code>pymmcore-plus</code>.</p>"},{"location":"api/events/#pymmcore_plus.core.events._protocol.PCoreSignaler.sequenceAcquisitionStopped","title":"<code>sequenceAcquisitionStopped: ClassVar[PSignal]</code>  <code>class-attribute</code>","text":"<p>Emits <code>(str)</code> when sequence acquisition is stopped.</p> <p> This signal is unique to <code>pymmcore-plus</code>.</p>"},{"location":"api/events/#pymmcore_plus.core.events._protocol.PCoreSignaler.shutterOpenChanged","title":"<code>shutterOpenChanged: ClassVar[PSignal]</code>  <code>class-attribute</code>","text":"<p>Emits <code>(name: str, isOpen: bool)</code> when the shutter open state has changed.</p>"},{"location":"api/events/#pymmcore_plus.core.events._protocol.PCoreSignaler.stagePositionChanged","title":"<code>stagePositionChanged: ClassVar[PSignal]</code>  <code>class-attribute</code>","text":"<p>Emits <code>(name: str, pos: float)</code> when a stage position has changed.</p>"},{"location":"api/events/#pymmcore_plus.core.events._protocol.PCoreSignaler.systemConfigurationLoaded","title":"<code>systemConfigurationLoaded: ClassVar[PSignal]</code>  <code>class-attribute</code>","text":"<p>Emits with no arguments when the system configuration has been loaded.</p>"},{"location":"api/events/#pymmcore_plus.core.events._protocol.PCoreSignaler.devicePropertyChanged","title":"<code>devicePropertyChanged(device: str, property: str | None = None) -&gt; PSignalInstance</code>","text":"<p>Return object to connect/disconnect to device/property-specific changes.</p> <p>Note that the callback provided to <code>.connect()</code> must take two parameters (property_name, new_value) if only <code>device</code> is provided, and one parameter (new_value) of both <code>device</code> and <code>property</code> are provided.</p> <p>Parameters:</p> Name Type Description Default <code>device</code> <code>str</code> <p>A device label</p> required <code>property</code> <code>Optional[str]</code> <p>Optional property label.  If not provided, all property changes on <code>device</code> will trigger an event emission. by default None</p> <code>None</code> <p>Returns:</p> Type Description <code>_PropertySignal</code> <p>Object with <code>connect</code> and <code>disconnect</code> methods that attach a callback to the change event of a specific property or device.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; core.events.devicePropertyChanged(\"Camera\", \"Gain\").connect(callback)\n&gt;&gt;&gt; core.events.devicePropertyChanged(\"Camera\").connect(callback)\n</code></pre>"},{"location":"api/events/#pymmcore_plus.mda.events.PMDASignaler","title":"<code>pymmcore_plus.mda.events.PMDASignaler</code>","text":"<p>Declares the protocol for all signals that will be emitted from <code>pymmcore_plus.mda.MDARunner</code>.</p>"},{"location":"api/events/#pymmcore_plus.mda.events._protocol.PMDASignaler.awaitingEvent","title":"<code>awaitingEvent: ClassVar[PSignal]</code>  <code>class-attribute</code>","text":"<p>Emits <code>(event: MDAEvent, remaining_sec: float)</code> when the runner is waiting to start an event.</p> <p>Note: Not all events in a sequence will emit this signal. This will only be emitted if the wait time is non-zero.</p>"},{"location":"api/events/#pymmcore_plus.mda.events._protocol.PMDASignaler.eventStarted","title":"<code>eventStarted: ClassVar[PSignal]</code>  <code>class-attribute</code>","text":"<p>Emits <code>(event: MDAEvent)</code> immediately before event setup and execution.</p>"},{"location":"api/events/#pymmcore_plus.mda.events._protocol.PMDASignaler.frameReady","title":"<code>frameReady: ClassVar[PSignal]</code>  <code>class-attribute</code>","text":"<p>Emits <code>(img: np.ndarray, event: MDAEvent, metadata: dict)</code> after an image is acquired during an acquisition sequence.</p> <p>For the default <code>MDAEngine</code>, the metadata <code>dict</code> will be of type <code>FrameMetaV1</code>.</p>"},{"location":"api/events/#pymmcore_plus.mda.events._protocol.PMDASignaler.sequenceCanceled","title":"<code>sequenceCanceled: ClassVar[PSignal]</code>  <code>class-attribute</code>","text":"<p>Emits <code>(sequence: MDASequence)</code> when an acquisition sequence is canceled.</p>"},{"location":"api/events/#pymmcore_plus.mda.events._protocol.PMDASignaler.sequenceFinished","title":"<code>sequenceFinished: ClassVar[PSignal]</code>  <code>class-attribute</code>","text":"<p>Emits <code>(sequence: MDASequence)</code> when an acquisition sequence is finished.</p>"},{"location":"api/events/#pymmcore_plus.mda.events._protocol.PMDASignaler.sequencePauseToggled","title":"<code>sequencePauseToggled: ClassVar[PSignal]</code>  <code>class-attribute</code>","text":"<p>Emits <code>(paused: bool)</code> when an acquisition sequence is paused or unpaused.</p>"},{"location":"api/events/#pymmcore_plus.mda.events._protocol.PMDASignaler.sequenceStarted","title":"<code>sequenceStarted: ClassVar[PSignal]</code>  <code>class-attribute</code>","text":"<p>Emits <code>(sequence: MDASequence, metadata: dict)</code> when an acquisition sequence is started.</p> <p>For the default <code>MDAEngine</code>, the metadata <code>dict</code> will be of type <code>SummaryMetaV1</code>.</p>"},{"location":"api/mda/","title":"Multi-Dimensional Acquisition","text":"<p>The <code>mda</code> attribute on the <code>CMMCorePlus</code> object provides a high-level interface for running multi-dimensional microscopy experiments.</p>"},{"location":"api/mda/#pymmcore_plus.mda.MDARunner","title":"<code>pymmcore_plus.mda.MDARunner</code>","text":"<p>Object that executes a multi-dimensional experiment using an MDAEngine.</p> <p>This object is available at <code>CMMCorePlus.mda</code>.</p> <p>This is the main object that runs a multi-dimensional experiment; it does so by driving an acquisition engine that implements the <code>PMDAEngine</code> protocol.  It emits signals at specific times during the experiment (see <code>PMDASignaler</code> for details on the signals that are available to connect to and when they are emitted).</p> <p>The state machine modeled by this runner is as follows:</p> <pre><code>stateDiagram-v2\n    [*] --&gt; IDLE\n    IDLE --&gt; PREPARING : run()\n    PREPARING --&gt; running : sequence ready\n    state running {\n        WAITING --&gt; ACQUIRING : next event ready\n        ACQUIRING --&gt; WAITING : event done\n        WAITING --&gt; PAUSED : &lt;code&gt;set_paused(True)&lt;/code&gt;\n        PAUSED --&gt; WAITING : &lt;code&gt;set_paused(False)&lt;/code&gt;\n        ACQUIRING --&gt; PAUSED : &lt;code&gt;set_paused(True)&lt;/code&gt;&lt;/br&gt;(after event done)\n    }\n    running --&gt; FINISHING : &lt;code&gt;cancel()&lt;/code&gt;\n    running --&gt; FINISHING : all events exhausted\n    FINISHING --&gt; IDLE : cleanup done</code></pre> <p>You can query the current state of the runner using the <code>status</code> property, which returns a snapshot of the runner's current state, including the current phase of the acquisition, whether a cancel or pause has been requested, and the reason for finishing (once the acquisition is finished).</p> Source code in <code>pymmcore_plus/mda/_runner.py</code> <pre><code>class MDARunner:\n    \"\"\"Object that executes a multi-dimensional experiment using an MDAEngine.\n\n    This object is available at [`CMMCorePlus.mda`][pymmcore_plus.CMMCorePlus.mda].\n\n    This is the main object that runs a multi-dimensional experiment; it does so by\n    driving an acquisition engine that implements the\n    [`PMDAEngine`][pymmcore_plus.mda.PMDAEngine] protocol.  It emits signals at specific\n    times during the experiment (see\n    [`PMDASignaler`][pymmcore_plus.mda.events.PMDASignaler] for details on the signals\n    that are available to connect to and when they are emitted).\n\n    The state machine modeled by this runner is as follows:\n\n    ```mermaid\n    stateDiagram-v2\n        [*] --&gt; IDLE\n        IDLE --&gt; PREPARING : run()\n        PREPARING --&gt; running : sequence ready\n        state running {\n            WAITING --&gt; ACQUIRING : next event ready\n            ACQUIRING --&gt; WAITING : event done\n            WAITING --&gt; PAUSED : &lt;code&gt;set_paused(True)&lt;/code&gt;\n            PAUSED --&gt; WAITING : &lt;code&gt;set_paused(False)&lt;/code&gt;\n            ACQUIRING --&gt; PAUSED : &lt;code&gt;set_paused(True)&lt;/code&gt;&lt;/br&gt;(after event done)\n        }\n        running --&gt; FINISHING : &lt;code&gt;cancel()&lt;/code&gt;\n        running --&gt; FINISHING : all events exhausted\n        FINISHING --&gt; IDLE : cleanup done\n    ```\n\n    You can query the current state of the runner using the\n    [`status`][pymmcore_plus.mda.MDARunner.status] property, which returns a snapshot\n    of the runner's current state, including the current phase of the acquisition,\n    whether a cancel or pause has been requested, and the reason for finishing\n    (once the acquisition is finished).\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        self._engine: PMDAEngine | None = None\n        self._signals = _get_auto_MDA_callback_class()()\n        self._lock = threading.Lock()\n        self._state: RunState = RunState.IDLE\n        self._finish_reason: FinishReason | None = None\n        self._cancel_requested: bool = False\n        self._pause_requested: bool = False\n        self._paused_time: float = 0\n        self._pause_interval: float = 0.1  # sec to wait between checking pause state\n        self._handlers: WeakSet[SupportsFrameReady] = WeakSet()\n        self._sequence: MDASequence | None = None\n        # timer for the full sequence, reset only once at the beginning of the sequence\n        self._sequence_t0: float = 0.0\n        # event clock, reset whenever `event.reset_event_timer` is True\n        self._t0: float = 0.0\n\n    def set_engine(self, engine: PMDAEngine) -&gt; PMDAEngine | None:\n        \"\"\"Set the [`PMDAEngine`][pymmcore_plus.mda.PMDAEngine] to use for the MDA run.\"\"\"  # noqa: E501\n        # MagicMock on py312 no longer satisfies isinstance ... so we explicitly\n        # allow it here just for the sake of testing.\n        if not isinstance(engine, (PMDAEngine, MagicMock)):\n            raise TypeError(\"Engine does not conform to the Engine protocol.\")\n\n        if self.is_running():  # pragma: no cover\n            raise RuntimeError(\n                \"Cannot register a new engine when the current engine is running \"\n                \"an acquisition. Please cancel the current engine's acquisition \"\n                \"before registering\"\n            )\n\n        old_engine, self._engine = self._engine, engine\n        return old_engine\n\n    # NOTE:\n    # this return annotation is a lie, since the user can set it to their own engine.\n    # but in MOST cases, this is the engine that will be used by default, so it's\n    # convenient for IDEs to point to this rather than the abstract protocol.\n    @property\n    def engine(self) -&gt; MDAEngine | None:\n        \"\"\"The [`PMDAEngine`][pymmcore_plus.mda.PMDAEngine] that is currently being used.\"\"\"  # noqa: E501\n        return self._engine  # type: ignore\n\n    @property\n    def events(self) -&gt; PMDASignaler:\n        \"\"\"Signals that are emitted during the MDA run.\n\n        See [`PMDASignaler`][pymmcore_plus.mda.PMDASignaler] for details on the\n        signals that are available to connect to.\n        \"\"\"\n        return self._signals\n\n    @property\n    def status(self) -&gt; RunnerStatus:\n        \"\"\"Snapshot of the runner's current status.\"\"\"\n        with self._lock:\n            return RunnerStatus(\n                phase=self._state,\n                finish_reason=self._finish_reason,\n                cancel_requested=self._cancel_requested,\n                pause_requested=self._pause_requested,\n            )\n\n    def is_running(self) -&gt; bool:\n        \"\"\"Return True if an acquisition is currently underway.\n\n        This will return True at any point between the emission of the\n        [`sequenceStarted`][pymmcore_plus.mda.PMDASignaler.sequenceStarted] and\n        [`sequenceFinished`][pymmcore_plus.mda.PMDASignaler.sequenceFinished] signals,\n        including when the acquisition is currently paused.\n\n        Returns\n        -------\n        bool\n            Whether an acquisition is underway.\n        \"\"\"\n        return self._state not in (RunState.IDLE, RunState.FINISHING)\n\n    def is_paused(self) -&gt; bool:\n        \"\"\"Return True if the acquisition is currently paused.\n\n        Use `set_paused` to change the paused state.\n\n        Returns\n        -------\n        bool\n            Whether the current acquisition is paused.\n        \"\"\"\n        return self._state == RunState.PAUSED\n\n    def cancel(self) -&gt; None:\n        \"\"\"Cancel the currently running acquisition.\n\n        This is a no-op if no acquisition is currently running.\n        If an acquisition is running then this will cancel the acquisition and\n        a sequenceCanceled signal, followed by a sequenceFinished signal will\n        be emitted.\n        \"\"\"\n        with self._lock:\n            if self._state in (RunState.IDLE, RunState.FINISHING):\n                return\n            self._paused_time = 0\n            if self._state == RunState.ACQUIRING:\n                # defer to event boundary\n                self._cancel_requested = True\n            else:\n                # WAITING, PREPARING, or PAUSED \u2192 immediate transition\n                self._finish_reason = FinishReason.CANCELED\n                self._state = RunState.FINISHING\n\n    @deprecated(\"Use `set_paused(paused)` instead.\", category=DeprecationWarning)\n    def toggle_pause(self) -&gt; None:\n        \"\"\"Toggle the paused state of the current acquisition.\n\n        !!!warning \"Deprecated\"\n            Use [`set_paused`][pymmcore_plus.mda.MDARunner.set_paused] instead.\n        \"\"\"\n        self.set_paused(not (self.is_paused() or self._pause_requested))\n\n    def set_paused(self, paused: bool) -&gt; None:\n        \"\"\"Set the paused state of the current acquisition.\n\n        This is a no-op if the acquisition is already in the requested state,\n        or if no acquisition is currently underway.\n\n        Parameters\n        ----------\n        paused : bool\n            Whether to pause (True) or unpause (False) the acquisition.\n        \"\"\"\n        with self._lock:\n            if self._state == RunState.WAITING:\n                if not paused:\n                    return\n                self._state = RunState.PAUSED\n            elif self._state == RunState.PAUSED:\n                if paused:\n                    return\n                self._state = RunState.WAITING\n            elif self._state == RunState.ACQUIRING:\n                if self._pause_requested == paused:\n                    return\n                self._pause_requested = paused\n            else:\n                return\n        self._signals.sequencePauseToggled.emit(paused)\n\n    def run(\n        self,\n        events: Iterable[MDAEvent],\n        *,\n        output: SingleOutput | Sequence[SingleOutput] | None = None,\n    ) -&gt; None:\n        \"\"\"Run the multi-dimensional acquisition defined by `sequence`.\n\n        Most users should not use this directly as it will block further\n        execution. Instead, use the\n        [`CMMCorePlus.run_mda`][pymmcore_plus.CMMCorePlus.run_mda] method which will\n        run on a thread.\n\n        Parameters\n        ----------\n        events : Iterable[MDAEvent]\n            An iterable of `useq.MDAEvents` objects to execute.\n        output : SingleOutput | Sequence[SingleOutput] | None, optional\n            The output handler(s) to use.  If None, no output will be saved.\n            The value may be either a single output or a sequence of outputs,\n            where a \"single output\" can be any of the following:\n\n            - A string or Path to a directory to save images to. A handler will be\n                created automatically based on the extension of the path.\n                - `.zarr` files will be handled by `OMEZarrWriter`\n                - `.ome.tiff` files will be handled by `OMETiffWriter`\n                - A directory with no extension will be handled by `ImageSequenceWriter`\n            - A handler object that implements the `DataHandler` protocol, currently\n                meaning it has a `frameReady` method.  See `mda_listeners_connected`\n                for more details.\n\n            During the course of the sequence, the `get_output_handlers` method can be\n            used to get the currently connected output handlers (including those that\n            were created automatically based on file paths).\n        \"\"\"\n        error = None\n        sequence = events if isinstance(events, MDASequence) else GeneratorMDASequence()\n        with self._outputs_connected(output):\n            # NOTE: it's important that `_prepare_to_run` and `_finish_run` are\n            # called inside the context manager, since the `mda_listeners_connected`\n            # context manager expects to see both of those signals.\n            try:\n                engine = self._prepare_to_run(sequence)\n                self._run(engine, events)\n            except Exception as e:\n                error = e\n                with self._lock:\n                    if self._finish_reason is None:\n                        self._finish_reason = FinishReason.ERRORED\n            with exceptions_logged():\n                self._finish_run(sequence)\n        if error is not None:\n            raise error\n\n    def get_output_handlers(self) -&gt; tuple[SupportsFrameReady, ...]:\n        \"\"\"Return the data handlers that are currently connected.\n\n        Output handlers are connected by passing them to the `output` parameter of the\n        `run` method; the run method accepts objects with a `frameReady` method *or*\n        strings representing paths.  If a string is passed, a handler will be created\n        internally.\n\n        This method returns a tuple of currently connected handlers, including those\n        that were explicitly passed to `run()`, as well as those that were created based\n        on file paths.  Internally, handlers are held by weak references, so if you want\n        the handler to persist, you must keep a reference to it.  The only guaranteed\n        API that the handler will have is the `frameReady` method, but it could be any\n        user-defined object that implements that method.\n\n        Handlers are cleared each time `run()` is called, (but not at the end\n        of the sequence).\n\n        Returns\n        -------\n        tuple[SupportsFrameReady, ...]\n            Tuple of objects that (minimally) support the `frameReady` method.\n        \"\"\"\n        return tuple(self._handlers)\n\n    def seconds_elapsed(self) -&gt; float:\n        \"\"\"Return the number of seconds since the start of the acquisition.\"\"\"\n        return time.perf_counter() - self._sequence_t0\n\n    def event_seconds_elapsed(self) -&gt; float:\n        \"\"\"Return the number of seconds on the \"event clock\".\n\n        This is the time since either the start of the acquisition or the last\n        event with `reset_event_timer` set to `True`.\n        \"\"\"\n        return time.perf_counter() - self._t0\n\n    def _outputs_connected(\n        self, output: SingleOutput | Sequence[SingleOutput] | None\n    ) -&gt; AbstractContextManager:\n        \"\"\"Context in which output handlers are connected to the frameReady signal.\"\"\"\n        if output is None:\n            return nullcontext()\n\n        if isinstance(output, (str, Path)) or not isinstance(output, Sequence):\n            output = [output]\n\n        # convert all items to handler objects, preserving order\n        _handlers: list[SupportsFrameReady] = []\n        for item in output:\n            if isinstance(item, (str, Path)):\n                _handlers.append(self._handler_for_path(item))\n            else:\n                if not callable(getattr(item, \"frameReady\", None)):\n                    raise TypeError(\n                        \"Output handlers must have a callable frameReady method. \"\n                        f\"Got {item} with type {type(item)}.\"\n                    )\n                _handlers.append(item)\n\n        self._handlers.clear()\n        self._handlers.update(_handlers)\n        return mda_listeners_connected(*_handlers, mda_events=self._signals)\n\n    def _handler_for_path(self, path: str | Path) -&gt; SupportsFrameReady:\n        \"\"\"Convert a string or Path into a handler object.\n\n        This method picks from the built-in handlers based on the extension of the path.\n        \"\"\"\n        from pymmcore_plus.mda.handlers import handler_for_path\n\n        return cast(\"SupportsFrameReady\", handler_for_path(path))\n\n    def _run(self, engine: PMDAEngine, events: Iterable[MDAEvent]) -&gt; None:\n        \"\"\"Main execution of events, inside the try/except block of `run`.\"\"\"\n        teardown_event = getattr(engine, \"teardown_event\", lambda e: None)\n        if isinstance(events, Iterator):\n            # if an iterator is passed directly, then we use that iterator\n            # instead of the engine's event_iterator.  Directly passing an iterator\n            # is an advanced use case, (for example, `iter(Queue(), None)` for event-\n            # driven acquisition) and we don't want the engine to interfere with it.\n            event_iterator = iter\n        else:\n            event_iterator = getattr(engine, \"event_iterator\", iter)\n        _events: Iterator[MDAEvent] = event_iterator(events)\n        self._reset_event_timer()\n        self._sequence_t0 = self._t0\n\n        for event in _events:\n            if event.reset_event_timer:\n                self._reset_event_timer()\n\n            if self._wait_until_event(event):\n                break\n\n            with self._lock:\n                self._state = RunState.ACQUIRING\n            self._signals.eventStarted.emit(event)\n            logger.info(\"%s\", event)\n            engine.setup_event(event)\n\n            try:\n                runner_time_ms = self.seconds_elapsed() * 1000\n                # this is a bit of a hack to pass the time into the engine\n                # it is used for intra-event time calculations inside the engine.\n                # we pop it off after the event is executed.\n                event.metadata[\"runner_t0\"] = self._sequence_t0\n                output = engine.exec_event(event) or ()  # in case output is None\n                for payload in self._iter_exec_output(output):\n                    img, _event, meta = payload\n                    _event.metadata.pop(\"runner_t0\", None)\n                    # if the engine calculated its own time, don't overwrite it\n                    if \"runner_time_ms\" not in meta:\n                        meta[\"runner_time_ms\"] = runner_time_ms\n                    with exceptions_logged():\n                        self._signals.frameReady.emit(img, _event, meta)\n            finally:\n                teardown_event(event)\n\n            # event boundary: resolve deferred flags\n            with self._lock:\n                if self._cancel_requested:\n                    self._cancel_requested = False\n                    self._finish_reason = FinishReason.CANCELED\n                    self._state = RunState.FINISHING\n                    break\n\n                if self._pause_requested:\n                    self._pause_requested = False\n                    self._state = RunState.PAUSED\n                    # signal was already emitted in set_paused()\n\n                if self._state != RunState.PAUSED:\n                    self._state = RunState.WAITING\n        else:\n            with self._lock:\n                self._finish_reason = FinishReason.COMPLETED\n\n    def _iter_exec_output(self, iterable: Iterable) -&gt; Iterator:\n        \"\"\"Iterate over exec_event output, sending cancel/pause signals to generators.\n\n        This allows the runner to communicate with generator-based engines\n        (like exec_sequenced_event) without the engine needing to know about\n        runner internals. Signals are sent via generator.send().\n\n        Works with any iterable - if it's not a generator or doesn't handle\n        signals, they're simply ignored.\n        \"\"\"\n        gen = iter(iterable)\n        is_generator = isinstance(gen, types.GeneratorType)\n\n        try:\n            item = next(gen)\n            while True:\n                yield item\n                if is_generator:\n                    signal = None\n                    if self._cancel_requested or self._state == RunState.FINISHING:\n                        signal = \"cancel\"\n                    elif self._pause_requested:\n                        signal = \"pause\"\n                    item = gen.send(signal)  # type: ignore[attr-defined]\n                else:\n                    item = next(gen)\n        except StopIteration:\n            pass\n\n    def _prepare_to_run(self, sequence: MDASequence) -&gt; PMDAEngine:\n        \"\"\"Set up for the MDA run.\n\n        Parameters\n        ----------\n        sequence : MDASequence\n            The sequence of events to run.\n        \"\"\"\n        if not self._engine:  # pragma: no cover\n            raise RuntimeError(\"No MDAEngine set.\")\n\n        with self._lock:\n            self._state = RunState.PREPARING\n            self._finish_reason = None\n            self._cancel_requested = False\n            self._pause_requested = False\n        self._paused_time = 0.0\n        self._sequence = sequence\n\n        meta = self._engine.setup_sequence(sequence)\n        with self._lock:\n            if self._state != RunState.FINISHING:\n                self._state = RunState.WAITING\n        self._signals.sequenceStarted.emit(sequence, meta or {})\n        logger.info(\"MDA Started: %s\", sequence)\n        return self._engine\n\n    def _reset_event_timer(self) -&gt; None:\n        self._t0 = time.perf_counter()  # reference time, in seconds\n\n    def _wait_until_event(self, event: MDAEvent) -&gt; bool:\n        \"\"\"Wait until the event's min start time, checking for pauses/cancellations.\n\n        Parameters\n        ----------\n        event : MDAEvent\n            The event to wait for.\n\n        Returns\n        -------\n        bool\n            Whether the MDA was cancelled while waiting.\n        \"\"\"\n        # NOTE: mypy narrows self._state after each check, but cancel() and\n        # set_paused() mutate it from other threads, so all checks are reachable.\n        if self._state == RunState.FINISHING:\n            return True\n\n        # pause loop (for deferred pause from ACQUIRING boundary)\n        while self._state == RunState.PAUSED:\n            self._paused_time += self._pause_interval\n            time.sleep(self._pause_interval)\n        if self._state == RunState.FINISHING:  # type: ignore[comparison-overlap]\n            return True\n\n        if event.min_start_time:\n            go_at = event.min_start_time + self._paused_time\n            remaining = go_at - self.event_seconds_elapsed()\n            while remaining &gt; 0:\n                self._signals.awaitingEvent.emit(event, remaining)\n                while self._state == RunState.PAUSED:  # type: ignore[comparison-overlap]\n                    self._paused_time += self._pause_interval\n                    remaining += self._pause_interval\n                    time.sleep(self._pause_interval)\n                if self._state == RunState.FINISHING:  # type: ignore[comparison-overlap]\n                    return True\n                time.sleep(min(remaining, 0.5))\n                remaining = go_at - self.event_seconds_elapsed()\n\n        return self._state == RunState.FINISHING  # type: ignore[comparison-overlap]\n\n    def _finish_run(self, sequence: MDASequence) -&gt; None:\n        \"\"\"To be called at the end of an acquisition.\n\n        Parameters\n        ----------\n        sequence : MDASequence\n            The sequence that was finished.\n        \"\"\"\n        with self._lock:\n            self._state = RunState.FINISHING\n            if self._finish_reason is None:\n                self._finish_reason = FinishReason.COMPLETED\n            finish_reason = self._finish_reason\n\n        if hasattr(self._engine, \"teardown_sequence\"):\n            self._engine.teardown_sequence(sequence)  # type: ignore\n\n        if finish_reason == FinishReason.CANCELED:\n            logger.warning(\"MDA Canceled: %s\", sequence)\n            self._signals.sequenceCanceled.emit(sequence)\n\n        logger.info(\"MDA Finished: %s\", sequence)\n        self._signals.sequenceFinished.emit(sequence)\n        with self._lock:\n            self._state = RunState.IDLE\n</code></pre>"},{"location":"api/mda/#pymmcore_plus.mda._runner.MDARunner.cancel","title":"<code>cancel() -&gt; None</code>","text":"<p>Cancel the currently running acquisition.</p> <p>This is a no-op if no acquisition is currently running. If an acquisition is running then this will cancel the acquisition and a sequenceCanceled signal, followed by a sequenceFinished signal will be emitted.</p> Source code in <code>pymmcore_plus/mda/_runner.py</code> <pre><code>def cancel(self) -&gt; None:\n    \"\"\"Cancel the currently running acquisition.\n\n    This is a no-op if no acquisition is currently running.\n    If an acquisition is running then this will cancel the acquisition and\n    a sequenceCanceled signal, followed by a sequenceFinished signal will\n    be emitted.\n    \"\"\"\n    with self._lock:\n        if self._state in (RunState.IDLE, RunState.FINISHING):\n            return\n        self._paused_time = 0\n        if self._state == RunState.ACQUIRING:\n            # defer to event boundary\n            self._cancel_requested = True\n        else:\n            # WAITING, PREPARING, or PAUSED \u2192 immediate transition\n            self._finish_reason = FinishReason.CANCELED\n            self._state = RunState.FINISHING\n</code></pre>"},{"location":"api/mda/#pymmcore_plus.mda._runner.MDARunner.engine","title":"<code>engine() -&gt; MDAEngine | None</code>  <code>property</code>","text":"<p>The <code>PMDAEngine</code> that is currently being used.</p> Source code in <code>pymmcore_plus/mda/_runner.py</code> <pre><code>@property\ndef engine(self) -&gt; MDAEngine | None:\n    \"\"\"The [`PMDAEngine`][pymmcore_plus.mda.PMDAEngine] that is currently being used.\"\"\"  # noqa: E501\n    return self._engine  # type: ignore\n</code></pre>"},{"location":"api/mda/#pymmcore_plus.mda._runner.MDARunner.event_seconds_elapsed","title":"<code>event_seconds_elapsed() -&gt; float</code>","text":"<p>Return the number of seconds on the \"event clock\".</p> <p>This is the time since either the start of the acquisition or the last event with <code>reset_event_timer</code> set to <code>True</code>.</p> Source code in <code>pymmcore_plus/mda/_runner.py</code> <pre><code>def event_seconds_elapsed(self) -&gt; float:\n    \"\"\"Return the number of seconds on the \"event clock\".\n\n    This is the time since either the start of the acquisition or the last\n    event with `reset_event_timer` set to `True`.\n    \"\"\"\n    return time.perf_counter() - self._t0\n</code></pre>"},{"location":"api/mda/#pymmcore_plus.mda._runner.MDARunner.events","title":"<code>events() -&gt; PMDASignaler</code>  <code>property</code>","text":"<p>Signals that are emitted during the MDA run.</p> <p>See <code>PMDASignaler</code> for details on the signals that are available to connect to.</p> Source code in <code>pymmcore_plus/mda/_runner.py</code> <pre><code>@property\ndef events(self) -&gt; PMDASignaler:\n    \"\"\"Signals that are emitted during the MDA run.\n\n    See [`PMDASignaler`][pymmcore_plus.mda.PMDASignaler] for details on the\n    signals that are available to connect to.\n    \"\"\"\n    return self._signals\n</code></pre>"},{"location":"api/mda/#pymmcore_plus.mda._runner.MDARunner.get_output_handlers","title":"<code>get_output_handlers() -&gt; tuple[SupportsFrameReady, ...]</code>","text":"<p>Return the data handlers that are currently connected.</p> <p>Output handlers are connected by passing them to the <code>output</code> parameter of the <code>run</code> method; the run method accepts objects with a <code>frameReady</code> method or strings representing paths.  If a string is passed, a handler will be created internally.</p> <p>This method returns a tuple of currently connected handlers, including those that were explicitly passed to <code>run()</code>, as well as those that were created based on file paths.  Internally, handlers are held by weak references, so if you want the handler to persist, you must keep a reference to it.  The only guaranteed API that the handler will have is the <code>frameReady</code> method, but it could be any user-defined object that implements that method.</p> <p>Handlers are cleared each time <code>run()</code> is called, (but not at the end of the sequence).</p> <p>Returns:</p> Type Description <code>tuple[SupportsFrameReady, ...]</code> <p>Tuple of objects that (minimally) support the <code>frameReady</code> method.</p> Source code in <code>pymmcore_plus/mda/_runner.py</code> <pre><code>def get_output_handlers(self) -&gt; tuple[SupportsFrameReady, ...]:\n    \"\"\"Return the data handlers that are currently connected.\n\n    Output handlers are connected by passing them to the `output` parameter of the\n    `run` method; the run method accepts objects with a `frameReady` method *or*\n    strings representing paths.  If a string is passed, a handler will be created\n    internally.\n\n    This method returns a tuple of currently connected handlers, including those\n    that were explicitly passed to `run()`, as well as those that were created based\n    on file paths.  Internally, handlers are held by weak references, so if you want\n    the handler to persist, you must keep a reference to it.  The only guaranteed\n    API that the handler will have is the `frameReady` method, but it could be any\n    user-defined object that implements that method.\n\n    Handlers are cleared each time `run()` is called, (but not at the end\n    of the sequence).\n\n    Returns\n    -------\n    tuple[SupportsFrameReady, ...]\n        Tuple of objects that (minimally) support the `frameReady` method.\n    \"\"\"\n    return tuple(self._handlers)\n</code></pre>"},{"location":"api/mda/#pymmcore_plus.mda._runner.MDARunner.is_paused","title":"<code>is_paused() -&gt; bool</code>","text":"<p>Return True if the acquisition is currently paused.</p> <p>Use <code>set_paused</code> to change the paused state.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the current acquisition is paused.</p> Source code in <code>pymmcore_plus/mda/_runner.py</code> <pre><code>def is_paused(self) -&gt; bool:\n    \"\"\"Return True if the acquisition is currently paused.\n\n    Use `set_paused` to change the paused state.\n\n    Returns\n    -------\n    bool\n        Whether the current acquisition is paused.\n    \"\"\"\n    return self._state == RunState.PAUSED\n</code></pre>"},{"location":"api/mda/#pymmcore_plus.mda._runner.MDARunner.is_running","title":"<code>is_running() -&gt; bool</code>","text":"<p>Return True if an acquisition is currently underway.</p> <p>This will return True at any point between the emission of the <code>sequenceStarted</code> and <code>sequenceFinished</code> signals, including when the acquisition is currently paused.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether an acquisition is underway.</p> Source code in <code>pymmcore_plus/mda/_runner.py</code> <pre><code>def is_running(self) -&gt; bool:\n    \"\"\"Return True if an acquisition is currently underway.\n\n    This will return True at any point between the emission of the\n    [`sequenceStarted`][pymmcore_plus.mda.PMDASignaler.sequenceStarted] and\n    [`sequenceFinished`][pymmcore_plus.mda.PMDASignaler.sequenceFinished] signals,\n    including when the acquisition is currently paused.\n\n    Returns\n    -------\n    bool\n        Whether an acquisition is underway.\n    \"\"\"\n    return self._state not in (RunState.IDLE, RunState.FINISHING)\n</code></pre>"},{"location":"api/mda/#pymmcore_plus.mda._runner.MDARunner.run","title":"<code>run(events: Iterable[MDAEvent], *, output: SingleOutput | Sequence[SingleOutput] | None = None) -&gt; None</code>","text":"<p>Run the multi-dimensional acquisition defined by <code>sequence</code>.</p> <p>Most users should not use this directly as it will block further execution. Instead, use the <code>CMMCorePlus.run_mda</code> method which will run on a thread.</p> <p>Parameters:</p> Name Type Description Default <code>events</code> <code>Iterable[MDAEvent]</code> <p>An iterable of <code>useq.MDAEvents</code> objects to execute.</p> required <code>output</code> <code>SingleOutput | Sequence[SingleOutput] | None, optional</code> <p>The output handler(s) to use.  If None, no output will be saved. The value may be either a single output or a sequence of outputs, where a \"single output\" can be any of the following:</p> <ul> <li>A string or Path to a directory to save images to. A handler will be created automatically based on the extension of the path.</li> <li><code>.zarr</code> files will be handled by <code>OMEZarrWriter</code></li> <li><code>.ome.tiff</code> files will be handled by <code>OMETiffWriter</code></li> <li>A directory with no extension will be handled by <code>ImageSequenceWriter</code></li> <li>A handler object that implements the <code>DataHandler</code> protocol, currently meaning it has a <code>frameReady</code> method.  See <code>mda_listeners_connected</code> for more details.</li> </ul> <p>During the course of the sequence, the <code>get_output_handlers</code> method can be used to get the currently connected output handlers (including those that were created automatically based on file paths).</p> <code>None</code> Source code in <code>pymmcore_plus/mda/_runner.py</code> <pre><code>def run(\n    self,\n    events: Iterable[MDAEvent],\n    *,\n    output: SingleOutput | Sequence[SingleOutput] | None = None,\n) -&gt; None:\n    \"\"\"Run the multi-dimensional acquisition defined by `sequence`.\n\n    Most users should not use this directly as it will block further\n    execution. Instead, use the\n    [`CMMCorePlus.run_mda`][pymmcore_plus.CMMCorePlus.run_mda] method which will\n    run on a thread.\n\n    Parameters\n    ----------\n    events : Iterable[MDAEvent]\n        An iterable of `useq.MDAEvents` objects to execute.\n    output : SingleOutput | Sequence[SingleOutput] | None, optional\n        The output handler(s) to use.  If None, no output will be saved.\n        The value may be either a single output or a sequence of outputs,\n        where a \"single output\" can be any of the following:\n\n        - A string or Path to a directory to save images to. A handler will be\n            created automatically based on the extension of the path.\n            - `.zarr` files will be handled by `OMEZarrWriter`\n            - `.ome.tiff` files will be handled by `OMETiffWriter`\n            - A directory with no extension will be handled by `ImageSequenceWriter`\n        - A handler object that implements the `DataHandler` protocol, currently\n            meaning it has a `frameReady` method.  See `mda_listeners_connected`\n            for more details.\n\n        During the course of the sequence, the `get_output_handlers` method can be\n        used to get the currently connected output handlers (including those that\n        were created automatically based on file paths).\n    \"\"\"\n    error = None\n    sequence = events if isinstance(events, MDASequence) else GeneratorMDASequence()\n    with self._outputs_connected(output):\n        # NOTE: it's important that `_prepare_to_run` and `_finish_run` are\n        # called inside the context manager, since the `mda_listeners_connected`\n        # context manager expects to see both of those signals.\n        try:\n            engine = self._prepare_to_run(sequence)\n            self._run(engine, events)\n        except Exception as e:\n            error = e\n            with self._lock:\n                if self._finish_reason is None:\n                    self._finish_reason = FinishReason.ERRORED\n        with exceptions_logged():\n            self._finish_run(sequence)\n    if error is not None:\n        raise error\n</code></pre>"},{"location":"api/mda/#pymmcore_plus.mda._runner.MDARunner.seconds_elapsed","title":"<code>seconds_elapsed() -&gt; float</code>","text":"<p>Return the number of seconds since the start of the acquisition.</p> Source code in <code>pymmcore_plus/mda/_runner.py</code> <pre><code>def seconds_elapsed(self) -&gt; float:\n    \"\"\"Return the number of seconds since the start of the acquisition.\"\"\"\n    return time.perf_counter() - self._sequence_t0\n</code></pre>"},{"location":"api/mda/#pymmcore_plus.mda._runner.MDARunner.set_engine","title":"<code>set_engine(engine: PMDAEngine) -&gt; PMDAEngine | None</code>","text":"<p>Set the <code>PMDAEngine</code> to use for the MDA run.</p> Source code in <code>pymmcore_plus/mda/_runner.py</code> <pre><code>def set_engine(self, engine: PMDAEngine) -&gt; PMDAEngine | None:\n    \"\"\"Set the [`PMDAEngine`][pymmcore_plus.mda.PMDAEngine] to use for the MDA run.\"\"\"  # noqa: E501\n    # MagicMock on py312 no longer satisfies isinstance ... so we explicitly\n    # allow it here just for the sake of testing.\n    if not isinstance(engine, (PMDAEngine, MagicMock)):\n        raise TypeError(\"Engine does not conform to the Engine protocol.\")\n\n    if self.is_running():  # pragma: no cover\n        raise RuntimeError(\n            \"Cannot register a new engine when the current engine is running \"\n            \"an acquisition. Please cancel the current engine's acquisition \"\n            \"before registering\"\n        )\n\n    old_engine, self._engine = self._engine, engine\n    return old_engine\n</code></pre>"},{"location":"api/mda/#pymmcore_plus.mda._runner.MDARunner.set_paused","title":"<code>set_paused(paused: bool) -&gt; None</code>","text":"<p>Set the paused state of the current acquisition.</p> <p>This is a no-op if the acquisition is already in the requested state, or if no acquisition is currently underway.</p> <p>Parameters:</p> Name Type Description Default <code>paused</code> <code>bool</code> <p>Whether to pause (True) or unpause (False) the acquisition.</p> required Source code in <code>pymmcore_plus/mda/_runner.py</code> <pre><code>def set_paused(self, paused: bool) -&gt; None:\n    \"\"\"Set the paused state of the current acquisition.\n\n    This is a no-op if the acquisition is already in the requested state,\n    or if no acquisition is currently underway.\n\n    Parameters\n    ----------\n    paused : bool\n        Whether to pause (True) or unpause (False) the acquisition.\n    \"\"\"\n    with self._lock:\n        if self._state == RunState.WAITING:\n            if not paused:\n                return\n            self._state = RunState.PAUSED\n        elif self._state == RunState.PAUSED:\n            if paused:\n                return\n            self._state = RunState.WAITING\n        elif self._state == RunState.ACQUIRING:\n            if self._pause_requested == paused:\n                return\n            self._pause_requested = paused\n        else:\n            return\n    self._signals.sequencePauseToggled.emit(paused)\n</code></pre>"},{"location":"api/mda/#pymmcore_plus.mda._runner.MDARunner.status","title":"<code>status() -&gt; RunnerStatus</code>  <code>property</code>","text":"<p>Snapshot of the runner's current status.</p> Source code in <code>pymmcore_plus/mda/_runner.py</code> <pre><code>@property\ndef status(self) -&gt; RunnerStatus:\n    \"\"\"Snapshot of the runner's current status.\"\"\"\n    with self._lock:\n        return RunnerStatus(\n            phase=self._state,\n            finish_reason=self._finish_reason,\n            cancel_requested=self._cancel_requested,\n            pause_requested=self._pause_requested,\n        )\n</code></pre>"},{"location":"api/mda/#pymmcore_plus.mda._runner.MDARunner.toggle_pause","title":"<code>toggle_pause() -&gt; None</code>","text":"<p>Toggle the paused state of the current acquisition.</p> <p>Deprecated</p> <p>Use <code>set_paused</code> instead.</p> Source code in <code>pymmcore_plus/mda/_runner.py</code> <pre><code>@deprecated(\"Use `set_paused(paused)` instead.\", category=DeprecationWarning)\ndef toggle_pause(self) -&gt; None:\n    \"\"\"Toggle the paused state of the current acquisition.\n\n    !!!warning \"Deprecated\"\n        Use [`set_paused`][pymmcore_plus.mda.MDARunner.set_paused] instead.\n    \"\"\"\n    self.set_paused(not (self.is_paused() or self._pause_requested))\n</code></pre>"},{"location":"api/mda/#pymmcore_plus.mda.PMDAEngine","title":"<code>pymmcore_plus.mda.PMDAEngine</code>","text":"<p>Protocol that all MDA engines must implement.</p>"},{"location":"api/mda/#pymmcore_plus.mda._protocol.PMDAEngine.event_iterator","title":"<code>event_iterator(events: Iterable[MDAEvent]) -&gt; Iterator[MDAEvent]</code>","text":"<p>Wrapper on the event iterator.</p> <p>Optional.</p> <p>This can be used to wrap the event iterator to perform any event merging (e.g. if the engine supports HardwareSequencing) or event modification. The default implementation is just <code>iter(events)</code>.</p> <p>Be careful when using this method.  It is powerful and can result in unexpected event iteration if used incorrectly.</p>"},{"location":"api/mda/#pymmcore_plus.mda._protocol.PMDAEngine.exec_event","title":"<code>exec_event(event: MDAEvent) -&gt; Iterable[PImagePayload]</code>  <code>abstractmethod</code>","text":"<p>Execute <code>event</code>.</p> <p>This method is called after <code>setup_event</code> and is responsible for executing the event.  The default assumption is to acquire an image, but more elaborate events will be possible.</p> <p>The protocol for the returned object is still under development.  However, if the returned object has an <code>image</code> attribute, then the <code>MDARunner</code> will emit a <code>frameReady</code> signal</p>"},{"location":"api/mda/#pymmcore_plus.mda._protocol.PMDAEngine.setup_event","title":"<code>setup_event(event: MDAEvent) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Prepare state of system (hardware, etc.) for <code>event</code>.</p> <p>This method is called before each event in the sequence.  It is responsible for preparing the state of the system for the event. The engine should be in a state where it can call <code>exec_event</code> without any additional preparation.  (This means that the engine should perform any waits or blocks required for system state changes to complete.)</p>"},{"location":"api/mda/#pymmcore_plus.mda._protocol.PMDAEngine.setup_sequence","title":"<code>setup_sequence(sequence: MDASequence) -&gt; SummaryMetaV1 | None</code>  <code>abstractmethod</code>","text":"<p>Setup state of system (hardware, etc.) before an MDA is run.</p> <p>This method is called once at the beginning of a sequence.</p>"},{"location":"api/mda/#pymmcore_plus.mda._protocol.PMDAEngine.teardown_event","title":"<code>teardown_event(event: MDAEvent) -&gt; None</code>","text":"<p>Teardown state of system (hardware, etc.) after <code>event</code>.</p> <p>Optional.</p> <p>If the engine provides this function, it will be called after <code>exec_event</code> to perform any cleanup or teardown required after the event has been executed.</p>"},{"location":"api/mda/#pymmcore_plus.mda._protocol.PMDAEngine.teardown_sequence","title":"<code>teardown_sequence(sequence: MDASequence) -&gt; None</code>","text":"<p>Perform any teardown required after the sequence has been executed.</p> <p>Optional.</p> <p>If the engine provides this function, it will be called after the last event in the sequence has been executed.</p>"},{"location":"api/mda/#pymmcore_plus.mda.MDAEngine","title":"<code>pymmcore_plus.mda.MDAEngine</code>","text":"<p>The default MDAengine that ships with pymmcore-plus.</p> <p>This implements the <code>PMDAEngine</code> protocol, and uses a <code>CMMCorePlus</code> instance to control the hardware.</p> <p>It may be subclassed to provide custom behavior, or to override specific methods. https://pymmcore-plus.github.io/pymmcore-plus/guides/custom_engine/</p> <p>Attributes:</p> Name Type Description <code>mmcore</code> <code>CMMCorePlus</code> <p>The <code>CMMCorePlus</code> instance to use for hardware control.</p> <code>use_hardware_sequencing</code> <code>bool</code> <p>Whether to use hardware sequencing if possible. If <code>True</code>, the engine will attempt to combine MDAEvents into a single <code>SequencedEvent</code> if <code>core.canSequenceEvents()</code> reports that the events can be sequenced. This can be set after instantiation. By default, this is <code>True</code>, however in various testing and demo scenarios, you may wish to set it to <code>False</code> in order to avoid unexpected behavior.</p> <code>force_set_xy_position</code> <code>bool</code> <p>Whether to always set the XY position, even if the target position is the same as the last commanded position (this does not query the stage for the current position). By default, this is <code>True</code>.</p> <code>restore_initial_state</code> <code>bool | None</code> <p>Whether to restore the initial hardware state after the MDA sequence completes. If <code>True</code>, the engine will capture the initial state (positions, config groups, exposure settings) before the sequence starts and restore it after completion.  If <code>None</code> (the default), <code>restore_initial_state</code> will be set to <code>True</code> if FocusDirection is known (i.e. not Unknown).</p> Source code in <code>pymmcore_plus/mda/_engine.py</code> <pre><code>class MDAEngine(PMDAEngine):\n    \"\"\"The default MDAengine that ships with pymmcore-plus.\n\n    This implements the [`PMDAEngine`][pymmcore_plus.mda.PMDAEngine] protocol, and\n    uses a [`CMMCorePlus`][pymmcore_plus.CMMCorePlus] instance to control the hardware.\n\n    It may be subclassed to provide custom behavior, or to override specific methods.\n    &lt;https://pymmcore-plus.github.io/pymmcore-plus/guides/custom_engine/&gt;\n\n    Attributes\n    ----------\n    mmcore: CMMCorePlus\n        The `CMMCorePlus` instance to use for hardware control.\n    use_hardware_sequencing : bool\n        Whether to use hardware sequencing if possible. If `True`, the engine will\n        attempt to combine MDAEvents into a single `SequencedEvent` if\n        [`core.canSequenceEvents()`][pymmcore_plus.CMMCorePlus.canSequenceEvents]\n        reports that the events can be sequenced. This can be set after instantiation.\n        By default, this is `True`, however in various testing and demo scenarios, you\n        may wish to set it to `False` in order to avoid unexpected behavior.\n    force_set_xy_position : bool\n        Whether to always set the XY position, even if the target position is the same\n        as the last commanded position (this does *not* query the stage for the\n        current position). By default, this is `True`.\n    restore_initial_state : bool | None\n        Whether to restore the initial hardware state after the MDA sequence completes.\n        If `True`, the engine will capture the initial state (positions,\n        config groups, exposure settings) before the sequence starts and restore it\n        after completion.  If `None` (the default), `restore_initial_state` will\n        be set to `True` if FocusDirection is known (i.e. not Unknown).\n    \"\"\"\n\n    def __init__(\n        self,\n        mmc: CMMCorePlus,\n        *,\n        use_hardware_sequencing: bool = True,\n        force_set_xy_position: bool = True,\n        restore_initial_state: bool | None = None,\n    ) -&gt; None:\n        self._mmcore_ref = weakref.ref(mmc)\n        self.use_hardware_sequencing: bool = use_hardware_sequencing\n        self.force_set_xy_position: bool = force_set_xy_position\n        self.restore_initial_state: bool | None = restore_initial_state\n\n        # whether to include position metadata when fetching on-frame metadata\n        # omitted by default when performing triggered acquisition because it's slow.\n        self._include_frame_position_metadata: IncludePositionArg = \"unsequenced-only\"\n\n        # stored initial state for restoration (if restore_initial_state is True)\n        self._initial_state: StateDict = {}\n\n        # used to check if the hardware autofocus is engaged when the sequence begins.\n        # if it is, we will re-engage it after the autofocus action (if successful).\n        self._af_was_engaged: bool = False\n        # used to store the success of the last _execute_autofocus call\n        self._af_succeeded: bool = False\n\n        # used for one_shot autofocus to store the z correction for each position index.\n        # map of {position_index: z_correction}\n        self._z_correction: dict[int | None, float] = {}\n\n        # This is used to determine whether we need to re-enable autoshutter after\n        # the sequence is done (assuming a event.keep_shutter_open was requested)\n        # Note: getAutoShutter() is True when no config is loaded at all\n        self._autoshutter_was_set: bool = mmc.getAutoShutter()\n\n        self._last_config: tuple[str, str] = (\"\", \"\")\n        self._last_xy_pos: tuple[float | None, float | None] = (None, None)\n\n        # -----\n        # The following values are stored during setup_sequence simply to speed up\n        # retrieval of metadata during each frame.\n        # sequence of (device, property) of all properties used in any of the presets\n        # in the channel group.\n        self._config_device_props: dict[str, Sequence[tuple[str, str]]] = {}\n\n    @property\n    def include_frame_position_metadata(self) -&gt; IncludePositionArg:\n        return self._include_frame_position_metadata\n\n    @include_frame_position_metadata.setter\n    def include_frame_position_metadata(self, value: IncludePositionArg) -&gt; None:\n        if value not in (True, False, \"unsequenced-only\"):  # pragma: no cover\n            raise ValueError(\n                \"include_frame_position_metadata must be True, False, or \"\n                \"'unsequenced-only'\"\n            )\n        self._include_frame_position_metadata = value\n\n    @property\n    def mmcore(self) -&gt; CMMCorePlus:\n        \"\"\"The `CMMCorePlus` instance to use for hardware control.\"\"\"\n        if (mmc := self._mmcore_ref()) is None:  # pragma: no cover\n            raise RuntimeError(\"The CMMCorePlus instance has been garbage collected.\")\n        return mmc\n\n    # ===================== Protocol Implementation =====================\n\n    def setup_sequence(self, sequence: MDASequence) -&gt; SummaryMetaV1 | None:\n        \"\"\"Setup the hardware for the entire sequence.\"\"\"\n        # clear z_correction for new sequence\n        self._z_correction.clear()\n\n        if not (core := self._mmcore_ref()):  # pragma: no cover\n            from pymmcore_plus.core import CMMCorePlus\n\n            core = CMMCorePlus.instance()\n            self._mmcore_ref = weakref.ref(core)\n\n        # just in case a non-programmatic changes have been made in the meantime\n        # https://github.com/pymmcore-plus/pymmcore-plus/issues/503\n        core._last_config = (\"\", \"\")  # noqa: SLF001\n        core._last_xy_position.clear()  # noqa: SLF001\n\n        self._update_config_device_props()\n        # get if the autofocus is engaged at the start of the sequence\n        self._af_was_engaged = core.isContinuousFocusLocked()\n\n        # capture initial state if restoration is enabled\n        if self.restore_initial_state is None:\n            if fd := core.getFocusDevice():\n                self.restore_initial_state = (\n                    core.getFocusDirection(fd) != FocusDirection.Unknown\n                )\n            else:\n                self.restore_initial_state = False\n\n        if self.restore_initial_state:\n            self._initial_state = self._capture_state()\n\n        if px_size := core.getPixelSizeUm():\n            self._update_grid_fov_sizes(px_size, sequence)\n\n        self._autoshutter_was_set = core.getAutoShutter()\n        return self.get_summary_metadata(mda_sequence=sequence)\n\n    def get_summary_metadata(self, mda_sequence: MDASequence | None) -&gt; SummaryMetaV1:\n        return summary_metadata(self.mmcore, mda_sequence=mda_sequence)\n\n    def _update_grid_fov_sizes(self, px_size: float, sequence: MDASequence) -&gt; None:\n        *_, x_size, y_size = self.mmcore.getROI()\n        fov_width = x_size * px_size\n        fov_height = y_size * px_size\n\n        if sequence.grid_plan:\n            sequence.grid_plan.fov_width = fov_width\n            sequence.grid_plan.fov_height = fov_height\n\n        # set fov to any stage positions sequences\n        for p in sequence.stage_positions:\n            if p.sequence and p.sequence.grid_plan:\n                p.sequence.grid_plan.fov_height = fov_height\n                p.sequence.grid_plan.fov_width = fov_width\n\n    def setup_event(self, event: MDAEvent) -&gt; None:\n        \"\"\"Set the system hardware (XY, Z, channel, exposure) as defined in the event.\n\n        Parameters\n        ----------\n        event : MDAEvent\n            The event to use for the Hardware config\n        \"\"\"\n        if isinstance(event, SequencedEvent):\n            self.setup_sequenced_event(event)\n        else:\n            self.setup_single_event(event)\n        self.mmcore.waitForSystem()\n\n    def exec_event(self, event: MDAEvent) -&gt; Iterable[PImagePayload]:\n        \"\"\"Execute an individual event and return the image data.\"\"\"\n        action = getattr(event, \"action\", None)\n        core = self.mmcore\n        if isinstance(action, HardwareAutofocus):\n            # skip if no autofocus device is found\n            if not core.getAutoFocusDevice():\n                logger.warning(\"No autofocus device found. Cannot execute autofocus.\")\n                return\n\n            try:\n                # execute hardware autofocus\n                new_correction = self._execute_autofocus(action)\n                self._af_succeeded = True\n            except RuntimeError as e:\n                logger.warning(\"Hardware autofocus failed. %s\", e)\n                self._af_succeeded = False\n            else:\n                # store correction for this position index\n                p_idx = event.index.get(\"p\", None)\n                self._z_correction[p_idx] = new_correction + self._z_correction.get(\n                    p_idx, 0.0\n                )\n            return\n\n        # don't try to execute any other action types. Mostly, this is just\n        # CustomAction, which is a user-defined action that the engine doesn't know how\n        # to handle.  But may include other actions in the future, and this ensures\n        # backwards compatibility.\n        if not isinstance(action, (AcquireImage, type(None))):\n            return\n\n        # if the autofocus was engaged at the start of the sequence AND autofocus action\n        # did not fail, re-engage it. NOTE: we need to do that AFTER the runner calls\n        # `setup_event`, so we can't do it inside the exec_event autofocus action above.\n        if self._af_was_engaged and self._af_succeeded:\n            core.enableContinuousFocus(True)\n\n        if isinstance(event, SequencedEvent):\n            yield from self.exec_sequenced_event(event)\n        else:\n            yield from self.exec_single_event(event)\n\n    def event_iterator(self, events: Iterable[MDAEvent]) -&gt; Iterator[MDAEvent]:\n        \"\"\"Event iterator that merges events for hardware sequencing if possible.\n\n        This wraps `for event in events: ...` inside `MDARunner.run()` and combines\n        sequenceable events into an instance of `SequencedEvent` if\n        `self.use_hardware_sequencing` is `True`.\n        \"\"\"\n        if not self.use_hardware_sequencing:\n            yield from events\n            return\n\n        yield from iter_sequenced_events(self.mmcore, events)\n\n    # ===================== Regular Events =====================\n\n    def setup_single_event(self, event: MDAEvent) -&gt; None:\n        \"\"\"Setup hardware for a single (non-sequenced) event.\n\n        This method is not part of the PMDAEngine protocol (it is called by\n        `setup_event`, which *is* part of the protocol), but it is made public\n        in case a user wants to subclass this engine and override this method.\n        \"\"\"\n        if event.keep_shutter_open:\n            ...\n\n        self._set_event_xy_position(event)\n\n        if event.z_pos is not None:\n            self._set_event_z(event)\n        if event.slm_image is not None:\n            self._set_event_slm_image(event)\n\n        self._set_event_channel(event)\n\n        mmcore = self.mmcore\n        if event.exposure is not None:\n            try:\n                mmcore.setExposure(event.exposure)\n            except Exception as e:\n                logger.warning(\"Failed to set exposure. %s\", e)\n        if event.properties is not None:\n            try:\n                for dev, prop, value in event.properties:\n                    mmcore.setProperty(dev, prop, value)\n            except Exception as e:\n                logger.warning(\"Failed to set properties. %s\", e)\n        if (\n            # (if autoshutter wasn't set at the beginning of the sequence\n            # then it never matters...)\n            self._autoshutter_was_set\n            # if we want to leave the shutter open after this event, and autoshutter\n            # is currently enabled...\n            and event.keep_shutter_open\n            and mmcore.getAutoShutter()\n        ):\n            # we have to disable autoshutter and open the shutter\n            mmcore.setAutoShutter(False)\n            mmcore.setShutterOpen(True)\n\n    def exec_single_event(self, event: MDAEvent) -&gt; Iterator[PImagePayload]:\n        \"\"\"Execute a single (non-triggered) event and return the image data.\n\n        This method is not part of the PMDAEngine protocol (it is called by\n        `exec_event`, which *is* part of the protocol), but it is made public\n        in case a user wants to subclass this engine and override this method.\n        \"\"\"\n        if event.slm_image is not None:\n            self._exec_event_slm_image(event.slm_image)\n\n        mmcore = self.mmcore\n        try:\n            mmcore.snapImage()\n            # taking event time after snapImage includes exposure time\n            # not sure that's what we want, but it's currently consistent with the\n            # timing of the sequenced event runner (where Elapsed_Time_ms is taken after\n            # the image is acquired, not before the exposure starts)\n            t0 = event.metadata.get(\"runner_t0\") or time.perf_counter()\n            event_time_ms = (time.perf_counter() - t0) * 1000\n        except Exception as e:\n            logger.warning(\"Failed to snap image. %s\", e)\n            return\n        if not event.keep_shutter_open:\n            mmcore.setShutterOpen(False)\n\n        # most cameras will only have a single channel\n        # but Multi-camera may have multiple, and we need to retrieve a buffer for each\n        for cam in range(mmcore.getNumberOfCameraChannels()):\n            meta = self.get_frame_metadata(\n                event,\n                runner_time_ms=event_time_ms,\n                camera_device=mmcore.getPhysicalCameraDevice(cam),\n                include_position=self._include_frame_position_metadata is not False,\n            )\n            # Note, the third element is actually a MutableMapping, but mypy doesn't\n            # see TypedDict as a subclass of MutableMapping yet.\n            # https://github.com/python/mypy/issues/4976\n            yield ImagePayload(mmcore.getImage(cam), event, meta)  # type: ignore[misc]\n\n    def get_frame_metadata(\n        self,\n        event: MDAEvent,\n        prop_values: tuple[PropertyValue, ...] | None = None,\n        runner_time_ms: float = 0.0,\n        include_position: bool = True,\n        camera_device: str | None = None,\n    ) -&gt; FrameMetaV1:\n        if prop_values is None and (ch := event.channel):\n            prop_values = self._get_current_props(ch.group)\n        else:\n            prop_values = ()\n        return frame_metadata(\n            self.mmcore,\n            cached=True,\n            runner_time_ms=runner_time_ms,\n            camera_device=camera_device,\n            property_values=prop_values,\n            mda_event=event,\n            include_position=include_position,\n        )\n\n    def teardown_event(self, event: MDAEvent) -&gt; None:\n        \"\"\"Teardown state of system (hardware, etc.) after `event`.\"\"\"\n        # autoshutter was set at the beginning of the sequence, and this event\n        # doesn't want to leave the shutter open.  Re-enable autoshutter.\n        core = self.mmcore\n        if not event.keep_shutter_open and self._autoshutter_was_set:\n            core.setAutoShutter(True)\n        # FIXME: this may not be hitting as intended...\n        # https://github.com/pymmcore-plus/pymmcore-plus/pull/353#issuecomment-2159176491\n        if isinstance(event, SequencedEvent):\n            if event.exposure_sequence:\n                core.stopExposureSequence(core.getCameraDevice())\n            if event.x_sequence:\n                core.stopXYStageSequence(core.getXYStageDevice())\n            if event.z_sequence:\n                core.stopStageSequence(core.getFocusDevice())\n            for dev, prop in event.property_sequences:\n                core.stopPropertySequence(dev, prop)\n\n    def teardown_sequence(self, sequence: MDASequence) -&gt; None:\n        \"\"\"Perform any teardown required after the sequence has been executed.\"\"\"\n        # restore initial state if enabled and state was captured\n        if self.restore_initial_state and self._initial_state:\n            self._restore_initial_state()\n\n    def _capture_state(self) -&gt; StateDict:\n        \"\"\"Capture the current hardware state for later restoration.\"\"\"\n        state: StateDict = {}\n        if (core := self._mmcore_ref()) is None:\n            return state\n\n        try:\n            # capture XY position\n            if core.getXYStageDevice():\n                state[\"xy_position\"] = core.getXYPosition()\n        except Exception as e:\n            logger.warning(\"Failed to capture XY position: %s\", e)\n\n        try:\n            # capture Z position\n            if core.getFocusDevice():\n                state[\"z_position\"] = core.getZPosition()\n        except Exception as e:\n            logger.warning(\"Failed to capture Z position: %s\", e)\n\n        try:\n            state[\"exposure\"] = core.getExposure()\n        except Exception as e:\n            logger.warning(\"Failed to capture exposure setting: %s\", e)\n\n        # capture config group states\n        try:\n            state_groups = state.setdefault(\"config_groups\", {})\n            for group in core.getAvailableConfigGroups():\n                if current_config := core.getCurrentConfig(group):\n                    state_groups[group] = current_config\n        except Exception as e:\n            logger.warning(\"Failed to get available config groups: %s\", e)\n\n        # capture autoshutter state\n        try:\n            state[\"autoshutter\"] = core.getAutoShutter()\n        except Exception as e:\n            logger.warning(\"Failed to capture autoshutter state: %s\", e)\n\n        return state\n\n    def _restore_initial_state(self) -&gt; None:\n        \"\"\"Restore the hardware state that was captured before the sequence.\"\"\"\n        if not self._initial_state or (core := self._mmcore_ref()) is None:\n            return\n\n        # !!! We need to be careful about the order of Z and XY restoration:\n        #\n        # If FocusDirection is Unknown, we cannot safely restore Z *or* XY stage\n        # positions: we simply refuse and warn.\n        #\n        # If focus_dir is TowardSample, and we are restoring a Z-position that is\n        # *lower* than the current position or\n        # if focus_dir is AwayFromSample, and we are restoring a Z-position that is\n        # *higher* than the current position, then we need to move Z *before* moving XY,\n        # otherwise we may crash the objective into the sample.\n        # Otherwise, we should move XY first, then Z.\n        target_z = self._initial_state.get(\"z_position\")\n        move_z_first = False\n        focus_dir = FocusDirection.Unknown\n        if target_z is not None and (focus_device := core.getFocusDevice()):\n            focus_dir = core.getFocusDirection(focus_device)\n            cur_z = core.getZPosition()\n            # focus_dir TowardSample =&gt; increasing position brings obj. closer to sample\n            if cur_z &gt; target_z:\n                if focus_dir == FocusDirection.TowardSample:\n                    move_z_first = True\n            elif focus_dir == FocusDirection.AwayFromSample:\n                move_z_first = True\n\n        if focus_dir == FocusDirection.Unknown:\n            _warn_focus_dir(focus_device)\n        else:\n\n            def _move_z() -&gt; None:\n                if target_z is not None:\n                    try:\n                        if core.getFocusDevice():\n                            core.setZPosition(target_z)\n                    except Exception as e:\n                        logger.warning(\"Failed to restore Z position: %s\", e)\n\n            if move_z_first:\n                _move_z()\n\n            # restore XY position\n            if \"xy_position\" in self._initial_state:\n                try:\n                    if core.getXYStageDevice():\n                        core.setXYPosition(*self._initial_state[\"xy_position\"])\n                except Exception as e:\n                    logger.warning(\"Failed to restore XY position: %s\", e)\n\n            if not move_z_first:\n                _move_z()\n\n        # restore exposure\n        if \"exposure\" in self._initial_state:\n            try:\n                core.setExposure(self._initial_state[\"exposure\"])\n            except Exception as e:\n                logger.warning(\"Failed to restore exposure setting: %s\", e)\n\n        # restore config group states\n        for key, value in self._initial_state.get(\"config_groups\", {}).items():\n            try:\n                core.setConfig(key, value)\n            except Exception as e:\n                logger.warning(\n                    \"Failed to restore config group %s to %s: %s\", key, value, e\n                )\n\n        # restore autoshutter state\n        if \"autoshutter\" in self._initial_state:\n            try:\n                core.setAutoShutter(self._initial_state[\"autoshutter\"])\n            except Exception as e:\n                logger.warning(\"Failed to restore autoshutter state: %s\", e)\n\n        core.waitForSystem()\n        # clear the state after restoration\n        self._initial_state = {}\n\n    # ===================== Sequenced Events =====================\n\n    def _load_sequenced_event(self, event: SequencedEvent) -&gt; None:\n        \"\"\"Load a `SequencedEvent` into the core.\n\n        `SequencedEvent` is a special pymmcore-plus specific subclass of\n        `useq.MDAEvent`.\n        \"\"\"\n        core = self.mmcore\n        if event.exposure_sequence:\n            cam_device = core.getCameraDevice()\n            with suppress(RuntimeError):\n                core.stopExposureSequence(cam_device)\n            core.loadExposureSequence(cam_device, event.exposure_sequence)\n        if event.x_sequence:  # y_sequence is implied and will be the same length\n            stage = core.getXYStageDevice()\n            with suppress(RuntimeError):\n                core.stopXYStageSequence(stage)\n            core.loadXYStageSequence(stage, event.x_sequence, event.y_sequence)\n        if event.z_sequence:\n            zstage = core.getFocusDevice()\n            with suppress(RuntimeError):\n                core.stopStageSequence(zstage)\n            core.loadStageSequence(zstage, event.z_sequence)\n        if event.slm_sequence:\n            slm = core.getSLMDevice()\n            with suppress(RuntimeError):\n                core.stopSLMSequence(slm)\n            core.loadSLMSequence(slm, event.slm_sequence)  # type: ignore[arg-type]\n        if event.property_sequences:\n            for (dev, prop), value_sequence in event.property_sequences.items():\n                with suppress(RuntimeError):\n                    core.stopPropertySequence(dev, prop)\n                core.loadPropertySequence(dev, prop, value_sequence)\n\n        # set all static properties, these won't change over the course of the sequence.\n        if event.properties:\n            for dev, prop, value in event.properties:\n                core.setProperty(dev, prop, value)\n\n    def setup_sequenced_event(self, event: SequencedEvent) -&gt; None:\n        \"\"\"Setup hardware for a sequenced (triggered) event.\n\n        This method is not part of the PMDAEngine protocol (it is called by\n        `setup_event`, which *is* part of the protocol), but it is made public\n        in case a user wants to subclass this engine and override this method.\n        \"\"\"\n        core = self.mmcore\n\n        self._load_sequenced_event(event)\n\n        # this is probably not necessary.  loadSequenceEvent will have already\n        # set all the config properties individually/manually.  However, without\n        # the call below, we won't be able to query `core.getCurrentConfig()`\n        # not sure that's necessary; and this is here for tests to pass for now,\n        # but this could be removed.\n        self._set_event_channel(event)\n\n        if event.slm_image:\n            self._set_event_slm_image(event)\n\n        if core.isSequenceRunning():\n            self._await_sequence_acquisition()\n\n        # start sequences or set non-sequenced values\n        if event.x_sequence:\n            core.startXYStageSequence(core.getXYStageDevice())\n        else:\n            self._set_event_xy_position(event)\n\n        if event.z_sequence:\n            core.startStageSequence(core.getFocusDevice())\n        elif event.z_pos is not None:\n            self._set_event_z(event)\n\n        if event.exposure_sequence:\n            core.startExposureSequence(core.getCameraDevice())\n        elif event.exposure is not None:\n            core.setExposure(event.exposure)\n\n        if event.property_sequences:\n            for dev, prop in event.property_sequences:\n                core.startPropertySequence(dev, prop)\n\n    def _await_sequence_acquisition(\n        self, timeout: float = 5.0, poll_interval: float = 0.2\n    ) -&gt; None:\n        tot = 0.0\n        core = self.mmcore\n        core.stopSequenceAcquisition()\n        while core.isSequenceRunning():\n            time.sleep(poll_interval)\n            tot += poll_interval\n            if tot &gt;= timeout:\n                raise TimeoutError(\"Failed to stop running sequence\")\n\n    def post_sequence_started(self, event: SequencedEvent) -&gt; None:\n        \"\"\"Perform any actions after startSequenceAcquisition has been called.\n\n        This method is available to subclasses in case they need to perform any\n        actions after a hardware-triggered sequence has been started (i.e. after\n        core.startSequenceAcquisition has been called).\n\n        The default implementation does nothing.\n        \"\"\"\n\n    def exec_sequenced_event(self, event: SequencedEvent) -&gt; EventPayloadGenerator:\n        \"\"\"Execute a sequenced (triggered) event and return the image data.\n\n        This method is not part of the PMDAEngine protocol (it is called by\n        `exec_event`, which *is* part of the protocol), but it is made public\n        in case a user wants to subclass this engine and override this method.\n        \"\"\"\n        n_events = len(event.events)\n        if t0 := event.metadata.get(\"runner_t0\"):\n            t0_ms = (time.perf_counter() - t0) * 1000\n        else:\n            t0_ms = 0.0\n\n        if event.slm_image is not None:\n            self._exec_event_slm_image(event.slm_image)\n\n        core = self.mmcore\n        n_channels = core.getNumberOfCameraChannels()\n\n        # Start sequence\n        # Note that the overload of startSequenceAcquisition that takes a camera\n        # label does NOT automatically initialize a circular buffer.  So if this call\n        # is changed to accept the camera in the future, that should be kept in mind.\n        core.startSequenceAcquisition(n_events, 0, True)\n        self.post_sequence_started(event)\n\n        if n_channels == 1:\n            yield from self._exec_single_camera_sequence(event, t0_ms)\n        else:\n            yield from self._exec_multi_camera_sequence(event, t0_ms, n_channels)\n\n    def _exec_single_camera_sequence(\n        self, event: SequencedEvent, t0_ms: float\n    ) -&gt; EventPayloadGenerator:\n        \"\"\"Execute single-camera sequenced event (fast path, no coordination needed).\"\"\"\n        core = self.mmcore\n        count = 0\n        pause_warned = False\n\n        # Pop frames while sequence is running, then drain remaining buffer\n        while True:\n            if remaining := core.getRemainingImageCount():\n                img, mm_meta = core.popNextImageAndMD()\n                signal = yield self._create_seqimg_payload_from_popped(\n                    img,\n                    mm_meta,\n                    event=event.events[count],\n                    channel=0,\n                    event_t0=t0_ms,\n                    remaining=remaining - 1,\n                )\n                count += 1\n                if signal == \"cancel\":\n                    core.stopSequenceAcquisition()\n                    return\n                if signal == \"pause\" and not pause_warned:\n                    pause_warned = True\n                    logger.warning(\n                        \"MDA: Pause has been requested, but sequenced acquisition \"\n                        \"cannot be yet paused, only canceled.\"\n                    )\n            elif core.isSequenceRunning():\n                # Still acquiring, buffer temporarily empty - wait\n                time.sleep(0.001)\n            else:\n                # Done acquiring and buffer empty - exit\n                break\n\n        if core.isBufferOverflowed():  # pragma: no cover\n            raise MemoryError(\"Buffer overflowed\")\n\n        # Validate count\n        if count != len(event.events):\n            logger.warning(\n                \"Unexpected number of images returned from sequence. \"\n                \"Expected %s, got %s\",\n                len(event.events),\n                count,\n            )\n\n    def _exec_multi_camera_sequence(\n        self,\n        event: SequencedEvent,\n        t0_ms: float,\n        n_channels: int,\n    ) -&gt; EventPayloadGenerator:\n        \"\"\"Execute multi-camera sequenced event with frame coordination.\"\"\"\n        core = self.mmcore\n        n_events = len(event.events)\n        coordinator = _MultiCameraCoordinator(core, n_channels, n_events)\n        pause_warned = False\n\n        # Unified loop: pop while running, then drain remaining buffer\n        while True:\n            if core.getRemainingImageCount():\n                for payload in coordinator.pop_and_process(\n                    event.events,\n                    t0_ms,\n                    self._create_seqimg_payload_from_popped,\n                ):\n                    signal = yield payload\n                    if signal == \"cancel\":\n                        core.stopSequenceAcquisition()\n                        return\n                    if signal == \"pause\" and not pause_warned:\n                        pause_warned = True\n                        logger.warning(\n                            \"MDA: Pause has been requested, but sequenced \"\n                            \"acquisition cannot be yet paused, only canceled.\"\n                        )\n            elif core.isSequenceRunning():\n                time.sleep(0.001)\n            else:\n                break\n\n        if core.isBufferOverflowed():  # pragma: no cover\n            raise MemoryError(\"Buffer overflowed\")\n\n        # Flush buffered frames and validate count\n        for payload in coordinator.flush_remaining():\n            signal = yield payload\n            if signal == \"cancel\":\n                return\n        coordinator.validate_count()\n\n    def _create_seqimg_payload_from_popped(\n        self,\n        img: NDArray,\n        mm_meta: Metadata,\n        event: MDAEvent,\n        channel: int,\n        *,\n        event_t0: float = 0.0,\n        remaining: int = 0,\n    ) -&gt; PImagePayload:\n        \"\"\"Create ImagePayload from already-popped image and metadata.\n\n        This is used by exec_sequenced_event to properly handle multi-camera\n        acquisitions where images arrive asynchronously.\n        \"\"\"\n        core = self.mmcore\n        try:\n            seq_time = float(mm_meta.get(Keyword.Elapsed_Time_ms))\n        except Exception:\n            seq_time = 0.0\n        try:\n            # note, when present in circular buffer meta, this key is called \"Camera\".\n            # It's NOT actually Keyword.CoreCamera (but it's the same value)\n            # it is hardcoded in various places in mmCoreAndDevices, see:\n            # see: https://github.com/micro-manager/mmCoreAndDevices/pull/468\n            camera_device = mm_meta.GetSingleTag(\"Camera\").GetValue()\n        except Exception:\n            camera_device = core.getPhysicalCameraDevice(channel)\n\n        # TODO: determine whether we want to try to populate changing property values\n        # during the course of a triggered sequence\n        meta = self.get_frame_metadata(\n            event,\n            prop_values=(),\n            runner_time_ms=event_t0 + seq_time,\n            camera_device=camera_device,\n            include_position=self._include_frame_position_metadata is True,\n        )\n        meta[\"hardware_triggered\"] = True\n        meta[\"images_remaining_in_buffer\"] = remaining\n        meta[\"camera_metadata\"] = dict(mm_meta)\n\n        # https://github.com/python/mypy/issues/4976\n        return ImagePayload(img, event, meta)  # type: ignore[return-value]\n\n    # ===================== EXTRA =====================\n\n    def _execute_autofocus(self, action: HardwareAutofocus) -&gt; float:\n        \"\"\"Perform the hardware autofocus.\n\n        Returns the change in ZPosition that occurred during the autofocus event.\n        \"\"\"\n        core = self.mmcore\n        # switch off autofocus device if it is on\n        core.enableContinuousFocus(False)\n\n        if action.autofocus_motor_offset is not None:\n            # set the autofocus device offset\n            # if name is given explicitly, use it, otherwise use setAutoFocusOffset\n            # (see docs for setAutoFocusOffset for additional details)\n            if name := getattr(action, \"autofocus_device_name\", None):\n                core.setPosition(name, action.autofocus_motor_offset)\n            else:\n                core.setAutoFocusOffset(action.autofocus_motor_offset)\n            core.waitForSystem()\n\n        @retry(exceptions=RuntimeError, tries=action.max_retries, logger=logger.warning)\n        def _perform_full_focus(previous_z: float) -&gt; float:\n            core.fullFocus()\n            core.waitForSystem()\n            return core.getZPosition() - previous_z\n\n        return _perform_full_focus(core.getZPosition())\n\n    def _set_event_xy_position(self, event: MDAEvent) -&gt; None:\n        event_x, event_y = event.x_pos, event.y_pos\n        # If neither coordinate is provided, do nothing.\n        if event_x is None and event_y is None:\n            return\n\n        core = self.mmcore\n        # skip if no XY stage device is found\n        if not core.getXYStageDevice():\n            logger.warning(\"No XY stage device found. Cannot set XY position.\")\n            return\n\n        # Retrieve the last commanded XY position.\n        last_x, last_y = core._last_xy_position.get(None) or (None, None)  # noqa: SLF001\n        if (\n            not self.force_set_xy_position\n            and (event_x is None or event_x == last_x)\n            and (event_y is None or event_y == last_y)\n        ):\n            return\n\n        if event_x is None or event_y is None:\n            cur_x, cur_y = core.getXYPosition()\n            event_x = cur_x if event_x is None else event_x\n            event_y = cur_y if event_y is None else event_y\n\n        try:\n            core.setXYPosition(event_x, event_y)\n        except Exception as e:\n            logger.warning(\"Failed to set XY position. %s\", e)\n\n    def _set_event_channel(self, event: MDAEvent) -&gt; None:\n        if (ch := event.channel) is None:\n            return\n\n        # comparison with _last_config is a fast/rough check ... which may miss subtle\n        # differences if device properties have been individually set in the meantime.\n        # could also compare to the system state, with:\n        # data = self.mmcore.getConfigData(ch.group, ch.config)\n        # if self.mmcore.getSystemStateCache().isConfigurationIncluded(data):\n        #     ...\n        if (ch.group, ch.config) != self.mmcore._last_config:  # noqa: SLF001\n            try:\n                self.mmcore.setConfig(ch.group, ch.config)\n            except Exception as e:\n                logger.warning(\"Failed to set channel. %s\", e)\n\n    def _set_event_z(self, event: MDAEvent) -&gt; None:\n        # skip if no Z stage device is found\n        if not self.mmcore.getFocusDevice():\n            logger.warning(\"No Z stage device found. Cannot set Z position.\")\n            return\n\n        p_idx = event.index.get(\"p\", None)\n        correction = self._z_correction.setdefault(p_idx, 0.0)\n        self.mmcore.setZPosition(cast(\"float\", event.z_pos) + correction)\n\n    def _set_event_slm_image(self, event: MDAEvent) -&gt; None:\n        if not event.slm_image:\n            return\n        core = self.mmcore\n        try:\n            # Get the SLM device\n            if not (\n                slm_device := event.slm_image.device or core.getSLMDevice()\n            ):  # pragma: no cover\n                raise ValueError(\"No SLM device found or specified.\")\n\n            # cast to numpy array\n            slm_array = np.asarray(event.slm_image)\n            # if it's a single value, we can just set all pixels to that value\n            if slm_array.ndim == 0:\n                value = slm_array.item()\n                if isinstance(value, bool):\n                    dev_name = core.getDeviceName(slm_device)\n                    on_value = _SLM_DEVICES_PIXEL_ON_VALUES.get(dev_name, 1)\n                    value = on_value if value else 0\n                core.setSLMPixelsTo(slm_device, int(value))\n            elif slm_array.size == 3:\n                # if it's a 3-valued array, we assume it's RGB\n                r, g, b = slm_array.astype(int)\n                core.setSLMPixelsTo(slm_device, r, g, b)\n            elif slm_array.ndim in (2, 3):\n                # if it's a 2D/3D array, we assume it's an image\n                # where 3D is RGB with shape (h, w, 3)\n                if slm_array.ndim == 3 and slm_array.shape[2] != 3:\n                    raise ValueError(  # pragma: no cover\n                        \"SLM image must be 2D or 3D with 3 channels (RGB).\"\n                    )\n                # convert boolean on/off values to pixel values\n                if slm_array.dtype == bool:\n                    dev_name = core.getDeviceName(slm_device)\n                    on_value = _SLM_DEVICES_PIXEL_ON_VALUES.get(dev_name, 1)\n                    slm_array = np.where(slm_array, on_value, 0).astype(np.uint8)\n                core.setSLMImage(slm_device, slm_array)\n            if event.slm_image.exposure:\n                core.setSLMExposure(slm_device, event.slm_image.exposure)\n        except Exception as e:\n            logger.warning(\"Failed to set SLM Image: %s\", e)\n\n    def _exec_event_slm_image(self, img: useq.SLMImage) -&gt; None:\n        if slm_device := (img.device or self.mmcore.getSLMDevice()):\n            try:\n                self.mmcore.displaySLMImage(slm_device)\n            except Exception as e:\n                logger.warning(\"Failed to set SLM Image: %s\", e)\n\n    def _update_config_device_props(self) -&gt; None:\n        # store devices/props that make up each config group for faster lookup\n        self._config_device_props.clear()\n        core = self.mmcore\n        for grp in core.getAvailableConfigGroups():\n            for preset in core.getAvailableConfigs(grp):\n                # ordered/unique list of (device, property) tuples for each group\n                self._config_device_props[grp] = tuple(\n                    {(i[0], i[1]): None for i in core.getConfigData(grp, preset)}\n                )\n\n    def _get_current_props(self, *groups: str) -&gt; tuple[PropertyValue, ...]:\n        \"\"\"Faster version of core.getConfigGroupState(group).\n\n        MMCore does some excess iteration that we want to avoid here. It calls\n        GetAvailableConfigs and then calls getConfigData for *every* preset in the\n        group, (not only the one being requested).  We go straight to cached data\n        for the group we want.\n        \"\"\"\n        return tuple(\n            {\n                \"dev\": dev,\n                \"prop\": prop,\n                \"val\": self.mmcore.getPropertyFromCache(dev, prop),\n            }\n            for group in groups\n            if (dev_props := self._config_device_props.get(group))\n            for dev, prop in dev_props\n        )\n</code></pre>"},{"location":"api/mda/#pymmcore_plus.mda._engine.MDAEngine.force_set_xy_position","title":"<code>force_set_xy_position: bool = force_set_xy_position</code>  <code>instance-attribute</code>","text":""},{"location":"api/mda/#pymmcore_plus.mda._engine.MDAEngine.restore_initial_state","title":"<code>restore_initial_state: bool | None = restore_initial_state</code>  <code>instance-attribute</code>","text":""},{"location":"api/mda/#pymmcore_plus.mda._engine.MDAEngine.use_hardware_sequencing","title":"<code>use_hardware_sequencing: bool = use_hardware_sequencing</code>  <code>instance-attribute</code>","text":""},{"location":"api/mda/#pymmcore_plus.mda._engine.MDAEngine.event_iterator","title":"<code>event_iterator(events: Iterable[MDAEvent]) -&gt; Iterator[MDAEvent]</code>","text":"<p>Event iterator that merges events for hardware sequencing if possible.</p> <p>This wraps <code>for event in events: ...</code> inside <code>MDARunner.run()</code> and combines sequenceable events into an instance of <code>SequencedEvent</code> if <code>self.use_hardware_sequencing</code> is <code>True</code>.</p> Source code in <code>pymmcore_plus/mda/_engine.py</code> <pre><code>def event_iterator(self, events: Iterable[MDAEvent]) -&gt; Iterator[MDAEvent]:\n    \"\"\"Event iterator that merges events for hardware sequencing if possible.\n\n    This wraps `for event in events: ...` inside `MDARunner.run()` and combines\n    sequenceable events into an instance of `SequencedEvent` if\n    `self.use_hardware_sequencing` is `True`.\n    \"\"\"\n    if not self.use_hardware_sequencing:\n        yield from events\n        return\n\n    yield from iter_sequenced_events(self.mmcore, events)\n</code></pre>"},{"location":"api/mda/#pymmcore_plus.mda._engine.MDAEngine.exec_event","title":"<code>exec_event(event: MDAEvent) -&gt; Iterable[PImagePayload]</code>","text":"<p>Execute an individual event and return the image data.</p> Source code in <code>pymmcore_plus/mda/_engine.py</code> <pre><code>def exec_event(self, event: MDAEvent) -&gt; Iterable[PImagePayload]:\n    \"\"\"Execute an individual event and return the image data.\"\"\"\n    action = getattr(event, \"action\", None)\n    core = self.mmcore\n    if isinstance(action, HardwareAutofocus):\n        # skip if no autofocus device is found\n        if not core.getAutoFocusDevice():\n            logger.warning(\"No autofocus device found. Cannot execute autofocus.\")\n            return\n\n        try:\n            # execute hardware autofocus\n            new_correction = self._execute_autofocus(action)\n            self._af_succeeded = True\n        except RuntimeError as e:\n            logger.warning(\"Hardware autofocus failed. %s\", e)\n            self._af_succeeded = False\n        else:\n            # store correction for this position index\n            p_idx = event.index.get(\"p\", None)\n            self._z_correction[p_idx] = new_correction + self._z_correction.get(\n                p_idx, 0.0\n            )\n        return\n\n    # don't try to execute any other action types. Mostly, this is just\n    # CustomAction, which is a user-defined action that the engine doesn't know how\n    # to handle.  But may include other actions in the future, and this ensures\n    # backwards compatibility.\n    if not isinstance(action, (AcquireImage, type(None))):\n        return\n\n    # if the autofocus was engaged at the start of the sequence AND autofocus action\n    # did not fail, re-engage it. NOTE: we need to do that AFTER the runner calls\n    # `setup_event`, so we can't do it inside the exec_event autofocus action above.\n    if self._af_was_engaged and self._af_succeeded:\n        core.enableContinuousFocus(True)\n\n    if isinstance(event, SequencedEvent):\n        yield from self.exec_sequenced_event(event)\n    else:\n        yield from self.exec_single_event(event)\n</code></pre>"},{"location":"api/mda/#pymmcore_plus.mda._engine.MDAEngine.exec_sequenced_event","title":"<code>exec_sequenced_event(event: SequencedEvent) -&gt; EventPayloadGenerator</code>","text":"<p>Execute a sequenced (triggered) event and return the image data.</p> <p>This method is not part of the PMDAEngine protocol (it is called by <code>exec_event</code>, which is part of the protocol), but it is made public in case a user wants to subclass this engine and override this method.</p> Source code in <code>pymmcore_plus/mda/_engine.py</code> <pre><code>def exec_sequenced_event(self, event: SequencedEvent) -&gt; EventPayloadGenerator:\n    \"\"\"Execute a sequenced (triggered) event and return the image data.\n\n    This method is not part of the PMDAEngine protocol (it is called by\n    `exec_event`, which *is* part of the protocol), but it is made public\n    in case a user wants to subclass this engine and override this method.\n    \"\"\"\n    n_events = len(event.events)\n    if t0 := event.metadata.get(\"runner_t0\"):\n        t0_ms = (time.perf_counter() - t0) * 1000\n    else:\n        t0_ms = 0.0\n\n    if event.slm_image is not None:\n        self._exec_event_slm_image(event.slm_image)\n\n    core = self.mmcore\n    n_channels = core.getNumberOfCameraChannels()\n\n    # Start sequence\n    # Note that the overload of startSequenceAcquisition that takes a camera\n    # label does NOT automatically initialize a circular buffer.  So if this call\n    # is changed to accept the camera in the future, that should be kept in mind.\n    core.startSequenceAcquisition(n_events, 0, True)\n    self.post_sequence_started(event)\n\n    if n_channels == 1:\n        yield from self._exec_single_camera_sequence(event, t0_ms)\n    else:\n        yield from self._exec_multi_camera_sequence(event, t0_ms, n_channels)\n</code></pre>"},{"location":"api/mda/#pymmcore_plus.mda._engine.MDAEngine.exec_single_event","title":"<code>exec_single_event(event: MDAEvent) -&gt; Iterator[PImagePayload]</code>","text":"<p>Execute a single (non-triggered) event and return the image data.</p> <p>This method is not part of the PMDAEngine protocol (it is called by <code>exec_event</code>, which is part of the protocol), but it is made public in case a user wants to subclass this engine and override this method.</p> Source code in <code>pymmcore_plus/mda/_engine.py</code> <pre><code>def exec_single_event(self, event: MDAEvent) -&gt; Iterator[PImagePayload]:\n    \"\"\"Execute a single (non-triggered) event and return the image data.\n\n    This method is not part of the PMDAEngine protocol (it is called by\n    `exec_event`, which *is* part of the protocol), but it is made public\n    in case a user wants to subclass this engine and override this method.\n    \"\"\"\n    if event.slm_image is not None:\n        self._exec_event_slm_image(event.slm_image)\n\n    mmcore = self.mmcore\n    try:\n        mmcore.snapImage()\n        # taking event time after snapImage includes exposure time\n        # not sure that's what we want, but it's currently consistent with the\n        # timing of the sequenced event runner (where Elapsed_Time_ms is taken after\n        # the image is acquired, not before the exposure starts)\n        t0 = event.metadata.get(\"runner_t0\") or time.perf_counter()\n        event_time_ms = (time.perf_counter() - t0) * 1000\n    except Exception as e:\n        logger.warning(\"Failed to snap image. %s\", e)\n        return\n    if not event.keep_shutter_open:\n        mmcore.setShutterOpen(False)\n\n    # most cameras will only have a single channel\n    # but Multi-camera may have multiple, and we need to retrieve a buffer for each\n    for cam in range(mmcore.getNumberOfCameraChannels()):\n        meta = self.get_frame_metadata(\n            event,\n            runner_time_ms=event_time_ms,\n            camera_device=mmcore.getPhysicalCameraDevice(cam),\n            include_position=self._include_frame_position_metadata is not False,\n        )\n        # Note, the third element is actually a MutableMapping, but mypy doesn't\n        # see TypedDict as a subclass of MutableMapping yet.\n        # https://github.com/python/mypy/issues/4976\n        yield ImagePayload(mmcore.getImage(cam), event, meta)  # type: ignore[misc]\n</code></pre>"},{"location":"api/mda/#pymmcore_plus.mda._engine.MDAEngine.get_frame_metadata","title":"<code>get_frame_metadata(event: MDAEvent, prop_values: tuple[PropertyValue, ...] | None = None, runner_time_ms: float = 0.0, include_position: bool = True, camera_device: str | None = None) -&gt; FrameMetaV1</code>","text":"Source code in <code>pymmcore_plus/mda/_engine.py</code> <pre><code>def get_frame_metadata(\n    self,\n    event: MDAEvent,\n    prop_values: tuple[PropertyValue, ...] | None = None,\n    runner_time_ms: float = 0.0,\n    include_position: bool = True,\n    camera_device: str | None = None,\n) -&gt; FrameMetaV1:\n    if prop_values is None and (ch := event.channel):\n        prop_values = self._get_current_props(ch.group)\n    else:\n        prop_values = ()\n    return frame_metadata(\n        self.mmcore,\n        cached=True,\n        runner_time_ms=runner_time_ms,\n        camera_device=camera_device,\n        property_values=prop_values,\n        mda_event=event,\n        include_position=include_position,\n    )\n</code></pre>"},{"location":"api/mda/#pymmcore_plus.mda._engine.MDAEngine.get_summary_metadata","title":"<code>get_summary_metadata(mda_sequence: MDASequence | None) -&gt; SummaryMetaV1</code>","text":"Source code in <code>pymmcore_plus/mda/_engine.py</code> <pre><code>def get_summary_metadata(self, mda_sequence: MDASequence | None) -&gt; SummaryMetaV1:\n    return summary_metadata(self.mmcore, mda_sequence=mda_sequence)\n</code></pre>"},{"location":"api/mda/#pymmcore_plus.mda._engine.MDAEngine.include_frame_position_metadata","title":"<code>include_frame_position_metadata() -&gt; IncludePositionArg</code>  <code>writable</code> <code>property</code>","text":"Source code in <code>pymmcore_plus/mda/_engine.py</code> <pre><code>@property\ndef include_frame_position_metadata(self) -&gt; IncludePositionArg:\n    return self._include_frame_position_metadata\n</code></pre>"},{"location":"api/mda/#pymmcore_plus.mda._engine.MDAEngine.mmcore","title":"<code>mmcore() -&gt; CMMCorePlus</code>  <code>property</code>","text":"<p>The <code>CMMCorePlus</code> instance to use for hardware control.</p> Source code in <code>pymmcore_plus/mda/_engine.py</code> <pre><code>@property\ndef mmcore(self) -&gt; CMMCorePlus:\n    \"\"\"The `CMMCorePlus` instance to use for hardware control.\"\"\"\n    if (mmc := self._mmcore_ref()) is None:  # pragma: no cover\n        raise RuntimeError(\"The CMMCorePlus instance has been garbage collected.\")\n    return mmc\n</code></pre>"},{"location":"api/mda/#pymmcore_plus.mda._engine.MDAEngine.post_sequence_started","title":"<code>post_sequence_started(event: SequencedEvent) -&gt; None</code>","text":"<p>Perform any actions after startSequenceAcquisition has been called.</p> <p>This method is available to subclasses in case they need to perform any actions after a hardware-triggered sequence has been started (i.e. after core.startSequenceAcquisition has been called).</p> <p>The default implementation does nothing.</p> Source code in <code>pymmcore_plus/mda/_engine.py</code> <pre><code>def post_sequence_started(self, event: SequencedEvent) -&gt; None:\n    \"\"\"Perform any actions after startSequenceAcquisition has been called.\n\n    This method is available to subclasses in case they need to perform any\n    actions after a hardware-triggered sequence has been started (i.e. after\n    core.startSequenceAcquisition has been called).\n\n    The default implementation does nothing.\n    \"\"\"\n</code></pre>"},{"location":"api/mda/#pymmcore_plus.mda._engine.MDAEngine.setup_event","title":"<code>setup_event(event: MDAEvent) -&gt; None</code>","text":"<p>Set the system hardware (XY, Z, channel, exposure) as defined in the event.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>MDAEvent</code> <p>The event to use for the Hardware config</p> required Source code in <code>pymmcore_plus/mda/_engine.py</code> <pre><code>def setup_event(self, event: MDAEvent) -&gt; None:\n    \"\"\"Set the system hardware (XY, Z, channel, exposure) as defined in the event.\n\n    Parameters\n    ----------\n    event : MDAEvent\n        The event to use for the Hardware config\n    \"\"\"\n    if isinstance(event, SequencedEvent):\n        self.setup_sequenced_event(event)\n    else:\n        self.setup_single_event(event)\n    self.mmcore.waitForSystem()\n</code></pre>"},{"location":"api/mda/#pymmcore_plus.mda._engine.MDAEngine.setup_sequence","title":"<code>setup_sequence(sequence: MDASequence) -&gt; SummaryMetaV1 | None</code>","text":"<p>Setup the hardware for the entire sequence.</p> Source code in <code>pymmcore_plus/mda/_engine.py</code> <pre><code>def setup_sequence(self, sequence: MDASequence) -&gt; SummaryMetaV1 | None:\n    \"\"\"Setup the hardware for the entire sequence.\"\"\"\n    # clear z_correction for new sequence\n    self._z_correction.clear()\n\n    if not (core := self._mmcore_ref()):  # pragma: no cover\n        from pymmcore_plus.core import CMMCorePlus\n\n        core = CMMCorePlus.instance()\n        self._mmcore_ref = weakref.ref(core)\n\n    # just in case a non-programmatic changes have been made in the meantime\n    # https://github.com/pymmcore-plus/pymmcore-plus/issues/503\n    core._last_config = (\"\", \"\")  # noqa: SLF001\n    core._last_xy_position.clear()  # noqa: SLF001\n\n    self._update_config_device_props()\n    # get if the autofocus is engaged at the start of the sequence\n    self._af_was_engaged = core.isContinuousFocusLocked()\n\n    # capture initial state if restoration is enabled\n    if self.restore_initial_state is None:\n        if fd := core.getFocusDevice():\n            self.restore_initial_state = (\n                core.getFocusDirection(fd) != FocusDirection.Unknown\n            )\n        else:\n            self.restore_initial_state = False\n\n    if self.restore_initial_state:\n        self._initial_state = self._capture_state()\n\n    if px_size := core.getPixelSizeUm():\n        self._update_grid_fov_sizes(px_size, sequence)\n\n    self._autoshutter_was_set = core.getAutoShutter()\n    return self.get_summary_metadata(mda_sequence=sequence)\n</code></pre>"},{"location":"api/mda/#pymmcore_plus.mda._engine.MDAEngine.setup_sequenced_event","title":"<code>setup_sequenced_event(event: SequencedEvent) -&gt; None</code>","text":"<p>Setup hardware for a sequenced (triggered) event.</p> <p>This method is not part of the PMDAEngine protocol (it is called by <code>setup_event</code>, which is part of the protocol), but it is made public in case a user wants to subclass this engine and override this method.</p> Source code in <code>pymmcore_plus/mda/_engine.py</code> <pre><code>def setup_sequenced_event(self, event: SequencedEvent) -&gt; None:\n    \"\"\"Setup hardware for a sequenced (triggered) event.\n\n    This method is not part of the PMDAEngine protocol (it is called by\n    `setup_event`, which *is* part of the protocol), but it is made public\n    in case a user wants to subclass this engine and override this method.\n    \"\"\"\n    core = self.mmcore\n\n    self._load_sequenced_event(event)\n\n    # this is probably not necessary.  loadSequenceEvent will have already\n    # set all the config properties individually/manually.  However, without\n    # the call below, we won't be able to query `core.getCurrentConfig()`\n    # not sure that's necessary; and this is here for tests to pass for now,\n    # but this could be removed.\n    self._set_event_channel(event)\n\n    if event.slm_image:\n        self._set_event_slm_image(event)\n\n    if core.isSequenceRunning():\n        self._await_sequence_acquisition()\n\n    # start sequences or set non-sequenced values\n    if event.x_sequence:\n        core.startXYStageSequence(core.getXYStageDevice())\n    else:\n        self._set_event_xy_position(event)\n\n    if event.z_sequence:\n        core.startStageSequence(core.getFocusDevice())\n    elif event.z_pos is not None:\n        self._set_event_z(event)\n\n    if event.exposure_sequence:\n        core.startExposureSequence(core.getCameraDevice())\n    elif event.exposure is not None:\n        core.setExposure(event.exposure)\n\n    if event.property_sequences:\n        for dev, prop in event.property_sequences:\n            core.startPropertySequence(dev, prop)\n</code></pre>"},{"location":"api/mda/#pymmcore_plus.mda._engine.MDAEngine.setup_single_event","title":"<code>setup_single_event(event: MDAEvent) -&gt; None</code>","text":"<p>Setup hardware for a single (non-sequenced) event.</p> <p>This method is not part of the PMDAEngine protocol (it is called by <code>setup_event</code>, which is part of the protocol), but it is made public in case a user wants to subclass this engine and override this method.</p> Source code in <code>pymmcore_plus/mda/_engine.py</code> <pre><code>def setup_single_event(self, event: MDAEvent) -&gt; None:\n    \"\"\"Setup hardware for a single (non-sequenced) event.\n\n    This method is not part of the PMDAEngine protocol (it is called by\n    `setup_event`, which *is* part of the protocol), but it is made public\n    in case a user wants to subclass this engine and override this method.\n    \"\"\"\n    if event.keep_shutter_open:\n        ...\n\n    self._set_event_xy_position(event)\n\n    if event.z_pos is not None:\n        self._set_event_z(event)\n    if event.slm_image is not None:\n        self._set_event_slm_image(event)\n\n    self._set_event_channel(event)\n\n    mmcore = self.mmcore\n    if event.exposure is not None:\n        try:\n            mmcore.setExposure(event.exposure)\n        except Exception as e:\n            logger.warning(\"Failed to set exposure. %s\", e)\n    if event.properties is not None:\n        try:\n            for dev, prop, value in event.properties:\n                mmcore.setProperty(dev, prop, value)\n        except Exception as e:\n            logger.warning(\"Failed to set properties. %s\", e)\n    if (\n        # (if autoshutter wasn't set at the beginning of the sequence\n        # then it never matters...)\n        self._autoshutter_was_set\n        # if we want to leave the shutter open after this event, and autoshutter\n        # is currently enabled...\n        and event.keep_shutter_open\n        and mmcore.getAutoShutter()\n    ):\n        # we have to disable autoshutter and open the shutter\n        mmcore.setAutoShutter(False)\n        mmcore.setShutterOpen(True)\n</code></pre>"},{"location":"api/mda/#pymmcore_plus.mda._engine.MDAEngine.teardown_event","title":"<code>teardown_event(event: MDAEvent) -&gt; None</code>","text":"<p>Teardown state of system (hardware, etc.) after <code>event</code>.</p> Source code in <code>pymmcore_plus/mda/_engine.py</code> <pre><code>def teardown_event(self, event: MDAEvent) -&gt; None:\n    \"\"\"Teardown state of system (hardware, etc.) after `event`.\"\"\"\n    # autoshutter was set at the beginning of the sequence, and this event\n    # doesn't want to leave the shutter open.  Re-enable autoshutter.\n    core = self.mmcore\n    if not event.keep_shutter_open and self._autoshutter_was_set:\n        core.setAutoShutter(True)\n    # FIXME: this may not be hitting as intended...\n    # https://github.com/pymmcore-plus/pymmcore-plus/pull/353#issuecomment-2159176491\n    if isinstance(event, SequencedEvent):\n        if event.exposure_sequence:\n            core.stopExposureSequence(core.getCameraDevice())\n        if event.x_sequence:\n            core.stopXYStageSequence(core.getXYStageDevice())\n        if event.z_sequence:\n            core.stopStageSequence(core.getFocusDevice())\n        for dev, prop in event.property_sequences:\n            core.stopPropertySequence(dev, prop)\n</code></pre>"},{"location":"api/mda/#pymmcore_plus.mda._engine.MDAEngine.teardown_sequence","title":"<code>teardown_sequence(sequence: MDASequence) -&gt; None</code>","text":"<p>Perform any teardown required after the sequence has been executed.</p> Source code in <code>pymmcore_plus/mda/_engine.py</code> <pre><code>def teardown_sequence(self, sequence: MDASequence) -&gt; None:\n    \"\"\"Perform any teardown required after the sequence has been executed.\"\"\"\n    # restore initial state if enabled and state was captured\n    if self.restore_initial_state and self._initial_state:\n        self._restore_initial_state()\n</code></pre>"},{"location":"api/metadata/","title":"Metadata","text":""},{"location":"api/metadata/#pymmcore_plus.Metadata","title":"<code>pymmcore_plus.Metadata</code>","text":"<p>Subclass of <code>pymmcore.Metadata</code> with a pythonic interface.</p> <p>This subclass fully implements a <code>collections.abc.Mapping</code> interface (i.e. it behaves like a Python <code>dict</code>).  It also adds a <code>json()</code> convenience method to convert to a JSON string.</p>"},{"location":"api/metadata/#pymmcore_plus.core._metadata.Metadata.clear","title":"<code>clear() -&gt; None</code>","text":""},{"location":"api/metadata/#pymmcore_plus.core._metadata.Metadata.copy","title":"<code>copy() -&gt; Metadata</code>","text":""},{"location":"api/metadata/#pymmcore_plus.core._metadata.Metadata.get","title":"<code>get(name: str, default: Any = _NULL) -&gt; Any</code>","text":""},{"location":"api/metadata/#pymmcore_plus.core._metadata.Metadata.items","title":"<code>items() -&gt; ItemsView[str, str]</code>","text":""},{"location":"api/metadata/#pymmcore_plus.core._metadata.Metadata.json","title":"<code>json() -&gt; str</code>","text":""},{"location":"api/metadata/#pymmcore_plus.core._metadata.Metadata.keys","title":"<code>keys() -&gt; KeysView[str]</code>","text":""},{"location":"api/metadata/#pymmcore_plus.core._metadata.Metadata.values","title":"<code>values() -&gt; ValuesView[str]</code>","text":""},{"location":"api/unicore/","title":"Experimental UniMMCore","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore","title":"<code>pymmcore_plus.experimental.unicore</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.CameraDevice","title":"<code>CameraDevice</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._camera.CameraDevice.STANDARD_PROPERTIES","title":"<code>STANDARD_PROPERTIES: ClassVar = MappingProxyType({Keyword.ActualInterval_ms: ('actual_interval_ms', float), Keyword.Binning: ('binning', int), Keyword.CameraID: ('camera_id', str), Keyword.CameraName: ('camera_name', str), Keyword.CCDTemperature: ('ccd_temperature', float), Keyword.CCDTemperatureSetPoint: ('ccd_temperature_set_point', float), Keyword.EMGain: ('em_gain', float), Keyword.Exposure: ('exposure', float), Keyword.Gain: ('gain', float), Keyword.Interval_ms: ('interval_ms', float), Keyword.Offset: ('offset', float), 'PixelFormat': ('pixel_format', PixelFormat), Keyword.ReadoutMode: ('readout_mode', str), Keyword.ReadoutTime: ('readout_time', float), Keyword.Metadata_ROI_X: ('roi_x', int), Keyword.Metadata_ROI_Y: ('roi_y', int)})</code>  <code>class-attribute</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._camera.CameraDevice.clear_roi","title":"<code>clear_roi() -&gt; None</code>","text":"<p>Reset the ROI to the full sensor frame.</p> <p>No-op by default (nothing was set, nothing to clear).</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._camera.CameraDevice.dtype","title":"<code>dtype() -&gt; DTypeLike</code>  <code>abstractmethod</code>","text":"<p>Return the data type of the image buffer.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._camera.CameraDevice.get_binning","title":"<code>get_binning() -&gt; int</code>","text":"<p>Get the binning factor for the camera.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._camera.CameraDevice.get_exposure","title":"<code>get_exposure() -&gt; float</code>  <code>abstractmethod</code>","text":"<p>Get the current exposure time in milliseconds.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._camera.CameraDevice.get_roi","title":"<code>get_roi() -&gt; tuple[int, int, int, int]</code>","text":"<p>Return the current ROI as <code>(x, y, width, height)</code>.</p> <p>The default implementation returns the full frame from <code>shape()</code>. Override in subclasses to support hardware ROI.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._camera.CameraDevice.register_standard_properties","title":"<code>register_standard_properties() -&gt; None</code>","text":"<p>Inspect the class for standard properties and register them.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._camera.CameraDevice.set_exposure","title":"<code>set_exposure(exposure: float) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Set the exposure time in milliseconds.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._camera.CameraDevice.set_roi","title":"<code>set_roi(x: int, y: int, width: int, height: int) -&gt; None</code>","text":"<p>Set the ROI.</p> <p>The default implementation raises <code>NotImplementedError</code>. Override in subclasses to support hardware ROI.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._camera.CameraDevice.shape","title":"<code>shape() -&gt; tuple[int, int] | tuple[int, int, int]</code>  <code>abstractmethod</code>","text":"<p>Return the shape of the current image buffer.</p> <p>This is used when querying Height, Width and number of components. If the camera is grayscale, it should return (height, width). If the camera is color, it should return (height, width, n_channels).</p> <p>If the camera supports ROI, this should return the ROI dimensions.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._camera.CameraDevice.start_sequence","title":"<code>start_sequence(n: int | None, get_buffer: Callable[[Sequence[int], DTypeLike], np.ndarray]) -&gt; Iterator[Mapping]</code>  <code>abstractmethod</code>","text":"<p>Start a sequence acquisition.</p> <p>This method should be implemented by the camera device adapter and should yield metadata for each acquired image. The implementation should call get_buffer() to get a buffer, fill it with image data, then yield the metadata for that image.</p> <p>The core will handle threading and synchronization.  This function may block.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int | None</code> <p>If an integer, this is the number of images to acquire. If None, the camera should acquire images indefinitely until stopped.</p> required <code>get_buffer</code> <code>Callable[[Sequence[int], DTypeLike], np.ndarray]</code> <p>A callable that returns a buffer for the camera to fill with image data. You should call this with the shape of the image and the dtype of the image data.  The core will produce a buffer of the requested shape and dtype, and you should fill it (in place) with the image data.</p> required <p>Yields:</p> Type Description <code>Mapping</code> <p>Metadata for each acquired image. This should be yielded after the corresponding buffer has been filled with image data.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.Device","title":"<code>Device</code>","text":"<p>ABC for all Devices.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._device_base.Device.busy","title":"<code>busy() -&gt; bool</code>","text":"<p>Return <code>True</code> if the device is busy.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._device_base.Device.core","title":"<code>core() -&gt; CMMCoreProxy</code>  <code>property</code>","text":"<p>The device may use this to access a restricted subset of the Core API.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._device_base.Device.description","title":"<code>description() -&gt; str</code>","text":"<p>Return a description of the device.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._device_base.Device.get_label","title":"<code>get_label() -&gt; str</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._device_base.Device.get_parent_label","title":"<code>get_parent_label() -&gt; str</code>","text":"<p>Return the label of the parent hub device, or empty string if none.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._device_base.Device.get_property_info","title":"<code>get_property_info(prop_name: str) -&gt; PropertyInfo</code>","text":"<p>Return the property controller for a property.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._device_base.Device.get_property_names","title":"<code>get_property_names() -&gt; KeysView[str]</code>","text":"<p>Return the names of the properties.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._device_base.Device.get_property_value","title":"<code>get_property_value(prop_name: str) -&gt; Any</code>","text":"<p>Return the value of a property.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._device_base.Device.has_property","title":"<code>has_property(prop_name: str) -&gt; bool</code>","text":"<p>Return <code>True</code> if the device has a property with the given name.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._device_base.Device.initialize","title":"<code>initialize() -&gt; None</code>","text":"<p>Initialize the device.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._device_base.Device.is_property_read_only","title":"<code>is_property_read_only(prop_name: str) -&gt; bool</code>","text":"<p>Return <code>True</code> if the property is read-only.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._device_base.Device.is_property_sequenceable","title":"<code>is_property_sequenceable(prop_name: str) -&gt; bool</code>","text":"<p>Return <code>True</code> if the property is sequenceable.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._device_base.Device.load_property_sequence","title":"<code>load_property_sequence(prop_name: str, sequence: Sequence[Any]) -&gt; None</code>","text":"<p>Load a sequence into a property.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._device_base.Device.name","title":"<code>name() -&gt; str</code>  <code>classmethod</code>","text":"<p>Return the name of the device.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._device_base.Device.register_property","title":"<code>register_property(name: str, *, default_value: TProp | None = None, getter: Callable[[TDev], TProp] | None = None, setter: Callable[[TDev, TProp], None] | None = None, limits: tuple[int | float, int | float] | None = None, sequence_max_length: int = 0, allowed_values: Sequence[TProp] | None = None, is_read_only: bool = False, is_pre_init: bool = False, property_type: PropArg = None, sequence_loader: Callable[[TDev, Sequence[TProp]], None] | None = None, sequence_starter: Callable[[TDev], None] | None = None, sequence_stopper: Callable[[TDev], None] | None = None) -&gt; None</code>","text":"<p>Manually register a property.</p> <p>This is an alternative to using the <code>@pymm_property</code> decorator.  It can be used to register properties that are not defined in the class body.  This is useful for pure \"user-side\" properties that are not used by the adapter, but which the adapter may want to access (such as a preference or a configuration setting that doesn't affect the device's behavior, but which the adapter may want to read).</p> <p>Properties defined this way are not accessible as class attributes.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._device_base.Device.set_parent_label","title":"<code>set_parent_label(parent_label: str) -&gt; None</code>","text":"<p>Set the label of the parent hub device.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._device_base.Device.set_property_allowed_values","title":"<code>set_property_allowed_values(prop_name: str, allowed_values: Sequence[Any]) -&gt; None</code>","text":"<p>Set the allowed values of a property.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._device_base.Device.set_property_limits","title":"<code>set_property_limits(prop_name: str, limits: tuple[float, float] | None) -&gt; None</code>","text":"<p>Set the limits of a property.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._device_base.Device.set_property_sequence_max_length","title":"<code>set_property_sequence_max_length(prop_name: str, max_length: int) -&gt; None</code>","text":"<p>Set the sequence max length of a property.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._device_base.Device.set_property_value","title":"<code>set_property_value(prop_name: str, value: Any) -&gt; None</code>","text":"<p>Set the value of a property.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._device_base.Device.shutdown","title":"<code>shutdown() -&gt; None</code>","text":"<p>Shutdown the device.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._device_base.Device.start_property_sequence","title":"<code>start_property_sequence(prop_name: str) -&gt; None</code>","text":"<p>Start a sequence of a property.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._device_base.Device.stop_property_sequence","title":"<code>stop_property_sequence(prop_name: str) -&gt; None</code>","text":"<p>Stop a sequence of a property.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._device_base.Device.type","title":"<code>type() -&gt; DeviceType</code>  <code>classmethod</code>","text":"<p>Return the type of the device.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.GenericDevice","title":"<code>GenericDevice</code>","text":"<p>Generic device API, e.g. for devices that don't fit into other categories.</p> <p>Generic Devices generally only use the device property interface.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.HubDevice","title":"<code>HubDevice</code>","text":"<p>ABC for Hub devices that can have peripheral devices attached.</p> <p>Hub devices represent a central device (e.g., a controller) that can have multiple peripheral devices attached to it. Examples include multi-channel controllers, or devices that manage multiple sub-devices.</p> <p>To implement a Hub device, simply override <code>get_installed_peripherals()</code>:</p> <pre><code>class MyHub(HubDevice):\n    def get_installed_peripherals(self) -&gt; Sequence[tuple[str, str]]:\n        return [\n            (\"Motor1\", \"First motor controller\"),\n            (\"Motor2\", \"Second motor controller\"),\n        ]\n</code></pre> <p>If your hub needs to perform expensive detection (e.g., scanning a bus), implement caching inside your <code>get_installed_peripherals()</code> method.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._hub.HubDevice.get_installed_peripherals","title":"<code>get_installed_peripherals() -&gt; Sequence[tuple[str, str]]</code>","text":"<p>Return information about installed peripheral devices.</p> <p>Override this method to return a sequence of <code>tuple[str, str]</code> objects describing all devices that can be loaded as peripherals of this hub.</p> <p>Returns:</p> Type Description <code>Sequence[tuple[str, str]]</code> <p>A sequence of (name, description) tuples for each available peripheral. The name MUST be the name of a class, importable from the same module as this hub.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.PropertyInfo","title":"<code>PropertyInfo</code>  <code>dataclass</code>","text":"<p>State of a property of a device.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the property.</p> <code>default_value</code> <code>TProp, optional</code> <p>The default value of the property, by default None.</p> <code>last_value</code> <code>TProp, optional</code> <p>The last value seen from the device, by default None.</p> <code>limits</code> <code>tuple[int | float, int | float], optional</code> <p>The minimum and maximum values of the property, by default None.</p> <code>sequence_max_length</code> <code>int</code> <p>The maximum length of a sequence of property values.</p> <code>description</code> <code>str, optional</code> <p>A description of the property, by default None.</p> <code>type</code> <code>PropertyType</code> <p>The type of the property.</p> <code>allowed_values</code> <code>Sequence[TProp], optional</code> <p>The allowed values of the property, by default None.</p> <code>is_read_only</code> <code>bool</code> <p>Whether the property is read-only.</p> <code>is_pre_init</code> <code>bool</code> <p>Whether the property must be set before initialization.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._properties.PropertyInfo.allowed_values","title":"<code>allowed_values: Sequence[TProp] | None = None</code>  <code>class-attribute</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._properties.PropertyInfo.default_value","title":"<code>default_value: TProp | None = None</code>  <code>class-attribute</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._properties.PropertyInfo.description","title":"<code>description: str | None = None</code>  <code>class-attribute</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._properties.PropertyInfo.is_pre_init","title":"<code>is_pre_init: bool = False</code>  <code>class-attribute</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._properties.PropertyInfo.is_read_only","title":"<code>is_read_only: bool | None = None</code>  <code>class-attribute</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._properties.PropertyInfo.last_value","title":"<code>last_value: TProp | None = None</code>  <code>class-attribute</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._properties.PropertyInfo.limits","title":"<code>limits: tuple[int | float, int | float] | None = None</code>  <code>class-attribute</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._properties.PropertyInfo.name","title":"<code>name: str</code>  <code>class-attribute</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._properties.PropertyInfo.sequence_max_length","title":"<code>sequence_max_length: int = 0</code>  <code>class-attribute</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._properties.PropertyInfo.type","title":"<code>type: PropertyType = PropertyType.Undef</code>  <code>class-attribute</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._properties.PropertyInfo.is_sequenceable","title":"<code>is_sequenceable() -&gt; bool</code>  <code>property</code>","text":"<p>Return True if the property is sequenceable.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._properties.PropertyInfo.number_of_allowed_values","title":"<code>number_of_allowed_values() -&gt; int</code>  <code>property</code>","text":"<p>Return the number of allowed values.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.SLMDevice","title":"<code>SLMDevice</code>","text":"<p>ABC for Spatial Light Modulator (SLM) devices.</p> <p>SLM devices are capable of displaying images.  They are expected to represent a rectangular grid of pixels that can be either 8-bit or 32-bit.  Illumination (light source on or off) is logically independent of displaying the image.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._slm.SLMDevice.display_image","title":"<code>display_image() -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Command the SLM to display the loaded image.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._slm.SLMDevice.dtype","title":"<code>dtype() -&gt; DTypeLike</code>  <code>abstractmethod</code>","text":"<p>Return the data type of the image buffer.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._slm.SLMDevice.get_exposure","title":"<code>get_exposure() -&gt; float</code>  <code>abstractmethod</code>","text":"<p>Find out the exposure interval of an SLM.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._slm.SLMDevice.get_image","title":"<code>get_image() -&gt; np.ndarray</code>","text":"<p>Get the current image from the SLM device adapter.</p> <p>This is useful for verifying that the image was set correctly.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._slm.SLMDevice.get_sequence_max_length","title":"<code>get_sequence_max_length() -&gt; int</code>","text":"<p>Return the maximum length of an image sequence that can be uploaded.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._slm.SLMDevice.send_sequence","title":"<code>send_sequence(sequence: Sequence[np.ndarray]) -&gt; None</code>","text":"<p>Load a sequence of images to the SLM.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._slm.SLMDevice.set_exposure","title":"<code>set_exposure(interval_ms: float) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Command the SLM to turn off after a specified interval.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._slm.SLMDevice.set_image","title":"<code>set_image(pixels: np.ndarray) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Load the image into the SLM device adapter.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._slm.SLMDevice.shape","title":"<code>shape() -&gt; tuple[int, ...]</code>  <code>abstractmethod</code>","text":"<p>Return the shape of the SLM image buffer.</p> <p>This is used when querying Width, Height, and number of components. If the SLM is grayscale, it should return (width, height). If the SLM is color, it should return (width, height, n_channels).</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._slm.SLMDevice.start_sequence","title":"<code>start_sequence() -&gt; None</code>","text":"<p>Start a sequence of images on the SLM.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._slm.SLMDevice.stop_sequence","title":"<code>stop_sequence() -&gt; None</code>","text":"<p>Stop a sequence of images on the SLM.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.ShutterDevice","title":"<code>ShutterDevice</code>","text":"<p>Shutter device API, e.g. for physical shutters or electronic shutter control.</p> <p>Or any 2-state device that can be either open or closed.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._shutter.ShutterDevice.get_open","title":"<code>get_open() -&gt; bool</code>  <code>abstractmethod</code>","text":"<p>Return True if the shutter is open, False if it is closed.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._shutter.ShutterDevice.set_open","title":"<code>set_open(open: bool) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Set the shutter to open or closed.</p> <p>Parameters:</p> Name Type Description Default <code>open</code> <code>bool</code> <p>True to open the shutter, False to close it.</p> required"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.SimpleCameraDevice","title":"<code>SimpleCameraDevice</code>","text":"<p>A convenience subclass of <code>CameraDevice</code> for simple/simulated cameras.</p> <p>Instead of implementing <code>start_sequence()</code> and <code>shape()</code> directly, subclasses only need to implement:</p> <ul> <li><code>sensor_shape()</code>: the full (height, width) of the sensor</li> <li><code>snap(buffer)</code>: fill the provided full-frame buffer with image   data and return metadata.  The buffer is always sized to   <code>sensor_shape()</code>.  If a ROI is active, cropping is handled   automatically by this base class.</li> </ul> <p>Software ROI (<code>set_roi</code> / <code>clear_roi</code>) works out of the box.</p> <p>.. warning::    This class is not recommended for real hardware cameras that need    efficient ring-buffer or hardware-triggered acquisition.  For those,    use subclass <code>CameraDevice</code> directly and implement <code>start_sequence()</code>.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._camera.SimpleCameraDevice.clear_roi","title":"<code>clear_roi() -&gt; None</code>","text":"<p>Reset the ROI to the full sensor frame.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._camera.SimpleCameraDevice.get_roi","title":"<code>get_roi() -&gt; tuple[int, int, int, int]</code>","text":"<p>Return the current ROI as <code>(x, y, width, height)</code>.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._camera.SimpleCameraDevice.sensor_shape","title":"<code>sensor_shape() -&gt; tuple[int, int] | tuple[int, int, int]</code>  <code>abstractmethod</code>","text":"<p>Return the full sensor shape <code>(height, width[, n_channels])</code>.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._camera.SimpleCameraDevice.set_roi","title":"<code>set_roi(x: int, y: int, width: int, height: int) -&gt; None</code>","text":"<p>Set the software ROI, validating bounds against the sensor shape.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._camera.SimpleCameraDevice.shape","title":"<code>shape() -&gt; tuple[int, int] | tuple[int, int, int]</code>","text":"<p>Return the current image shape, accounting for any active ROI.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._camera.SimpleCameraDevice.snap","title":"<code>snap(buffer: np.ndarray) -&gt; Mapping</code>  <code>abstractmethod</code>","text":"<p>Snap a single image into the provided full-frame buffer.</p> <p>Parameters:</p> Name Type Description Default <code>buffer</code> <code>np.ndarray</code> <p>Pre-allocated buffer shaped to <code>sensor_shape()</code>. Must be filled with full-frame image data every time.</p> required <p>Returns:</p> Type Description <code>Mapping</code> <p>Metadata for the acquired image.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._camera.SimpleCameraDevice.start_sequence","title":"<code>start_sequence(n: int | None, get_buffer: Callable[[Sequence[int], DTypeLike], np.ndarray]) -&gt; Iterator[Mapping]</code>","text":"<p>Loop over <code>snap()</code>, cropping to the active ROI if set.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.StageDevice","title":"<code>StageDevice</code>","text":"<p>ABC for Stage devices.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._stage.StageDevice.get_focus_direction","title":"<code>get_focus_direction() -&gt; FocusDirection</code>","text":"<p>Returns the focus direction of the stage.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._stage.StageDevice.get_position_um","title":"<code>get_position_um() -&gt; float</code>  <code>abstractmethod</code>","text":"<p>Returns the current position of the stage in microns.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._stage.StageDevice.is_continuous_focus_drive","title":"<code>is_continuous_focus_drive() -&gt; bool</code>","text":"<p>Return True if positions can be set while continuous focus runs.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._stage.StageDevice.is_linear_sequenceable","title":"<code>is_linear_sequenceable() -&gt; bool</code>","text":"<p>Return True if the stage supports linear sequences.</p> <p>A linear sequence is defined by a step size and number of slices.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._stage.StageDevice.set_adapter_origin_um","title":"<code>set_adapter_origin_um(newZUm: float) -&gt; None</code>","text":"<p>Enable software translation of coordinates.</p> <p>The current position of the stage becomes Z = newZUm. Only some stages support this functionality; it is recommended that set_origin() be used instead where available.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._stage.StageDevice.set_focus_direction","title":"<code>set_focus_direction(sign: int) -&gt; None</code>","text":"<p>Sets the focus direction of the stage.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._stage.StageDevice.set_linear_sequence","title":"<code>set_linear_sequence(dZ_um: float, nSlices: int) -&gt; None</code>","text":"<p>Load a linear sequence defined by step size and number of slices.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._stage.StageDevice.set_position_um","title":"<code>set_position_um(val: float) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Set the position of the stage in microns.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._stage.StageDevice.set_relative_position_um","title":"<code>set_relative_position_um(d: float) -&gt; None</code>","text":"<p>Move the stage by a relative amount.</p> <p>Can be overridden for more efficient implementations.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.StateDevice","title":"<code>StateDevice</code>","text":"<p>State device API, e.g. filter wheel, objective turret, etc.</p> <p>A state device is a device that at any point in time is in a single state out of a list of possible states, like a filter wheel, an objective turret, etc.  The interface contains functions to get and set the state, to give states human readable labels, and functions to make it possible to treat the state device as a shutter.</p> <p>In terms of implementation, this base class provides the basic functionality by presenting state and label as properties, which it keeps in sync with the underlying device.</p> <p>Parameters:</p> Name Type Description Default <code>state_labels</code> <code>Mapping[int, str] | Iterable[tuple[int, str]]</code> <p>A mapping (or iterable of 2-tuples) of integer state indices to string labels.</p> required"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._state.StateDevice.assign_label_to_position","title":"<code>assign_label_to_position(pos: int, label: str) -&gt; None</code>","text":"<p>Assign a User-defined label to a position.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._state.StateDevice.from_count","title":"<code>from_count(count: int) -&gt; Self</code>  <code>classmethod</code>","text":"<p>Simplified constructor with just a number of states.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._state.StateDevice.get_position_for_label","title":"<code>get_position_for_label(label: str) -&gt; int</code>","text":"<p>Return the position corresponding to the provided label.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._state.StateDevice.get_state","title":"<code>get_state() -&gt; int</code>  <code>abstractmethod</code>","text":"<p>Get the current state of the device (integer index).</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._state.StateDevice.register_standard_properties","title":"<code>register_standard_properties() -&gt; None</code>","text":"<p>Inspect the class for standard properties and register them.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._state.StateDevice.set_position_or_label","title":"<code>set_position_or_label(pos_or_label: int | str) -&gt; None</code>","text":"<p>Set the position of the device by index or label.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._state.StateDevice.set_state","title":"<code>set_state(position: int) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Set the state of the device (integer index).</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.UniMMCore","title":"<code>UniMMCore</code>","text":"<p>Unified Core object that first checks for python, then C++ devices.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.load_py_device","title":"<code>load_py_device = loadPyDevice</code>  <code>class-attribute</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.clearCircularBuffer","title":"<code>clearCircularBuffer() -&gt; None</code>","text":"<p>Clear all images from the circular buffer.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.clearROI","title":"<code>clearROI() -&gt; None</code>","text":"<p>Clear the current region of interest (ROI) for the camera.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.defineConfig","title":"<code>defineConfig(groupName: str, configName: str, deviceLabel: str | None = None, propName: str | None = None, value: Any | None = None) -&gt; None</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.defineConfigGroup","title":"<code>defineConfigGroup(groupName: str) -&gt; None</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.defineStateLabel","title":"<code>defineStateLabel(stateDeviceLabel: DeviceLabel | str, state: int, label: str) -&gt; None</code>","text":"<p>Define a label for the specific state.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.deleteConfig","title":"<code>deleteConfig(groupName: str, configName: str, deviceLabel: str | None = None, propName: str | None = None) -&gt; None</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.deleteConfigGroup","title":"<code>deleteConfigGroup(groupName: str) -&gt; None</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.deviceBusy","title":"<code>deviceBusy(label: DeviceLabel | str) -&gt; bool</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.deviceTypeBusy","title":"<code>deviceTypeBusy(devType: int) -&gt; bool</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.displaySLMImage","title":"<code>displaySLMImage(slmLabel: DeviceLabel | str | None = None) -&gt; None</code>","text":"<p>Command the SLM to display the loaded image.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getAllowedPropertyValues","title":"<code>getAllowedPropertyValues(label: DeviceLabel | str, propName: PropertyName | str) -&gt; tuple[str, ...]</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getBufferFreeCapacity","title":"<code>getBufferFreeCapacity() -&gt; int</code>","text":"<p>Get the number of free slots in the circular buffer.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getBufferTotalCapacity","title":"<code>getBufferTotalCapacity() -&gt; int</code>","text":"<p>Get the total capacity of the circular buffer.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getBytesPerPixel","title":"<code>getBytesPerPixel() -&gt; int</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getCameraChannelName","title":"<code>getCameraChannelName(channelNr: int) -&gt; str</code>","text":"<p>Get the name of the camera channel.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getCameraDevice","title":"<code>getCameraDevice() -&gt; DeviceLabel | Literal['']</code>","text":"<p>Returns the label of the currently selected camera device.</p> <p>Returns empty string if no camera device is selected.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getCircularBufferMemoryFootprint","title":"<code>getCircularBufferMemoryFootprint() -&gt; int</code>","text":"<p>Get the circular buffer memory footprint in MB.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getConfigData","title":"<code>getConfigData(configGroup: str, configName: str, *, native: bool = False) -&gt; Configuration | pymmcore.Configuration</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getConfigGroupState","title":"<code>getConfigGroupState(group: str, *, native: bool = False) -&gt; Configuration | pymmcore.Configuration</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getConfigGroupStateFromCache","title":"<code>getConfigGroupStateFromCache(group: str, *, native: bool = False) -&gt; Configuration | pymmcore.Configuration</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getConfigState","title":"<code>getConfigState(group: str, config: str, *, native: bool = False) -&gt; Configuration | pymmcore.Configuration</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getCurrentConfig","title":"<code>getCurrentConfig(groupName: str) -&gt; ConfigPresetName | Literal['']</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getCurrentConfigFromCache","title":"<code>getCurrentConfigFromCache(groupName: str) -&gt; ConfigPresetName | Literal['']</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getDeviceDelayMs","title":"<code>getDeviceDelayMs(label: DeviceLabel | str) -&gt; float</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getDeviceDescription","title":"<code>getDeviceDescription(label: DeviceLabel | str) -&gt; str</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getDeviceInitializationState","title":"<code>getDeviceInitializationState(label: str) -&gt; DeviceInitializationState</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getDeviceLibrary","title":"<code>getDeviceLibrary(label: DeviceLabel | str) -&gt; AdapterName</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getDeviceName","title":"<code>getDeviceName(label: DeviceLabel | str) -&gt; DeviceName</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getDevicePropertyNames","title":"<code>getDevicePropertyNames(label: DeviceLabel | str) -&gt; tuple[PropertyName, ...]</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getDeviceType","title":"<code>getDeviceType(label: str) -&gt; DeviceType</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getExposure","title":"<code>getExposure(cameraLabel: DeviceLabel | str | None = None) -&gt; float</code>","text":"<p>Get the exposure time in milliseconds.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getExposureSequenceMaxLength","title":"<code>getExposureSequenceMaxLength(cameraLabel: DeviceLabel | str) -&gt; int</code>","text":"<p>Get the maximum length of the exposure sequence.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getFocusDevice","title":"<code>getFocusDevice() -&gt; DeviceLabel | Literal['']</code>","text":"<p>Return the current Focus Device.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getFocusDirection","title":"<code>getFocusDirection(stageLabel: DeviceLabel | str) -&gt; FocusDirection</code>","text":"<p>Get the current focus direction of the Z stage.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getImage","title":"<code>getImage(numChannel: int | None = None, *, fix: bool = True) -&gt; np.ndarray</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getImageBitDepth","title":"<code>getImageBitDepth() -&gt; int</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getImageBufferSize","title":"<code>getImageBufferSize() -&gt; int</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getImageHeight","title":"<code>getImageHeight() -&gt; int</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getImageWidth","title":"<code>getImageWidth() -&gt; int</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getInstalledDeviceDescription","title":"<code>getInstalledDeviceDescription(hubLabel: DeviceLabel | str, peripheralLabel: DeviceName | str) -&gt; str</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getInstalledDevices","title":"<code>getInstalledDevices(hubLabel: DeviceLabel | str) -&gt; tuple[DeviceName, ...]</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getLastImage","title":"<code>getLastImage(*, out: np.ndarray | None = None) -&gt; np.ndarray</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getLastImageMD","title":"<code>getLastImageMD(*args: Any, out: np.ndarray | None = None) -&gt; np.ndarray</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getLoadedDevices","title":"<code>getLoadedDevices() -&gt; tuple[DeviceLabel, ...]</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getLoadedDevicesOfType","title":"<code>getLoadedDevicesOfType(devType: int) -&gt; tuple[DeviceLabel, ...]</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getLoadedPeripheralDevices","title":"<code>getLoadedPeripheralDevices(hubLabel: DeviceLabel | str) -&gt; tuple[DeviceLabel, ...]</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getNBeforeLastImageMD","title":"<code>getNBeforeLastImageMD(n: int, md: pymmcore.Metadata, /, *, out: np.ndarray | None = None) -&gt; np.ndarray</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getNumberOfCameraChannels","title":"<code>getNumberOfCameraChannels() -&gt; int</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getNumberOfComponents","title":"<code>getNumberOfComponents() -&gt; int</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getNumberOfStates","title":"<code>getNumberOfStates(stateDeviceLabel: DeviceLabel | str) -&gt; int</code>","text":"<p>Return the total number of available positions (states).</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getParentLabel","title":"<code>getParentLabel(peripheralLabel: DeviceLabel | str) -&gt; DeviceLabel | Literal['']</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getPixelSizeAffine","title":"<code>getPixelSizeAffine(cached: bool = False) -&gt; AffineTuple</code>","text":"<p>Get the pixel size affine transformation matrix.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getPixelSizeUm","title":"<code>getPixelSizeUm(cached: bool = False) -&gt; float</code>","text":"<p>Get the pixel size in micrometers.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getPosition","title":"<code>getPosition(stageLabel: str | None = None) -&gt; float</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getProperty","title":"<code>getProperty(label: DeviceLabel | str, propName: PropertyName | str) -&gt; Any</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getPropertyFromCache","title":"<code>getPropertyFromCache(deviceLabel: DeviceLabel | str, propName: PropertyName | str) -&gt; Any</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getPropertyLowerLimit","title":"<code>getPropertyLowerLimit(label: DeviceLabel | str, propName: PropertyName | str) -&gt; float</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getPropertySequenceMaxLength","title":"<code>getPropertySequenceMaxLength(label: DeviceLabel | str, propName: PropertyName | str) -&gt; int</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getPropertyType","title":"<code>getPropertyType(label: str, propName: str) -&gt; PropertyType</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getPropertyUpperLimit","title":"<code>getPropertyUpperLimit(label: DeviceLabel | str, propName: PropertyName | str) -&gt; float</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getROI","title":"<code>getROI(label: DeviceLabel | str = '') -&gt; list[int]</code>","text":"<p>Get the current region of interest (ROI) for the camera.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getRemainingImageCount","title":"<code>getRemainingImageCount() -&gt; int</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getSLMBytesPerPixel","title":"<code>getSLMBytesPerPixel(slmLabel: DeviceLabel | str | None = None) -&gt; int</code>","text":"<p>Returns the number of bytes per pixel for the SLM.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getSLMDevice","title":"<code>getSLMDevice() -&gt; DeviceLabel | Literal['']</code>","text":"<p>Returns the label of the currently selected SLM device.</p> <p>Returns empty string if no SLM device is selected.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getSLMExposure","title":"<code>getSLMExposure(slmLabel: DeviceLabel | str | None = None) -&gt; float</code>","text":"<p>Find out the exposure interval of an SLM.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getSLMHeight","title":"<code>getSLMHeight(slmLabel: DeviceLabel | str | None = None) -&gt; int</code>","text":"<p>Returns the height of the SLM in pixels.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getSLMImage","title":"<code>getSLMImage(slmLabel: DeviceLabel | str | None = None) -&gt; np.ndarray</code>","text":"<p>Get the current image from the SLM device.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getSLMNumberOfComponents","title":"<code>getSLMNumberOfComponents(slmLabel: DeviceLabel | str | None = None) -&gt; int</code>","text":"<p>Returns the number of color components (channels) in the SLM.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getSLMSequenceMaxLength","title":"<code>getSLMSequenceMaxLength(slmLabel: DeviceLabel | str) -&gt; int</code>","text":"<p>Get the maximum length of an image sequence that can be uploaded.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getSLMWidth","title":"<code>getSLMWidth(slmLabel: DeviceLabel | str | None = None) -&gt; int</code>","text":"<p>Returns the width of the SLM in pixels.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getShutterDevice","title":"<code>getShutterDevice() -&gt; DeviceLabel | Literal['']</code>","text":"<p>Returns the label of the currently selected Shutter device.</p> <p>Returns empty string if no Shutter device is selected.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getShutterOpen","title":"<code>getShutterOpen(shutterLabel: DeviceLabel | str | None = None) -&gt; bool</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getStageSequenceMaxLength","title":"<code>getStageSequenceMaxLength(stageLabel: DeviceLabel | str) -&gt; int</code>","text":"<p>Gets the maximum length of a stage's position sequence.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getState","title":"<code>getState(stateDeviceLabel: DeviceLabel | str) -&gt; int</code>","text":"<p>Return the current state (position) on the specific device.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getStateFromLabel","title":"<code>getStateFromLabel(stateDeviceLabel: DeviceLabel | str, stateLabel: str) -&gt; int</code>","text":"<p>Obtain the state for a given label.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getStateLabel","title":"<code>getStateLabel(stateDeviceLabel: DeviceLabel | str) -&gt; StateLabel</code>","text":"<p>Return the current state as the label (string).</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getStateLabels","title":"<code>getStateLabels(stateDeviceLabel: DeviceLabel | str) -&gt; tuple[StateLabel, ...]</code>","text":"<p>Return labels for all states.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getSystemState","title":"<code>getSystemState(*, native: bool = False) -&gt; Configuration | pymmcore.Configuration</code>","text":"<p>Return the entire system state including Python device properties.</p> <p>This method iterates through all devices (C++ and Python) and returns all property values. Following the C++ implementation pattern.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getSystemStateCache","title":"<code>getSystemStateCache(*, native: bool = False) -&gt; Configuration | pymmcore.Configuration</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getXPosition","title":"<code>getXPosition(xyStageLabel: DeviceLabel | str = '') -&gt; float</code>","text":"<p>Obtains the current position of the X axis of the XY stage in microns.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getXYPosition","title":"<code>getXYPosition(xyStageLabel: DeviceLabel | str = '') -&gt; tuple[float, float]</code>","text":"<p>Obtains the current position of the XY stage in microns.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getXYStageDevice","title":"<code>getXYStageDevice() -&gt; DeviceLabel | Literal['']</code>","text":"<p>Returns the label of the currently selected XYStage device.</p> <p>Returns empty string if no XYStage device is selected.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getXYStageSequenceMaxLength","title":"<code>getXYStageSequenceMaxLength(xyStageLabel: DeviceLabel | str) -&gt; int</code>","text":"<p>Gets the maximum length of an XY stage's position sequence.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.getYPosition","title":"<code>getYPosition(xyStageLabel: DeviceLabel | str = '') -&gt; float</code>","text":"<p>Obtains the current position of the Y axis of the XY stage in microns.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.hasProperty","title":"<code>hasProperty(label: DeviceLabel | str, propName: PropertyName | str) -&gt; bool</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.hasPropertyLimits","title":"<code>hasPropertyLimits(label: DeviceLabel | str, propName: PropertyName | str) -&gt; bool</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.home","title":"<code>home(xyOrZStageLabel: DeviceLabel | str) -&gt; None</code>","text":"<p>Perform a hardware homing operation for an XY or focus/Z stage.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.initializeAllDevices","title":"<code>initializeAllDevices() -&gt; None</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.initializeCircularBuffer","title":"<code>initializeCircularBuffer() -&gt; None</code>","text":"<p>Initialize the circular buffer.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.initializeDevice","title":"<code>initializeDevice(label: DeviceLabel | str) -&gt; None</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.isBufferOverflowed","title":"<code>isBufferOverflowed() -&gt; bool</code>","text":"<p>Check if the circular buffer has overflowed.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.isContinuousFocusDrive","title":"<code>isContinuousFocusDrive(stageLabel: DeviceLabel | str) -&gt; bool</code>","text":"<p>Check if a stage has continuous focusing capability.</p> <p>Returns True if positions can be set while continuous focus runs.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.isExposureSequenceable","title":"<code>isExposureSequenceable(cameraLabel: DeviceLabel | str) -&gt; bool</code>","text":"<p>Check if the camera supports exposure sequences.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.isPropertyPreInit","title":"<code>isPropertyPreInit(label: DeviceLabel | str, propName: PropertyName | str) -&gt; bool</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.isPropertyReadOnly","title":"<code>isPropertyReadOnly(label: DeviceLabel | str, propName: PropertyName | str) -&gt; bool</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.isPropertySequenceable","title":"<code>isPropertySequenceable(label: DeviceLabel | str, propName: PropertyName | str) -&gt; bool</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.isPyDevice","title":"<code>isPyDevice(label: DeviceLabel | str) -&gt; bool</code>","text":"<p>Returns True if the specified device label corresponds to a Python device.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.isSequenceRunning","title":"<code>isSequenceRunning(cameraLabel: DeviceLabel | str | None = None) -&gt; bool</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.isStageLinearSequenceable","title":"<code>isStageLinearSequenceable(stageLabel: DeviceLabel | str) -&gt; bool</code>","text":"<p>Queries if the stage can be used in a linear sequence.</p> <p>A linear sequence is defined by a step size and number of slices.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.isStageSequenceable","title":"<code>isStageSequenceable(stageLabel: DeviceLabel | str) -&gt; bool</code>","text":"<p>Queries stage if it can be used in a sequence.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.isXYStageSequenceable","title":"<code>isXYStageSequenceable(xyStageLabel: DeviceLabel | str) -&gt; bool</code>","text":"<p>Queries XY stage if it can be used in a sequence.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.loadDevice","title":"<code>loadDevice(label: str, moduleName: AdapterName | str, deviceName: DeviceName | str) -&gt; None</code>","text":"<p>Loads a device from the plugin library, or python module.</p> <p>In the standard MM case, this will load a device from the plugin library:</p> <pre><code>core.loadDevice(\"cam\", \"DemoCamera\", \"DCam\")\n</code></pre> <p>For python devices, this will load a device from a python module:</p> <pre><code>core.loadDevice(\"pydev\", \"package.module\", \"DeviceClass\")\n</code></pre>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.loadExposureSequence","title":"<code>loadExposureSequence(cameraLabel: DeviceLabel | str, exposureSequence_ms: Sequence[float]) -&gt; None</code>","text":"<p>Transfer a sequence of exposure times to the camera.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.loadPropertySequence","title":"<code>loadPropertySequence(label: DeviceLabel | str, propName: PropertyName | str, eventSequence: Sequence[Any]) -&gt; None</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.loadPyDevice","title":"<code>loadPyDevice(label: str, device: Device) -&gt; None</code>","text":"<p>Load a <code>unicore.Device</code> as a python device.</p> <p>This API allows you to create python-side Device objects that can be used in tandem with the C++ devices. Whenever a method is called that would normally interact with a C++ device, this class will first check if a python device with the same label exists, and if so, use that instead.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label to assign to the device.</p> required <code>device</code> <code>unicore.Device</code> <p>The device object to load.  Use the appropriate subclass of <code>Device</code> for the type of device you are creating.</p> required"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.loadSLMSequence","title":"<code>loadSLMSequence(slmLabel: DeviceLabel | str, imageSequence: Sequence[bytes | np.ndarray]) -&gt; None</code>","text":"<p>Load a sequence of images to the SLM.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.loadStageSequence","title":"<code>loadStageSequence(stageLabel: DeviceLabel | str, positionSequence: Sequence[float]) -&gt; None</code>","text":"<p>Transfer a sequence of stage positions to the stage.</p> <p>This should only be called for stages that are sequenceable.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.loadSystemConfiguration","title":"<code>loadSystemConfiguration(fileName: str | Path = 'MMConfig_demo.cfg') -&gt; None</code>","text":"<p>Load a system config file conforming to the MM <code>.cfg</code> format.</p> <p>This is a Python implementation that supports both C++ and Python devices. Lines prefixed with <code>#py</code> are processed as Python device commands but are ignored by upstream C++/pymmcore implementations.</p> <p>Format example::</p> <pre><code># C++ devices\nDevice, Camera, DemoCamera, DCam\nProperty, Core, Initialize, 1\n\n# Python devices (hidden from upstream via comment prefix)\n# py pyDevice,PyCamera,mypackage.cameras,MyCameraClass\n# py Property,PyCamera,Exposure,50.0\n</code></pre> <p>https://micro-manager.org/Micro-Manager_Configuration_Guide#configuration-file-syntax</p> <p>For relative paths, the current working directory is first checked, then the device adapter path is checked.</p> <p>Parameters:</p> Name Type Description Default <code>fileName</code> <code>str | Path</code> <p>Path to the configuration file. Defaults to \"MMConfig_demo.cfg\".</p> <code>'MMConfig_demo.cfg'</code>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.loadXYStageSequence","title":"<code>loadXYStageSequence(xyStageLabel: DeviceLabel | str, xSequence: Sequence[float], ySequence: Sequence[float]) -&gt; None</code>","text":"<p>Transfer a sequence of stage positions to the xy stage.</p> <p>xSequence and ySequence must have the same length. This should only be called for XY stages that are sequenceable</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.popNextImage","title":"<code>popNextImage(*, fix: bool = True) -&gt; np.ndarray</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.popNextImageMD","title":"<code>popNextImageMD(*args: Any) -&gt; np.ndarray</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.prepareSequenceAcquisition","title":"<code>prepareSequenceAcquisition(cameraLabel: DeviceLabel | str) -&gt; None</code>","text":"<p>Prepare the camera for sequence acquisition.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.renameConfig","title":"<code>renameConfig(groupName: str, oldConfigName: str, newConfigName: str) -&gt; None</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.renameConfigGroup","title":"<code>renameConfigGroup(oldGroupName: str, newGroupName: str) -&gt; None</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.reset","title":"<code>reset() -&gt; None</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.saveSystemConfiguration","title":"<code>saveSystemConfiguration(filename: str | Path, *, prefix_py_devices: bool = True) -&gt; None</code>","text":"<p>Save the current system configuration to a text file.</p> <p>This saves both C++ and Python devices.  Python device lines are prefixed with <code>#py</code> by default so they are ignored by upstream C++/pymmcore.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str | Path</code> <p>Path to save the configuration file.</p> required <code>prefix_py_devices</code> <code>bool, optional</code> <p>If True (default), Python device lines are prefixed with <code>#py</code> so they are ignored by upstream C++/pymmcore implementations, allowing config files to work with regular pymmcore. If False, Python device lines are saved without the prefix (config will only be loadable by UniMMCore).</p> <code>True</code>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.setAdapterOrigin","title":"<code>setAdapterOrigin(*args: Any) -&gt; None</code>","text":"<p>Enable software translation of coordinates for the current focus/Z stage.</p> <p>The current position of the stage becomes Z = newZUm. Only some stages support this functionality; it is recommended that setOrigin() be used instead where available.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.setAdapterOriginXY","title":"<code>setAdapterOriginXY(*args: Any) -&gt; None</code>","text":"<p>Enable software translation of coordinates for the current XY stage.</p> <p>The current position of the stage becomes (newXUm, newYUm). It is recommended that setOriginXY() be used instead where available.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.setCameraDevice","title":"<code>setCameraDevice(cameraLabel: DeviceLabel | str) -&gt; None</code>","text":"<p>Set the camera device.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.setCircularBufferMemoryFootprint","title":"<code>setCircularBufferMemoryFootprint(sizeMB: int) -&gt; None</code>","text":"<p>Set the circular buffer memory footprint in MB.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.setConfig","title":"<code>setConfig(groupName: str, configName: str) -&gt; None</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.setDeviceDelayMs","title":"<code>setDeviceDelayMs(label: DeviceLabel | str, delayMs: float) -&gt; None</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.setExposure","title":"<code>setExposure(*args: Any) -&gt; None</code>","text":"<p>Set the exposure time in milliseconds.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.setFocusDevice","title":"<code>setFocusDevice(focusLabel: str) -&gt; None</code>","text":"<p>Set new current Focus Device.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.setFocusDirection","title":"<code>setFocusDirection(stageLabel: DeviceLabel | str, sign: int) -&gt; None</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.setOrigin","title":"<code>setOrigin(stageLabel: DeviceLabel | str | None = None) -&gt; None</code>","text":"<p>Zero the current focus/Z stage's coordinates at the current position.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.setOriginX","title":"<code>setOriginX(xyStageLabel: DeviceLabel | str = '') -&gt; None</code>","text":"<p>Zero the given XY stage's X coordinate at the current position.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.setOriginXY","title":"<code>setOriginXY(xyStageLabel: DeviceLabel | str = '') -&gt; None</code>","text":"<p>Zero the given XY stage's coordinates at the current position.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.setOriginY","title":"<code>setOriginY(xyStageLabel: DeviceLabel | str = '') -&gt; None</code>","text":"<p>Zero the given XY stage's Y coordinate at the current position.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.setParentLabel","title":"<code>setParentLabel(deviceLabel: DeviceLabel | str, parentHubLabel: DeviceLabel | str) -&gt; None</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.setPosition","title":"<code>setPosition(*args: Any) -&gt; None</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.setProperty","title":"<code>setProperty(label: str, propName: str, propValue: bool | float | int | str) -&gt; None</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.setRelativePosition","title":"<code>setRelativePosition(*args: Any) -&gt; None</code>","text":"<p>Sets the relative position of the stage in microns.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.setRelativeXYPosition","title":"<code>setRelativeXYPosition(*args: Any) -&gt; None</code>","text":"<p>Sets the relative position of the XY stage in microns.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.setSLMDevice","title":"<code>setSLMDevice(slmLabel: DeviceLabel | str) -&gt; None</code>","text":"<p>Set the SLM device.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.setSLMExposure","title":"<code>setSLMExposure(*args: Any) -&gt; None</code>","text":"<p>Command the SLM to turn off after a specified interval.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.setSLMImage","title":"<code>setSLMImage(*args: Any) -&gt; None</code>","text":"<p>Load the image into the SLM device adapter.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.setSLMPixelsTo","title":"<code>setSLMPixelsTo(*args: Any) -&gt; None</code>","text":"<p>Set all pixels of the SLM to a uniform intensity or RGB values.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.setShutterDevice","title":"<code>setShutterDevice(shutterLabel: DeviceLabel | str) -&gt; None</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.setStageLinearSequence","title":"<code>setStageLinearSequence(stageLabel: DeviceLabel | str, dZ_um: float, nSlices: int) -&gt; None</code>","text":"<p>Loads a linear sequence (defined by step size and nr. of steps).</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.setState","title":"<code>setState(stateDeviceLabel: DeviceLabel | str, state: int) -&gt; None</code>","text":"<p>Set state (position) on the specific device.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.setStateLabel","title":"<code>setStateLabel(stateDeviceLabel: DeviceLabel | str, stateLabel: str) -&gt; None</code>","text":"<p>Set device state using the previously assigned label (string).</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.setXYPosition","title":"<code>setXYPosition(*args: Any) -&gt; None</code>","text":"<p>Sets the position of the XY stage in microns.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.setXYStageDevice","title":"<code>setXYStageDevice(xyStageLabel: DeviceLabel | str) -&gt; None</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.startExposureSequence","title":"<code>startExposureSequence(cameraLabel: DeviceLabel | str) -&gt; None</code>","text":"<p>Start a sequence of exposures.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.startPropertySequence","title":"<code>startPropertySequence(label: DeviceLabel | str, propName: PropertyName | str) -&gt; None</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.startSLMSequence","title":"<code>startSLMSequence(slmLabel: DeviceLabel | str) -&gt; None</code>","text":"<p>Start a sequence of images on the SLM.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.startStageSequence","title":"<code>startStageSequence(stageLabel: DeviceLabel | str) -&gt; None</code>","text":"<p>Starts an ongoing sequence of triggered events in a stage.</p> <p>This should only be called for stages that are sequenceable.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.startXYStageSequence","title":"<code>startXYStageSequence(xyStageLabel: DeviceLabel | str) -&gt; None</code>","text":"<p>Starts an ongoing sequence of triggered events in an XY stage.</p> <p>This should only be called for stages that are sequenceable</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.stop","title":"<code>stop(xyOrZStageLabel: DeviceLabel | str) -&gt; None</code>","text":"<p>Stop the XY or focus/Z stage.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.stopExposureSequence","title":"<code>stopExposureSequence(cameraLabel: DeviceLabel | str) -&gt; None</code>","text":"<p>Stop a sequence of exposures.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.stopPropertySequence","title":"<code>stopPropertySequence(label: DeviceLabel | str, propName: PropertyName | str) -&gt; None</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.stopSLMSequence","title":"<code>stopSLMSequence(slmLabel: DeviceLabel | str) -&gt; None</code>","text":"<p>Stop a sequence of images on the SLM.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.stopStageSequence","title":"<code>stopStageSequence(stageLabel: DeviceLabel | str) -&gt; None</code>","text":"<p>Stops an ongoing sequence of triggered events in a stage.</p> <p>This should only be called for stages that are sequenceable.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.stopXYStageSequence","title":"<code>stopXYStageSequence(xyStageLabel: DeviceLabel | str) -&gt; None</code>","text":"<p>Stops an ongoing sequence of triggered events in an XY stage.</p> <p>This should only be called for stages that are sequenceable</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.systemBusy","title":"<code>systemBusy() -&gt; bool</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.unloadAllDevices","title":"<code>unloadAllDevices() -&gt; None</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.unloadDevice","title":"<code>unloadDevice(label: DeviceLabel | str) -&gt; None</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.updateSystemStateCache","title":"<code>updateSystemStateCache() -&gt; None</code>","text":"<p>Update the system state cache for all devices including Python devices.</p> <p>This populates our Python-side cache with current values from all Python devices, then calls the C++ updateSystemStateCache.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.usesDeviceDelay","title":"<code>usesDeviceDelay(label: DeviceLabel | str) -&gt; bool</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.waitForConfig","title":"<code>waitForConfig(group: str, configName: str) -&gt; None</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.waitForDevice","title":"<code>waitForDevice(label: DeviceLabel | str) -&gt; None</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.waitForDeviceType","title":"<code>waitForDeviceType(devType: int) -&gt; None</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.core._unicore.UniMMCore.waitForSystem","title":"<code>waitForSystem() -&gt; None</code>","text":""},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.XYStageDevice","title":"<code>XYStageDevice</code>","text":"<p>ABC for XYStage devices.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._stage.XYStageDevice.get_position_um","title":"<code>get_position_um() -&gt; tuple[float, float]</code>  <code>abstractmethod</code>","text":"<p>Returns the current position of the XY stage in microns.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._stage.XYStageDevice.set_adapter_origin_um","title":"<code>set_adapter_origin_um(x: float, y: float) -&gt; None</code>","text":"<p>Alter the software coordinate translation between micrometers and steps.</p> <p>... such that the current position becomes the given coordinates.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._stage.XYStageDevice.set_origin","title":"<code>set_origin() -&gt; None</code>","text":"<p>Zero the stage's coordinates at the current position.</p> <p>This is a convenience method that calls <code>set_origin_x</code> and <code>set_origin_y</code>. Can be overridden for more efficient implementations.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._stage.XYStageDevice.set_origin_x","title":"<code>set_origin_x() -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Zero the stage's X coordinates at the current position.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._stage.XYStageDevice.set_origin_y","title":"<code>set_origin_y() -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Zero the stage's Y coordinates at the current position.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._stage.XYStageDevice.set_position_um","title":"<code>set_position_um(x: float, y: float) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Set the position of the XY stage in microns.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._stage.XYStageDevice.set_relative_position_um","title":"<code>set_relative_position_um(dx: float, dy: float) -&gt; None</code>","text":"<p>Move the stage by a relative amount.</p> <p>Can be overridden for more efficient implementations.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.XYStepperStageDevice","title":"<code>XYStepperStageDevice</code>","text":"<p>ABC for XYStage devices that support stepper motors.</p> <p>In this variant, rather than providing <code>set_position_um</code> and <code>get_position_um</code>, you provide <code>set_position_steps</code>, <code>get_position_steps</code>, <code>get_step_size_x_um</code>, and <code>get_step_size_y_um</code>.  A default implementation of <code>set_position_um</code> and <code>get_position_um</code> is then provided that uses these methods, taking into account the XY-mirroring properties of the device.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._stage.XYStepperStageDevice.get_position_steps","title":"<code>get_position_steps() -&gt; tuple[int, int]</code>  <code>abstractmethod</code>","text":"<p>Returns the current position of the XY stage in steps.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._stage.XYStepperStageDevice.get_position_um","title":"<code>get_position_um() -&gt; tuple[float, float]</code>","text":"<p>Get the position of the XY stage in microns.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._stage.XYStepperStageDevice.get_step_size_x_um","title":"<code>get_step_size_x_um() -&gt; float</code>  <code>abstractmethod</code>","text":"<p>Returns the step size of the X axis in microns.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._stage.XYStepperStageDevice.get_step_size_y_um","title":"<code>get_step_size_y_um() -&gt; float</code>  <code>abstractmethod</code>","text":"<p>Returns the step size of the Y axis in microns.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._stage.XYStepperStageDevice.set_adapter_origin_um","title":"<code>set_adapter_origin_um(x: float = 0.0, y: float = 0.0) -&gt; None</code>","text":"<p>Alter the software coordinate translation between micrometers and steps.</p> <p>... such that the current position becomes the given coordinates.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._stage.XYStepperStageDevice.set_origin","title":"<code>set_origin() -&gt; None</code>","text":"<p>Zero the stage's coordinates at the current position.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._stage.XYStepperStageDevice.set_origin_x","title":"<code>set_origin_x() -&gt; None</code>","text":"<p>Zero the stage's X coordinates at the current position.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._stage.XYStepperStageDevice.set_origin_y","title":"<code>set_origin_y() -&gt; None</code>","text":"<p>Zero the stage's Y coordinates at the current position.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._stage.XYStepperStageDevice.set_position_steps","title":"<code>set_position_steps(x: int, y: int) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Set the position of the XY stage in steps.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._stage.XYStepperStageDevice.set_position_um","title":"<code>set_position_um(x: float, y: float) -&gt; None</code>","text":"<p>Set the position of the XY stage in microns.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._stage.XYStepperStageDevice.set_relative_position_steps","title":"<code>set_relative_position_steps(dx: int, dy: int) -&gt; None</code>","text":"<p>Move the stage by a relative amount.</p> <p>Can be overridden for more efficient implementations.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.devices._stage.XYStepperStageDevice.set_relative_position_um","title":"<code>set_relative_position_um(dx: float, dy: float) -&gt; None</code>","text":"<p>Default implementation for relative motion.</p> <p>Can be overridden for more efficient implementations.</p>"},{"location":"api/unicore/#pymmcore_plus.experimental.unicore.pymm_property","title":"<code>pymm_property(fget: Callable[[TDev], TProp] | None = None, *, limits: tuple[TLim, TLim] | None = None, sequence_max_length: int = 0, allowed_values: Sequence[TProp] | None = None, is_read_only: bool | None = None, is_pre_init: bool = False, name: str | None = None, property_type: PropArg = None) -&gt; PropertyController[TDev, TProp] | Callable[[Callable[[TDev], TProp]], PropertyController[TDev, TProp]]</code>","text":"<p>Decorates a (getter) method to create a device property.</p> <p>The returned PropertyController instance can be additionally used (similar to <code>@property</code>) to decorate <code>setter</code>, <code>sequence_loader</code>, <code>sequence_starter</code>, and/or <code>sequence_stopper</code> methods.</p> <p>Properties can have limits, allowed values, but may not have both.</p> <p>Properties will only be considered \"sequenceable\" (i.e. they support hardware triggering) if they have a non-zero sequence_max_length AND have decorated <code>sequence_loader</code> and <code>sequence_starter</code> methods.</p> <p>Parameters:</p> Name Type Description Default <code>fget</code> <code>Callable[[TDev], TProp], optional</code> <p>The getter method for the property, by default None.</p> <code>None</code> <code>limits</code> <code>tuple[float, float], optional</code> <p>The minimum and maximum values of the property, by default None. Cannot be combined with <code>allowed_values</code>.</p> <code>None</code> <code>sequence_max_length</code> <code>int, optional</code> <p>The maximum length of a sequence of property values, by default 0.</p> <code>0</code> <code>allowed_values</code> <code>Sequence[TProp], optional</code> <p>The allowed values of the property, by default None. Cannot be combined with <code>limits</code>.</p> <code>None</code> <code>is_read_only</code> <code>bool, optional</code> <p>Whether the property is read-only, by default False.</p> <code>None</code> <code>is_pre_init</code> <code>bool, optional</code> <p>Whether the property must be set before initialization, by default False.</p> <code>False</code> <code>name</code> <code>str, optional</code> <p>The name of the property, by default, the name of the getter method is used.</p> <code>None</code> <code>prop_type</code> <code>PropArg, optional</code> <p>The type of the property, by default the return annotation of the getter method is used (but must be one of <code>float</code>, <code>int</code>, or <code>str</code>).</p> required <p>Examples:</p> <pre><code>class MyDevice(Device):\n    @pymm_property(limits=(0, 100), sequence_max_length=10)\n    def position(self) -&gt; float:\n        # get position from device\n        return 42.0\n\n    @position.setter\n    def position(self, value: float) -&gt; None:\n        print(f\"Setting position to {value}\")\n\n    @position.sequence_loader\n    def load_position_sequence(self, sequence: Sequence[float]) -&gt; None:\n        print(f\"Loading position sequence: {sequence}\")\n\n    @position.sequence_starter\n    def start_position_sequence(self) -&gt; None:\n        print(\"Starting position sequence\")\n\n    @pymm_property(is_read_only=True)\n    def pressure(self) -&gt; float:\n        return 1.0\n\n    @pymm_property(allowed_values=[\"low\", \"medium\", \"high\"])\n    def speed(self) -&gt; str:\n        # get speed from device\n        return \"medium\"\n\n    @speed.setter\n    def speed(self, value: str) -&gt; None:\n        print(f\"Setting speed to {value}\")\n</code></pre>"},{"location":"api/utils/","title":"Utilities","text":""},{"location":"api/utils/#pymmcore_plus.find_micromanager","title":"<code>pymmcore_plus.find_micromanager(return_first: bool = True) -&gt; str | None | list[str]</code>","text":"<p>Locate a Micro-Manager folder (for device adapters).</p> <p>In order, this will look for:</p> <ol> <li>An environment variable named <code>MICROMANAGER_PATH</code></li> <li>A path stored in the <code>CURRENT_MM_PATH</code> file (set by <code>use_micromanager</code>).</li> <li> <p>A <code>Micro-Manager*</code> folder in the <code>pymmcore-plus</code> user data directory    (this is the default install location when running <code>mmcore install</code>)</p> <ul> <li>Windows: C:\\Users\\[user]\\AppData\\Local\\pymmcore-plus\\pymmcore-plus</li> <li>macOS: ~/Library/Application Support/pymmcore-plus</li> <li>Linux: ~/.local/share/pymmcore-plus</li> </ul> </li> <li> <p>A <code>Micro-Manager*</code> folder in the <code>pymmcore_plus</code> package directory (this is the    default install location when running <code>python -m pymmcore_plus.install</code>)</p> </li> <li> <p>The default micro-manager install location:</p> <ul> <li>Windows: <code>C:/Program Files/</code></li> <li>macOS: <code>/Applications</code></li> <li>Linux: <code>/usr/local/lib</code></li> </ul> </li> </ol> <p>Note</p> <p>This function is used by <code>pymmcore_plus.CMMCorePlus</code> to locate the micro-manager device adapters.  By default, the output of this function is passed to <code>setDeviceAdapterSearchPaths</code> when creating a new <code>CMMCorePlus</code> instance.</p> <p>Parameters:</p> Name Type Description Default <code>return_first</code> <code>bool, optional</code> <p>If True (default), return the first found path.  If False, return a list of all found paths.</p> <code>True</code>"},{"location":"api/utils/#pymmcore_plus.use_micromanager","title":"<code>pymmcore_plus.use_micromanager(path: str | Path | None = None, pattern: str | re.Pattern[str] | None = None) -&gt; Path | None</code>","text":"<p>Set the preferred Micro-Manager path.</p> <p>This sets the preferred micromanager path, and persists across sessions. This path takes precedence over everything except the <code>MICROMANAGER_PATH</code> environment variable.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path | None</code> <p>Path to an existing directory. This directory should contain micro-manager device adapters. If <code>None</code>, the path will be determined using <code>pattern</code>.</p> <code>None</code> <code>pattern</code> <code>str Pattern | | None</code> <p>A regex pattern to match against the micromanager paths found by <code>find_micromanager</code>. If no match is found, a <code>FileNotFoundError</code> will be raised.</p> <code>None</code>"},{"location":"api/utils/#pymmcore_plus.configure_logging","title":"<code>pymmcore_plus.configure_logging(file: str | Path | None = LOG_FILE, stderr_level: int | str = DEFAULT_LOG_LEVEL, file_level: int | str = logging.DEBUG, log_to_stderr: bool = True, file_rotation: int = 40, file_retention: int = 20) -&gt; None</code>","text":"<p>Configure logging for pymmcore-plus.</p> <p>This function is called automatically once when pymmcore-plus is imported, to set up logging to stderr and a log file.  You can call it again to change the logging settings.</p> <p>You may also configure logging using the following environment variables:</p> <ul> <li><code>PYMM_LOG_LEVEL</code> - The log level for <code>stderr</code> logging. By default <code>INFO</code>.</li> <li><code>PYMM_LOG_FILE</code> - The path to the log file.  If set to <code>0</code>, <code>false</code>, <code>no</code>,     or <code>none</code>, logging to file will be disabled.</li> </ul> <p>Note</p> <p>This function will clear all existing logging handlers and replace them with new ones.  So be sure to pass all the settings you want to use each time you call this function.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str | Path | None</code> <p>Path to logfile. May also be set with MM_LOG_FILE environment variable. If <code>None</code>, will not log to file.  By default, logs to: Mac OS X:   ~/Library/Application Support/pymmcore-plus/logs Unix:       ~/.local/share/pymmcore-plus/logs Win:        C:\\Users\\\\AppData\\Local\\pymmcore-plus\\pymmcore-plus\\logs <code>LOG_FILE</code> <code>stderr_level</code> <code>int | str</code> <p>Level for stderr logging. One of \"TRACE\", \"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\", or 5, 10, 20, 30, 40, or 50, respectively. by default <code>\"INFO\"</code>.</p> <code>DEFAULT_LOG_LEVEL</code> <code>file_level</code> <code>int | str</code> <p>Level for logging to file, by default <code>\"TRACE\"</code></p> <code>logging.DEBUG</code> <code>log_to_stderr</code> <code>bool</code> <p>Whether to log to stderr, by default True</p> <code>True</code> <code>file_rotation</code> <code>int</code> <p>When to rollover to the next log file, in MegaBytes, by default <code>40</code>.</p> <code>40</code> <code>file_retention</code> <code>int</code> <p>Maximum number of log files to retain, by default <code>20</code></p> <code>20</code>"},{"location":"examples/context-set/","title":"Set as a Context","text":"<p>You may want to temporarily set something on core such as <code>core.setAutoShutter(False)</code> when writing an MDA Engine. For this case you can use the convenience method <code>CMMCorePlus.setContext</code>.</p> set_as_context.py<pre><code>from pymmcore_plus import CMMCorePlus\n\ncore = CMMCorePlus.instance()\n\n# set some state temporarily\nwith core.setContext(autoShutter=False):\n    assert not core.getAutoShutter()\n    # do other stuff\n\nassert core.getAutoShutter()\n</code></pre> <p>This will work for the <code>set</code> methods on the core such as <code>setAutoShutter</code>, <code>setShutterOpen</code>, ...</p>"},{"location":"examples/following_changes_in_core/","title":"Follow changes in MMCore","text":"<p><code>pymmcore-plus</code> implements an enhanced Observer pattern, making it easier to connect callback functions to events that occur in the core.  This is useful for things like updating a GUI when a property changes, or writing and/or processing data as it is acquired.</p> <p>See the Events API documentation for complete details on what events are emitted and how to connect to them.</p> on_prop_changed.py<pre><code>from pymmcore_plus import CMMCorePlus\n\ncore = CMMCorePlus.instance()\ncore.loadSystemConfiguration()\n\n\n@core.events.propertyChanged.connect\ndef _on_prop_changed(dev, prop, value):\n    # Note that when state devices change either the state or the label\n    # TWO propertyChanged events will be emitted, one for prop 'State'\n    # and one for prop 'Label'. Probably, best to check the property\n    # name and only respond to one of them\n    if dev == \"Objective\" and prop == \"Label\":\n        print(\"new objective is\", value)\n\n\ncore.setState(\"Objective\", 3)\n</code></pre>"},{"location":"examples/integration-with-qt/","title":"Qt Integration","text":"<p>For a complex Qt application based on <code>pymmcore-plus</code> check out napari-micromanager which implements a GUI to control microscopes.</p> <p><code>pymmcore-plus</code> is designed seamlessly integrate with Qt GUIs. It accomplishes this in two ways:</p> <ol> <li><code>pymmcore_plus.CMMCorePlus.run_mda</code> runs in a thread in order to not block the event loop.</li> <li>The <code>events</code> object will preferentially to use QSignals instead of of signals from the psygnal library. This helps keep things from crashing when working with callbacks in multiple threads.</li> </ol> <p>This example requires qtpy and an Qt backend installed in the env:</p> <pre><code>pip install qtpy superqt Pyside2 # or pyqt5\n</code></pre>"},{"location":"examples/integration-with-qt/#avoiding-blocking-the-qt-event-loop","title":"Avoiding blocking the Qt event loop","text":"<p>If you make a blocking call on the thread running the Qt event loop then your GUI will become unresponsive. <code>pymmcore-plus</code> has two options to avoid this. The recommended way is to use threads to call <code>pymmcore_plus.CMMCorePlus.snapImage</code>, and let pymmcore-plus handle the threading when you use <code>pymmcore_plus.CMMCorePlus.run_mda</code>.</p> <p>This example will use the recommended process-local(threads) approach.</p> <p>The simple application will consist of a counter that increments so long as the event loop is not blocked, and two buttons to call the <code>snapImage</code> method. One button will call from a thread and the counter should continue, the other will block and will stop the counter.</p> <p>Key takeaways:</p> <ol> <li>Use <code>CMMCorePlus.instance()</code> to create the core object. This allows another script in the same process to use the same object.</li> <li>Use a thread for blocking operations like <code>snapImage</code>.</li> </ol> <pre><code>import sys\n\nfrom qtpy.QtCore import QTimer\nfrom qtpy.QtWidgets import (\n    QApplication,\n    QLabel,\n    QMainWindow,\n    QPushButton,\n    QVBoxLayout,\n    QWidget,\n)\nfrom superqt.utils import create_worker\n\nfrom pymmcore_plus import CMMCorePlus\n\n\nclass MainWindow(QMainWindow):\n    def __init__(self):\n        super().__init__()\n        self.mmc = CMMCorePlus.instance()\n        self.mmc.loadSystemConfiguration()\n        self.mmc.setExposure(5000)  # 5 seconds\n\n        self.counter = 0\n\n        layout = QVBoxLayout()\n\n        self.l = QLabel(\"Start\")\n        b_blocking = QPushButton(\"Snap blocking\")\n        b_threaded = QPushButton(\"Snap threaded\")\n        b_blocking.pressed.connect(self.snap_blocking)\n        b_threaded.pressed.connect(self.snap_threaded)\n\n        layout.addWidget(self.l)\n        layout.addWidget(b_blocking)\n        layout.addWidget(b_threaded)\n\n        w = QWidget()\n        w.setLayout(layout)\n        self.setCentralWidget(w)\n        self.show()\n\n        self.timer = QTimer()\n        self.timer.setInterval(1000)\n        self.timer.timeout.connect(self._recurring_timer)\n        self.timer.start()\n\n    def _recurring_timer(self):\n        self.counter += 1\n        self.l.setText(\"Counter: %d\" % self.counter)\n\n    def snap_threaded(self):\n        # alternatively you could use the python threading module\n        # or directly use QThreads\n        create_worker(\n            self._mmc.snapImage,\n            _start_thread=True,\n        )\n\n    def snap_blocking(self):\n        self.mmc.snapImage()\n\n\n\napp = QApplication(sys.argv)\nwindow = MainWindow()\napp.exec_()\n</code></pre>"},{"location":"examples/mda/","title":"Multidimensional Acquisition","text":"<p>Note</p> <p>There is much more extensive documentation on the MDA acquisition engine in the Acquisition Engine guide</p> <p><code>pymmcore-plus</code> includes a basic Multi-dimensional Acquisition (<code>mda</code>) engine <code>CMMCorePlus.run_mda</code> that accepts experimental sequences defined using useq-schema.</p> run_mda.py<pre><code>import numpy as np\nfrom useq import MDAEvent, MDASequence\n\nfrom pymmcore_plus import CMMCorePlus\n\n# see https://pymmcore-plus.github.io/useq-schema/api/ (1)\nsequence = MDASequence(\n    channels=[\"DAPI\", {\"config\": \"FITC\", \"exposure\": 50}],\n    time_plan={\"interval\": 2, \"loops\": 5},\n    z_plan={\"range\": 4, \"step\": 0.5},\n    axis_order=\"tpcz\",\n)\n\nmmc = CMMCorePlus.instance()  # (2)!\nmmc.loadSystemConfiguration()  #  load demo configuration (3)\n\n\n# connect callback using a decorator (4)\n@mmc.mda.events.frameReady.connect\ndef new_frame(img: np.ndarray, event: MDAEvent):\n    print(img.shape)\n\n\n# or connect callback using a function\ndef on_start(sequence: MDASequence):\n    print(f\"now starting sequence {sequence.uid}!\")\n\n\nmmc.mda.events.sequenceStarted.connect(on_start)\n\n# run the sequence in a separate thread (5)\nmmc.run_mda(sequence)\n</code></pre> <ol> <li><code>pymmcore-plus</code> uses    <code>useq-schema</code> to define    experimental sequences. You can either construct a <code>useq.MDASequence</code>    object manually, or    from a YAML/JSON file.</li> <li>Access global singleton:    <code>CMMCorePlus.instance</code></li> <li>See    <code>CMMCorePlus.loadSystemConfiguration</code></li> <li>For info on all of the signals available to connect to, see the    MDA Events API</li> <li>To avoid blocking further execution,    <code>run_mda</code> runs on a new thread.    (<code>run_mda</code> returns a reference to the thread in case you want to do    something with it, such as wait for it to finish with    threading.Thread.join)</li> </ol>"},{"location":"examples/mda/#cancelling-or-pausing","title":"Cancelling or Pausing","text":"<p>You can pause or cancel the mda with the <code>CMMCorePlus.mda.toggle_pause</code> or <code>CMMCorePlus.mda.cancel</code> methods.</p>"},{"location":"examples/mda/#registering-a-new-mda-engine","title":"Registering a new MDA Engine","text":"<p>By default the built-in <code>MDAEngine</code> will be used to run the MDA. However, you can create a custom acquisition engine and register it use <code>CMMCorePlus.register_mda_engine</code>.</p> <p>Your engine must conform to the engine protocol defined by <code>pymmcore_plus.mda.PMDAEngine</code>. To ensure that your engine conforms you can inherit from the protocol.</p> <p>You can be alerted to the the registering of a new engine with the <code>core.events.mdaEngineRegistered</code> signal.</p> <pre><code>@mmc.events.mdaEngineRegistered\ndef new_engine(new_engine, old_engine):\n    print('new engine registered!\")\n</code></pre>"},{"location":"examples/napari-micromanager/","title":"Using with napari","text":"<p>If you want a nice GUI to interact with in addition to being able to script you can use napari-micromanager which implements a GUI in napari using this library as a backend.</p>"},{"location":"examples/napari-micromanager/#launching-napari-from-a-script","title":"Launching napari from a script","text":"<p>For complex scripting you likely will want to launch napari from a script or a jupyter notebook.</p> napari.py<pre><code>import napari\n\nfrom pymmcore_plus import CMMCorePlus\n\nv = napari.Viewer()\ndw, main_window = v.window.add_plugin_dock_widget(\"napari-micromanager\")\n\n# quick way to access the same core instance as napari-micromanager\nmmc = CMMCorePlus.instance()\n\n# do any complicated scripting you want here\n...\n\n# start napari\nnapari.run()\n</code></pre>"},{"location":"examples/napari-micromanager/#using-the-integrated-napari-terminal","title":"Using the integrated napari terminal","text":"<p>After launching napari and starting the <code>napari-micromanager</code> plugin you can open the napari terminal and get a reference to the same core object that the plugin uses by running:</p> <pre><code>from pymmcore_plus import CMMCorePlus\n\nmmc = CMMCorePlus.instance()\n</code></pre>"},{"location":"examples/pycro-manager-api/","title":"Pycro-manager like API","text":"<p>If you have been using pycro-manager and are familiar with its API, the following example may be useful to see what a pycro-manager-like API would look like implemented on the pymmcore-plus engine.</p> <p>Warning</p> <p>This is not presented as \"suggestion\", but rather as an educational example.  If you are considering pymmcore-plus for a pure-python acquisition workflow, consider using the <code>pymmcore</code> and <code>pymmcore-plus</code> APIs directly.</p> pycro-api.py<pre><code>from __future__ import annotations\n\nimport inspect\nfrom queue import Queue\nfrom typing import TYPE_CHECKING, Any, cast\n\nfrom useq import MDAEvent\n\nfrom pymmcore_plus import CMMCorePlus\nfrom pymmcore_plus.mda import MDAEngine\n\n# These types represent what the pycro-manager API expects.\nif TYPE_CHECKING:\n    from collections import deque\n    from collections.abc import Callable, Iterable, Iterator, Sequence\n    from typing import TypeAlias\n\n    from numpy.typing import NDArray\n\n    from pymmcore_plus.mda._engine import EventPayload\n\n    Meta: TypeAlias = dict[str, Any]\n    PycroEvent: TypeAlias = dict[str, Any]\n\n    # Acquisition Hooks\n    EventQueue = Queue[PycroEvent | None]\n    EventHook = Callable[[PycroEvent], PycroEvent | None]\n    EventQueueHook = Callable[[PycroEvent, EventQueue], PycroEvent | None]\n    AcquisitionHook = EventHook | EventQueueHook\n\n    # Processor Hooks\n    ImgHookReturn = tuple[NDArray, Meta] | Sequence[tuple[NDArray, Meta]] | None\n    ImgMetaHook = Callable[[NDArray, Meta], ImgHookReturn]\n    ImgMetaQueueHook = Callable[[NDArray, Meta, EventQueue], ImgHookReturn]\n    ProcessorHook = ImgMetaHook | ImgMetaQueueHook\n\n\nclass Acquisition:\n    \"\"\"Pycro-Manager -&gt; pymmcore-plus adaptor.\n\n    This doesn't re-implement file saving, but it gives you an example of how\n    pycromanager hooks would be converted to pymmcore-plus.\n\n    See `__main__` below for example usage.\n    \"\"\"\n\n    def __init__(\n        self,\n        image_process_fn: ProcessorHook | None = None,\n        event_generation_hook_fn: AcquisitionHook | None = None,\n        pre_hardware_hook_fn: AcquisitionHook | None = None,\n        post_hardware_hook_fn: AcquisitionHook | None = None,\n        post_camera_hook_fn: AcquisitionHook | None = None,\n    ):\n        self._core = CMMCorePlus.instance()\n        self._event_queue: EventQueue = Queue()\n        self._engine_cls = _build_engine(\n            self._event_queue,\n            event_generation_hook_fn,\n            pre_hardware_hook_fn,\n            post_hardware_hook_fn,\n            post_camera_hook_fn,\n        )\n        self._engine = self._engine_cls(self._core)\n        self._core.mda.set_engine(self._engine)\n\n        # see https://pymmcore-plus.github.io/pymmcore-plus/guides/event_driven_acquisition/\n        iter_queue = iter(self._event_queue.get, None)\n        self._thread = self._core.run_mda(iter_queue)  # type: ignore\n        # type error because of conversion between MDAEvent and pycromanager dict.\n        # we do the conversion below in the PycroEngine class.\n\n        # we can use `mda.events.frameReady` for the image_process hooks\n        self._image_process_fn = image_process_fn\n        if image_process_fn is not None:\n            sig = inspect.signature(image_process_fn)\n            if len(sig.parameters) == 2:\n                self._core.mda.events.frameReady.connect(self._call_img_hook_2arg)\n            elif len(sig.parameters) == 3:\n                self._core.mda.events.frameReady.connect(self._call_img_hook_3arg)\n            else:\n                raise ValueError(f\"Invalid image processing hook: {sig}\")\n\n    def acquire(self, event_or_events: PycroEvent | list[PycroEvent]) -&gt; None:\n        if isinstance(event_or_events, list):\n            for event in event_or_events:\n                self._event_queue.put(event)\n        else:\n            self._event_queue.put(event_or_events)\n\n    def abort(self, exception: BaseException | None = None) -&gt; None:\n        self._core.mda.cancel()\n        cast(\"deque\", self._event_queue.queue).clear()\n\n    def await_completion(self) -&gt; None:\n        self._thread.join()\n\n    def mark_finished(self) -&gt; None:\n        self._event_queue.put(None)\n\n    def _call_img_hook_2arg(self, img: NDArray, event: MDAEvent) -&gt; None:\n        \"\"\"Call a 2-argument image processing hook.\"\"\"\n        hook = cast(\"ImgMetaHook\", self._image_process_fn)\n        hook(img, {})  # todo: meta\n\n    def _call_img_hook_3arg(self, img: NDArray, event: MDAEvent) -&gt; None:\n        \"\"\"Call a 3-argument image processing hook.\"\"\"\n        hook = cast(\"ImgMetaQueueHook\", self._image_process_fn)\n        hook(img, {}, self._event_queue)  # todo: meta\n\n    def __enter__(self) -&gt; Acquisition:\n        return self\n\n    def __exit__(self, *args: Any) -&gt; None:\n        self.mark_finished()\n        self.await_completion()\n\n\n# note, this could be improved:\n# we don't need to check signature every time...\ndef _call_acq_hook(\n    hook: AcquisitionHook | None, event: PycroEvent, queue: EventQueue\n) -&gt; PycroEvent | None:\n    if hook is None:\n        return event\n\n    sig = inspect.signature(hook)\n    if len(sig.parameters) == 1:\n        return cast(\"EventHook\", hook)(event)\n    elif len(sig.parameters) == 2:\n        return cast(\"EventQueueHook\", hook)(event, queue)\n    else:\n        raise ValueError(f\"Invalid signature for acquisition hook: {sig}\")\n\n\nPYCRO_KEY = \"pycro_event\"  # where we store the pycro event in the mda event\nSKIP = \"pycro_skip\"  # if we should skip this event\n\n\ndef _build_engine(\n    event_queue: EventQueue,\n    event_generation_hook_fn: AcquisitionHook | None = None,\n    pre_hardware_hook_fn: AcquisitionHook | None = None,\n    post_hardware_hook_fn: AcquisitionHook | None = None,\n    post_camera_hook_fn: AcquisitionHook | None = None,\n) -&gt; type[MDAEngine]:\n    \"\"\"Convert pycromanager hooks to a pymmcore-plus style MDAEngine subclass.\"\"\"\n\n    class PycroEngine(MDAEngine):\n        def setup_event(self, event: MDAEvent) -&gt; None:\n            pyc_event = event.metadata[PYCRO_KEY]\n            if pre_hardware_hook_fn is not None:\n                pyc_event = _call_acq_hook(pre_hardware_hook_fn, pyc_event, event_queue)\n                if pyc_event is None:\n                    event.metadata[SKIP] = True\n                    return\n                event = _pycro_to_mda_event(pyc_event)\n\n            super().setup_event(event)\n            pyc_event = _call_acq_hook(post_hardware_hook_fn, pyc_event, event_queue)\n            if pyc_event is None:\n                event.metadata[SKIP] = True\n\n        def exec_event(self, event: MDAEvent) -&gt; EventPayload | None:\n            if event.metadata.get(SKIP):\n                return None\n\n            result = super().exec_event(event)\n            _call_acq_hook(post_camera_hook_fn, event.metadata[PYCRO_KEY], event_queue)\n            return result\n\n        def event_iterator(self, events: Iterable[MDAEvent]) -&gt; Iterator[MDAEvent]:\n            for pycro_event in iter(event_queue.get, None):\n                _event = _call_acq_hook(\n                    event_generation_hook_fn, pycro_event, event_queue\n                )\n                if _event is not None:\n                    yield _pycro_to_mda_event(_event)\n\n    return PycroEngine\n\n\ndef _pycro_to_mda_event(pycro_event: PycroEvent) -&gt; MDAEvent:\n    # This is rough estimation... ideally, useq-schema would be used directly,\n    # and the need to convert pycro-manager events to MDAEvents would be eliminated.\n\n    # TODO: convert row/col to useq grid plan\n    index = {\n        k[0]: v\n        for k, v in pycro_event[\"axes\"].items()\n        if k in [\"z\", \"time\", \"position\"]\n        # TODO: convert channel str to index integer\n    }\n    if cfg := pycro_event.get(\"config_group\", []):\n        channel = {\"group\": cfg[0], \"config\": cfg[1]}\n    else:\n        channel = None\n\n    return MDAEvent(\n        index=index,\n        channel=channel,\n        x_pos=pycro_event.get(\"x\"),\n        y_pos=pycro_event.get(\"y\"),\n        z_pos=pycro_event.get(\"z\"),\n        exposure=pycro_event.get(\"exposure\"),\n        keep_shutter_open=pycro_event.get(\"keep_shutter_open\", False),\n        min_start_time=pycro_event.get(\"min_start_time\"),\n        properties=[tuple(prop) for prop in pycro_event.get(\"properties\", [])],\n        metadata={PYCRO_KEY: pycro_event},  # store original event\n    )\n\n\n# Example usage:\nif __name__ == \"__main__\":\n    from pycromanager import multi_d_acquisition_events\n\n    core = CMMCorePlus.instance()\n    core.loadSystemConfiguration()\n\n    with Acquisition() as acq:\n        # the pymmcore-plus equivalent here is to use MDASequence\n        # https://pymmcore-plus.github.io/pymmcore-plus/guides/mda_engine/\n        events = multi_d_acquisition_events(\n            num_time_points=4,\n            time_interval_s=2,\n            channel_group=\"Channel\",\n            channels=[\"DAPI\", \"FITC\"],\n            z_start=0,\n            z_end=6,\n            z_step=0.4,\n            order=\"tcz\",\n        )\n        acq.acquire(events)\n</code></pre>"},{"location":"guides/custom_engine/","title":"Custom Acquisition Engines","text":"<p>Important</p> <p>This page assumes you have a basic understanding of how the default MDA acquisition engine works to execute a sequence of <code>useq.MDAEvent</code> objects. If you haven't already done so, please read the Acquisition Engine guide first.</p> <p>While the default MDA acquisition engine is sufficient for many common use cases, you may find that you need to customize the acquisition engine to accomplish your goals. Cases where you may need to customize the acquisition engine include:</p> <ul> <li>Driving hardware for which a micro-manager device   adapter does not exist.</li> <li>Conditionally executing arbitrary python code before, during, or after   each acquisition event.</li> <li>Using an alternate high-performance camera   driver</li> <li>Handling user-specific <code>MDAEvent.metadata</code> values.</li> <li> <p>Intercepting and modifying the event sequence<sup>*</sup>.</p> <p><sup>*</sup>Note</p> <p>If all you want to is to modify the event sequence (e.g. to add additional events in a non-deterministic way) but you don't need to modify the behavior of the acquisition engine itself, you likely don't need to customize the acquisition engine. See the guide on Event-Driven Acquisition for details.</p> </li> </ul>"},{"location":"guides/custom_engine/#the-mdarunner-and-mdaengine","title":"The <code>MDARunner</code> and <code>MDAEngine</code>","text":"<p>Let's start by taking a quick look at how the acquisition logic in pymmcore-plus is structured. There are two key classes involved:</p> <ol> <li>An <code>MDARunner</code> instance is    responsible for receiving a sequence of <code>useq.MDAEvent</code> objects and    driving an <code>MDAEngine</code> to execute them. The <code>MDARunner</code> is the object that    has the actual <code>run()</code> method. It also    emits all the events, such as    <code>frameReady</code>. Users shouldn't    need to subclass or modify <code>MDARunner</code> directly.</li> <li>An <code>MDAEngine</code> instance (anything that implements the    <code>PMDAEngine</code> protocol) is responsible for    actually setting up and executing each event in the sequence. The default    implementation of the <code>PMDAEngine</code> protocol is the    <code>MDAEngine</code> class, but you can register    your own custom engine, using either a subclass of the default engine,    or any other object that implements the <code>PMDAEngine</code> protocol.</li> </ol> <pre><code>from pymmcore_plus import CMMCorePlus\n\ncore = CMMCorePlus()\n\ncore.mda          # &lt;- The MDARunner instance\ncore.mda.engine   # &lt;- The MDAEngine instance\n</code></pre>"},{"location":"guides/custom_engine/#the-mdaengine-protocol","title":"The <code>MDAEngine</code> Protocol","text":"<p><code>pymmcore-plus</code> defines a protocol (a.k.a. \"interface\" in the Java world) that all acquisition engines must implement. Formal API docs for the protocol can be found here, but let's discuss the three key methods here.</p> <ol> <li><code>setup_sequence()</code> -    Setup state of system before an MDA is run.</li> <li><code>setup_event()</code> -    Prepare state of system for an event.</li> <li><code>exec_event()</code>    Execute the event.</li> </ol> <p>The <code>PMDAEngine</code> Protocol</p> <pre><code>class MyEngine:\n    def setup_sequence(self, sequence: MDASequence) -&gt; SummaryMetaV1 | None:\n        \"\"\"Setup state of system (hardware, etc.) before an MDA is run.\n\n        This method is called once at the beginning of a sequence.\n        (The sequence object needn't be used here if not necessary)\n        \"\"\"\n\n    def setup_event(self, event: MDAEvent) -&gt; None:\n        \"\"\"Prepare state of system (hardware, etc.) for `event`.\n\n        This method is called before each event in the sequence. It is\n        responsible for preparing the state of the system for the event.\n        The engine should be in a state where it can call `exec_event`\n        without any additional preparation.\n        \"\"\"\n\n    def exec_event(self, event: MDAEvent) -&gt; Iterable[tuple[NDArray, MDAEvent, FrameMetaV1]]:\n        \"\"\"Execute `event`.\n\n        This method is called after `setup_event` and is responsible for\n        executing the event. The default assumption is to acquire an image,\n        but more elaborate events will be possible.\n        \"\"\"\n</code></pre> <p>The following methods are optional, but will be used if they are defined:</p> <ol> <li><code>event_iterator()</code> -    Optional wrapper on the event iterator. To customize the event sequence.</li> <li><code>teardown_event()</code> -    Called after <code>exec_event()</code>. To clean up after an event.</li> <li><code>teardown_sequence()</code>    Called after the sequence is complete. To clean up after an MDA.</li> </ol>"},{"location":"guides/custom_engine/#the-built-in-mdaengine","title":"The built-in <code>MDAEngine</code>","text":"<p>The default implementation of the <code>PMDAEngine</code> protocol is the <code>MDAEngine</code> class. It can handle microscope setup and image acquisition for a standard <code>MDAEvent</code>, and opportunistically queues hardware-triggered sequences. It also serves as a good base class for custom engines if you want to extend the default behavior. (You may also find the source code for the <code>MDAEngine</code> class helpful as a reference when writing a custom engine.)</p>"},{"location":"guides/custom_engine/#customizing-the-mdaengine","title":"Customizing the <code>MDAEngine</code>","text":"<p>If you want to customize how the instrument sets up or executes each event, the easiest approach is to subclass the default <code>MDAEngine</code> class and override or extend the methods you need to customize, then register your custom engine with the runner's <code>set_engine()</code> method.</p> <pre><code>from pymmcore_plus import CMMCorePlus\nfrom pymmcore_plus.mda import MDAEngine\nimport useq\n\nclass MyEngine(MDAEngine): # (1)!\n    def setup_event(self, event: useq.MDAEvent) -&gt; None:\n        \"\"\"Prepare state of system (hardware, etc.) for `event`.\"\"\"\n        # do some custom pre-setup\n        super().setup_event(event)  # (2)!\n        # do some custom post-setup\n\n    def exec_event(self, event: useq.MDAEvent) -&gt; object:\n        \"\"\"Prepare state of system (hardware, etc.) for `event`.\"\"\"\n        # do some custom pre-execution\n        result = super().exec_event(event)  # (3)!\n        # do some custom post-execution\n        return result # (4)!\n\ncore = CMMCorePlus.instance()\ncore.loadSystemConfiguration()\n\n# Register the custom engine with the runner\ncore.mda.set_engine(MyEngine(core))  # (5)!\n\n# Run an MDA\ncore.run_mda([])\n</code></pre> <ol> <li>Create a custom engine by subclassing the default engine</li> <li>Note that it's not required to call the <code>super()</code> method here    if you don't want to</li> <li>Note that it's not required to call the <code>super()</code> method here    if you don't want to</li> <li>If the object returned by <code>exec_event()</code> has an <code>image</code> attribute,    it will be used to emit the <code>frameReady</code> event. A simple implementation    might use a named tuple:    <pre><code>class EventPayload(typing.NamedTuple):\n    image: np.ndarray | None = None\n</code></pre></li> <li>Note that <code>MDAEngine.__init__</code> accepts a <code>CMMCorePlus</code> instance    as its first argument, so you'll need to pass that in when    instantiating your custom engine.</li> </ol>"},{"location":"guides/custom_engine/#utilizing-mdaevent-metadata","title":"Utilizing <code>MDAEvent</code> metadata","text":"<p>More often than not, if you are customizing the acquisition engine, it will be because you'd like to do something other than drive the micro-manager core to set up and acquire an image. Perhaps you need to control a micro-fluidic device, or control a DAQ card, or communicate with a remote server, etc.</p> <p>In all of these cases, you will likely need additional parameters (beyond the fields defined in the <code>MDAEvent</code> class) to pass to your control code. For this, the <code>MDAEvent</code> class has a <code>metadata</code> attribute that is explicitly provided for user-defined data.</p> <pre><code>from pymmcore_plus import CMMCorePlus\nfrom pymmcore_plus.mda import MDAEngine\nimport useq\n\nclass MyEngine(MDAEngine):\n    def setup_event(self, event: useq.MDAEvent) -&gt; None:\n        if 'my_key' in event.metadata:  # (1)!\n            self._my_custom_setup(event.metadata)\n        else:\n            super().setup_event(event)\n\n    def _my_custom_setup(self, metadata: dict) -&gt; None:\n        print(f\"Setting up my custom device with {metadata}\")\n\n    def exec_event(self, event: useq.MDAEvent) -&gt; object:\n        if 'my_key' in event.metadata:\n            return self._my_custom_exec(event.metadata)  # (2)!\n        else:\n            return super().exec_event(event)\n\n    def _my_custom_exec(self, metadata: dict) -&gt; object:\n        print(f\"Executing my custom stuff with {metadata}\")\n\ncore = CMMCorePlus.instance()\ncore.loadSystemConfiguration()\n\ncore.mda.set_engine(MyEngine(core))\n\nexperiment = [\n    useq.MDAEvent(),\n    useq.MDAEvent(metadata={'my_key': {'param1': 'val1'}}),  # (3)!\n    useq.MDAEvent(),\n    useq.MDAEvent(metadata={'my_key': {'param1': 'val2'}}),\n]\n\ncore.run_mda(experiment)\n</code></pre> <ol> <li>You can use any characteristics of the <code>MDAEvent</code>, such as the <code>index</code>, or    the presence of a special key in the <code>metadata</code> attribute, to determine    whether you want to do something special for that event.</li> <li>You don't have to return here. If you also want to do the default image    acquisition, you can call <code>super().exec_event(event)</code> as well.</li> <li>Add metadata to the event. You can do this either by constructing your own    sequence of <code>MDAEvent</code> objects, or by using    <code>MDASequence</code> to build    the sequence for you, then editing the <code>metadata</code> attributes as needed.</li> </ol> <p>Example</p> <p>For a real-world example of an <code>MDAEngine</code> subclass that uses <code>MDAEvent.metadata</code> to drive hardware for Raman spectroscopy, see Ian Hunt-Isaak's raman-mda-engine. (engine subclass here)</p>"},{"location":"guides/event_driven_acquisition/","title":"Event-Driven Acquisition","text":"<p>Important</p> <p>This page assumes you have a basic understanding of how the default MDA acquisition engine works to execute a sequence of <code>useq.MDAEvent</code> objects. If you haven't already done so, please read the Acquisition Engine guide first.</p> <p>You may not always know the exact sequence of events that you want to execute ahead of time. For example, you may want to start acquiring images at a certain frequency, but then take a burst of images at a faster frame rate or in a specific region of interest when a specific (possibly rare) event occurs. This is sometimes referred to as event-driven acquisition, or \"smart-microscopy\".</p> <p>In publications</p> <p>For two compelling examples of this type of event-driven microscopy, see:</p> <ol> <li> <p>Mahecic D, Stepp WL, Zhang C, Griffi\u00e9 J, Weigert M, Manley S. Event-driven acquisition for content-enriched microscopy. Nat Methods 19, 1262\u20131267 (2022). https://doi.org/10.1038/s41592-022-01589-x</p> </li> <li> <p>Shi Y, Tabet JS, Milkie DE, Daugird TA, Yang CQ, Giovannucci A, Legant WR. Smart Lattice Light Sheet Microscopy for imaging rare and complex cellular events. bioRxiv. 2023 Mar 9 https://doi.org/10.1101/2023.03.07.531517.</p> </li> </ol> <p>Obviously, in this case, you can't just create a list of <code>useq.MDAEvent</code> objects and pass them to the acquisition engine, since that list needs to change based on the results of previous events.</p> <p>Fortunately, the <code>MDARunner.run()</code> method is designed to handle this case.</p>"},{"location":"guides/event_driven_acquisition/#iterablemdaevent","title":"<code>Iterable[MDAEvent]</code>","text":"<p>The key thing to observe here is the signature of the <code>MDARunner.run()</code> method:</p> <pre><code>from typing import Iterable\nimport useq\n\nclass MDARunner:\n    def run(self, events: Iterable[useq.MDAEvent]) -&gt; None: ...\n</code></pre> <p> The <code>run</code> method expects an iterable of <code>useq.MDAEvent</code> objects. </p> <p>Iterable</p> <p>An <code>Iterable</code> is any object that implements an <code>__iter__()</code> method that returns an iterator object. This includes sequences of known length, like <code>list</code>, <code>tuple</code>, but also many other types of objects, such as generators, <code>deque</code>, and more. Other types such as <code>Queue</code> can easily be converted to an iterator as well, as we'll see below.</p>"},{"location":"guides/event_driven_acquisition/#useful-iterables","title":"Useful Iterables","text":"<p>Many python objects are iterable. Let's look at a few types of iterables that can be used to implement event-driven acquisition in pymmcore-plus.</p>"},{"location":"guides/event_driven_acquisition/#generators","title":"Generators","text":"<p>Generators are functions that contain <code>yield</code> statements. When called, they return a generator iterator that can be used to iterate over the values yielded by the generator function. </p> <p>Say what?</p> <p>That may sound a bit confusing, but it's actually quite simple.  It just means that you can use the output of a generator function in a for loop:</p> <pre><code>from typing import Iterator\n\n# a generator function, which contains \"yield\" statements\ndef my_generator_func() -&gt; Iterator[int]:\n    yield 1\n    yield 2\n\n# calling the function returns an iterator\ngen_iterator = my_generator_func()\n\n# which we can iterate over (e.g. in a for loop)\nfor value in gen_iterator:\n    print(value)  # prints 1, then 2\n</code></pre> <p>Let's create a generator that yields <code>useq.MDAEvent</code> objects, but simulate a \"burst\" of events when a certain condition is met:</p> <pre><code>import random\nimport time\nfrom typing import Iterator\n\nimport useq\n\ndef some_condition_is_met() -&gt; bool:\n    # Return True 20% of the time ...\n    # Just an example of some probabilistic condition\n    # This could be anything, the results of analysis, etc.\n    return random.random() &lt; 0.2\n\n# generator function that yields events\ndef my_events() -&gt; Iterator[useq.MDAEvent]:\n    i = 0\n    while True:\n        if some_condition_is_met():\n            # yield a burst of events\n            for _ in range(5):\n                yield useq.MDAEvent(metadata={'bursting': True})\n        elif i &gt; 5:\n            # stop after 5 events\n            # (just an example of some stop condition)\n            return\n        else:\n            # yield a regular single event\n            yield useq.MDAEvent()\n\n        # wait a bit before yielding the next event (1)\n        time.sleep(0.1)\n        i += 1\n</code></pre> <ol> <li>Note, we could also take advantage of the <code>min_start_time</code>    field in MDAEvent, but this demonstrates that the generator    can also control the timing of events.</li> </ol> example output of <code>list(my_events())</code> <p>We can use the <code>list()</code> function to iterate over the generator and collect the yielded events:</p> <pre><code>list(my_events())\n</code></pre> <p>Because of the random condition, the output will be different each time, but it might look something like this:</p> <pre><code>[\n    MDAEvent(),\n    MDAEvent(metadata={'bursting': True}),  # (1)!\n    MDAEvent(metadata={'bursting': True}),\n    MDAEvent(metadata={'bursting': True}),\n    MDAEvent(metadata={'bursting': True}),\n    MDAEvent(metadata={'bursting': True}),\n    MDAEvent(),\n    MDAEvent(),\n    MDAEvent(),\n    MDAEvent() # (2)!\n]\n</code></pre> <ol> <li><code>some_condition_is_met</code> returned <code>True</code> on the second iteration,    so the generator yielded a burst of events.</li> <li>Our \"stop condition\" of <code>i &gt; 5</code> was met, so the generator returned    and stopped yielding events.</li> </ol> <p>To run this \"experiment\" using pymmcore-plus, we can pass the output of the generator to the <code>MDARunner.run()</code> method:</p> <pre><code>from pymmcore_plus import CMMCorePlus\n\ncore = CMMCorePlus()\ncore.loadSystemConfiguration()\n\ncore.run_mda(my_events())\n</code></pre>"},{"location":"guides/event_driven_acquisition/#queues","title":"Queues","text":"<p>Python's <code>Queue</code> class is useful for managing and synchronizing data between multiple threads or processes. It ensures orderly execution and prevents race conditions. Generally, a Queue is passed between threads or processes, and one thread or process puts data (such as an <code>MDAEvent</code> to execute) into the queue, while another thread or process gets data out of the queue.</p> <p>A <code>Queue</code> instance itself is not an iterable...</p> <p></p> <pre><code>&gt;&gt;&gt; from queue import Queue\n&gt;&gt;&gt; list(Queue())\nTraceback (most recent call last):\nFile \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: 'Queue' object is not iterable\n</code></pre> <p>however, a <code>Queue</code> can be easily converted to an iterator using the two-argument version of the builtin <code>iter()</code> function:</p> <p></p> <pre><code>&gt;&gt;&gt; from queue import Queue\n&gt;&gt;&gt; q = Queue()\n&gt;&gt;&gt; q.put(1)\n&gt;&gt;&gt; q.put(2)\n&gt;&gt;&gt; q.put('STOP')\n&gt;&gt;&gt; iterable_queue = iter(q.get, 'STOP') # !! (1)\n&gt;&gt;&gt; list(iterable_queue)\n[1, 2]\n</code></pre> <ol> <li> Thanks Kyle Douglass for discovering this handy, if obscure, second argument to <code>iter()</code>!</li> </ol> <p>We can use this <code>iter(queue.get, sentinel)</code> pattern to create a queue-backed iterable that can be passed to the <code>run_mda()</code> method. The acquisition engine will then execute events as they get <code>put</code> into the queue, until the stop sentinel is encountered.</p> <pre><code>from queue import Queue\nfrom pymmcore_plus import CMMCorePlus\nfrom useq import MDAEvent\n\ncore = CMMCorePlus()\ncore.loadSystemConfiguration()\n\nq = Queue()                    # create the queue\nSTOP = object()                # any object can serve as the sentinel\nq_iterator = iter(q.get, STOP) # create the queue-backed iterable\n\n# start the acquisition in a separate thread\ncore.run_mda(q_iterator)\n\n# (optional) connect some callback to the imageReady signal\n@core.mda.events.frameReady.connect\ndef on_frame(img, event):\n    print(f'Frame {event.index} received: {img.shape}')\n\n# now we can put events into the queue\n# according to whatever logic we want:\nq.put(MDAEvent(index={'t': 0}, exposure=20))\nq.put(MDAEvent(index={'t': 1}, exposure=40))\n\n# ... and eventually stop the acquisition\nq.put(STOP)\n</code></pre> More complete event-driven acquisition example <p>The following example is modified from this gist by Kyle Douglass.</p> <p>It simulates a typical event-driven acquisition, where an Analyzer object analyzes the results of each image and provides a dict of results. The Controller object then decides whether to continue or stop the acquisition (by placing the <code>STOP_EVENT</code> sentinel in the queue).</p> event_driven_acquisition.py<pre><code>\"\"\"Simple simulator demonstrating event-driven acquisitions with pymmcore-plus.\"\"\"\n\nimport random\nimport time\nfrom queue import Queue\n\nimport numpy as np\nfrom useq import MDAEvent\n\nfrom pymmcore_plus import CMMCorePlus\n\n\nclass Analyzer:\n    \"\"\"Analyzes images and returns a dict of results.\"\"\"\n\n    def run(self, data) -&gt; dict:\n        # Fake analysis; randomly return a dict with a value of None 10% of the time\n        if random.random() &lt; 0.1:\n            return {\"result\": \"STOP\"}\n        else:\n            return {\"result\": random.random()}\n\n\nclass Controller:\n    STOP_EVENT = object()\n\n    def __init__(self, analyzer: Analyzer, mmc: CMMCorePlus, queue: Queue):\n        self._analyzer = analyzer  # analyzer of images\n        self._queue = queue  # queue of MDAEvents\n        self._results: dict = {}  # results of analysis\n\n        self._mmc = mmc\n        mmc.mda.events.frameReady.connect(self._on_frame_ready)\n\n    def _on_frame_ready(self, img: np.ndarray, event: MDAEvent) -&gt; None:\n        # Analyze the image\n        self._results = self._analyzer.run(img)\n\n    def run(self) -&gt; None:\n        # convert the queue to an iterable\n        queue_sequence = iter(self._queue.get, self.STOP_EVENT)\n\n        # Start the acquisition (run_mda is non-blocking)\n        self._mmc.run_mda(queue_sequence)\n\n        # Queue the first image acquisition\n        self._queue.put(MDAEvent(exposure=10))\n\n        # loop until the analyzer returns \"STOP\"\n        while True:\n            # get the last results from the analyzer\n            result = self._results.pop(\"result\", None)\n\n            # Decide what to do. This is the key part of the reactive loop.\n            if result == \"STOP\":\n                # Do nothing and return\n                print(\"Analyzer returned no results. Stopping...\")\n                self._queue.put(self.STOP_EVENT)\n                break\n            elif result:\n                # Adjust the exposure time based on the results and continue\n                print(\"Analyzer returned results. Continuing...\")\n                next_event = MDAEvent(exposure=10 * result)\n                self._queue.put(next_event)\n            else:\n                # No results yet, wait a bit and check again\n                time.sleep(0.1)\n\n\ndef main():\n    # Setup the MM Core\n    mmc = CMMCorePlus()\n    mmc.loadSystemConfiguration()\n\n    # create the Queue that will hold the MDAEvents\n    q = Queue()\n\n    # Setup the controller and analyzer\n    analyzer = Analyzer()\n    controller = Controller(analyzer, mmc, q)\n\n    # Start the acquisition\n    controller.run()\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"guides/event_driven_acquisition/#mdasequence","title":"MDASequence","text":"<p>It's worth noting that the <code>MDASequence</code> class is itself an <code>Iterable[MDAEvent]</code>. It implements an <code>__iter__</code> method that yields the events in the sequence, and it can be passed directly to the <code>run_mda()</code> method as we saw in the Acquisition engine guide. It is a deterministic sequence, so it wouldn't be used on its own to implement conditional event sequences; it can, however, be used in conjunction with other iterables to implement more complex sequences.</p> <p>Take this simple sequence as an example:</p> <pre><code>my_sequence = useq.MDASequence(\n    time_plan={'loops': 5, 'interval': 0.1},\n    channels=[\"DAPI\", \"FITC\"]\n)\n</code></pre> <p>In the generator example above, we could yield the events in this sequence when the condition is met (saving us from constructing the events manually)</p> <pre><code># example usage in the\ndef my_events() -&gt; Iterator[useq.MDAEvent]:\n    while True:\n        if some_condition_is_met():\n            yield from my_sequence  # yield the events in the sequence\n        else:\n            ...\n</code></pre> <p>In the <code>Queue</code> example above, we could <code>put</code> the events in the sequence into the queue:</p> <pre><code># ... we can put events into the queue\n# according to whatever logic we want:\nfor event in my_sequence:\n    q.put(event)\n</code></pre>"},{"location":"guides/events/","title":"Events and Callbacks","text":"<p>Terminology confusion!</p> <p>A quick warning on terminology: the name \"event\" may refer to two different things in pymmcore-plus, which are not to be confused.</p> <p>This page discusses the \"events\" that are emitted by the <code>CMMCorePlus</code> and <code>MDARunner</code> objects.  These are occurrences that your program can react to by registering callback functions. These are also known as \"signals\" in the context of the Qt framework or psygnal.</p> <p>The term \"event\" may also used to refer to the <code>useq.MDAEvent</code> objects that are consumed by the Acquisition Engine. These are not the same as the \"events\" discussed on this page.</p> <p>Both the <code>CMMCorePlus</code> object and the <code>CMMCorePlus.mda</code> (<code>MDARunner</code>) objects have <code>events</code> attributes that can be used to register callbacks for events that occur as the state of the microscope changes, or as an acquisition sequences progresses.</p>"},{"location":"guides/events/#event-backends","title":"Event backends","text":"<p><code>pymmcore-plus</code> supports both Qt-based and psygnal-based event signaling.</p> <p>The default behavior is to use Qt-backed signals when a global <code>QApplication</code> instance has been created in the main process, and <code>psygnal</code> otherwise.</p> <p>If you would like to force a specific event backend, you can do so by setting the <code>PYMM_SIGNALS_BACKEND</code> environment variable to <code>qt</code>, <code>psygnal</code>, or <code>auto</code> (for the default behavior).</p> bash/zshcmdpythonpowershell <pre><code>export PYMM_SIGNALS_BACKEND=psygnal\n</code></pre> <pre><code>set PYMM_SIGNALS_BACKEND=psygnal\n</code></pre> <pre><code># before instantiating CMMCorePlus\nimport os\nos.environ[\"PYMM_SIGNALS_BACKEND\"] = \"psygnal\"\n</code></pre> <pre><code>$env:PYMM_SIGNALS_BACKEND = \"psygnal\"\n</code></pre>"},{"location":"guides/events/#connecting-callbacks-to-events","title":"Connecting callbacks to events","text":"<p>To connect a callback to an event, use the <code>connect</code> method of specific event emitter that you would like to listen to.  (All event backends support the same connection/disconnection API.)</p> <p>Example: Connecting callbacks</p> <p>Given a <code>CMMCorePlus</code> object <code>core</code>:</p> <pre><code>from pymmcore_plus import CMMCorePlus\n\ncore = CMMCorePlus()\n</code></pre> <p>Register a callback to listen to property changes on the <code>CMMCorePlus</code>:</p> <pre><code>@core.events.propertyChanged.connect\ndef on_property_changed(dev: str, prop: str, value: str):\n    print(f\"Property {prop!r} on device {dev!r} changed to {value}\")\n</code></pre> <p>Register a callback to process data during an acquisition sequence:</p> <pre><code>@core.mda.events.frameReady.connect\ndef on_image_captured(data: np.ndarray, event: useq.MDAEvent, metadata: dict):\n    print(f\"Event index {event.index} captured with shape {data.shape}\")\n</code></pre> <p>The signature of the callback function should match the signature of the event emitter's signal.  See API documentation for the specific event signatures.</p> <p>You may disconnect a callback from an event by calling the <code>disconnect</code> method of the event emitter with the callback function as the argument.</p> <p>Example: Disconnecting callbacks</p> <pre><code>core.events.propertyChanged.disconnect(on_property_changed)\n</code></pre>"},{"location":"guides/ipython_completion/","title":"IPython Tab Completion","text":"<p><code>pymmcore-plus</code> provides an IPython completer that allows you to use tab-completion for methods on the <code>CMMCorePlus</code> object. If you hit <code>&lt;Tab&gt;</code> after the parenthesis of a core method that expects the name of an existing device, you will be presented with suggestions for the names of loaded devices (of the appropriate type).</p> <p></p> <p>You may disable this feature by setting the environment variable <code>PYMM_DISABLE_IPYTHON_COMPLETIONS</code> to <code>1</code> before importing <code>pymmcore_plus</code>.</p>"},{"location":"guides/logging/","title":"Logging","text":"<p>By default, pymmcore-plus logs to the console at the <code>INFO</code> level and to a logfile in the pymmcore-plus application data directory at the <code>DEBUG</code> level. The logfile is named <code>pymmcore_plus.log</code> and is rotated at 40MB, with a maximum retention of 20 logfiles.</p>"},{"location":"guides/logging/#customizing-logging","title":"Customizing logging","text":"<p>The <code>pymmcore_plus.configure_logging</code> function allows you to customize the log level, logfile name, and logfile rotation settings.</p> <p>You may also configure logging using the following environment variables:</p> Variable Default Description PYMM_LOG_LEVEL INFO The log level. PYMM_LOG_FILE <code>pymmcore_plus.log</code> in the pymmcore-plus log directory The logfile location. <p>pymmcore-plus log directory</p> <p>The application data directory is platform-dependent. Here are the log folders for each supported platform:</p> OS Path macOS ~/Library/Application Support/pymmcore-plus/logs Unix ~/.local/share/pymmcore-plus/logs Win C:\\Users\\username\\AppData\\Local\\pymmcore-plus\\pymmcore-plus\\logs <p>You can also use <code>mmcore logs --reveal</code> to open the log directory in your file manager.</p> <p>Note that both pymmcore-plus and the underlying CMMCore object will write to the log file. By default, CMMCorePlus will call <code>setPrimaryLogFile()</code> with the location of the pymmcore-plus logfile upon instantiation.</p>"},{"location":"guides/logging/#managing-logs-with-the-cli","title":"Managing logs with the CLI","text":"<p>The <code>mmcore</code> CLI provides a <code>logs</code> subcommand for managing logs.</p> <pre><code>$ mmcore logs --help\n\u001b[1m                                                                            \u001b[0m\n\u001b[1m \u001b[0m\u001b[1;33mUsage: \u001b[0m\u001b[1mmmcore logs [OPTIONS]\u001b[0m\u001b[1m                                              \u001b[0m\u001b[1m \u001b[0m\n\u001b[1m                                                                            \u001b[0m\n Display recent output from pymmcore-plus log.                              \n\n\u001b[2m\u256d\u2500\u001b[0m\u001b[2m Options \u001b[0m\u001b[2m\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u001b[0m\u001b[2m\u2500\u256e\u001b[0m\n\u001b[2m\u2502\u001b[0m \u001b[1;36m-\u001b[0m\u001b[1;36m-num\u001b[0m     \u001b[1;32m-n\u001b[0m      \u001b[1;33mINTEGER\u001b[0m  Number of lines to display.                   \u001b[2m\u2502\u001b[0m\n\u001b[2m\u2502\u001b[0m \u001b[1;36m-\u001b[0m\u001b[1;36m-tail\u001b[0m    \u001b[1;32m-t\u001b[0m      \u001b[1;33m       \u001b[0m  Continually stream logs.                      \u001b[2m\u2502\u001b[0m\n\u001b[2m\u2502\u001b[0m \u001b[1;36m-\u001b[0m\u001b[1;36m-clear\u001b[0m   \u001b[1;32m-c\u001b[0m      \u001b[1;33m       \u001b[0m  Delete all log files.                         \u001b[2m\u2502\u001b[0m\n\u001b[2m\u2502\u001b[0m \u001b[1;36m-\u001b[0m\u001b[1;36m-reveal\u001b[0m          \u001b[1;33m       \u001b[0m  Reveal log file in Explorer/Finder.           \u001b[2m\u2502\u001b[0m\n\u001b[2m\u2502\u001b[0m \u001b[1;36m-\u001b[0m\u001b[1;36m-help\u001b[0m            \u001b[1;33m       \u001b[0m  Show this message and exit.                   \u001b[2m\u2502\u001b[0m\n\u001b[2m\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\u001b[0m\n</code></pre> <p>A particularly useful command is <code>mmcore logs --tail</code>, which will continually stream the current logfile to the console. This can be started in another process and left running to monitor an experiment in progress.</p> <p>To delete all logfiles, use <code>mmcore logs --clear</code>.</p>"},{"location":"guides/mda_engine/","title":"The Acquisition Engine","text":"<p>One of the key features of pymmcore-plus is the acquisition engine. This allows you to define and execute a sequence of events. The sequence may be a typical multi-dimensional acquisition (MDA), such as a z-stack across multiple channels, stage positions, and time points; or it can be any custom sequence of events that you define. It needn't even be a sequence of known length: you can define an iterable or a <code>queue.Queue</code> of events that reacts to the results of previous events, for event-driven \"smart\" microscopy.</p> <p>The built-in acquisition engine will support many standard use-cases, but you can also subclass and customize it, allowing arbitrary python code to be executed at each step of the acquisition. This makes it possible to incorporate custom hardware control (e.g. to control devices for which micro-manager has no adapters), data analysis, or other logic into the experiment.</p>"},{"location":"guides/mda_engine/#running-a-very-simple-sequence","title":"Running a very simple sequence","text":"<p>To execute a sequence, you must:</p> <ol> <li>Create a <code>CMMCorePlus</code> instance (and probably    load a configuration file)</li> <li>Pass an iterable of <code>useq.MDAEvent</code> objects to the    <code>run_mda()</code> method.</li> </ol> <pre><code>from pymmcore_plus import CMMCorePlus\nfrom useq import MDAEvent\n\n# Create the core instance.\nmmc = CMMCorePlus.instance()  # (1)!\nmmc.loadSystemConfiguration()  # (2)!\n\n# Create a super-simple sequence, with one event\nmda_sequence = [MDAEvent()] # (3)!\n\n# Run it!\nmmc.run_mda(mda_sequence)\n</code></pre> <ol> <li>Here, we use the global    <code>CMMCorePlus.instance</code> singleton.</li> <li>This loads the demo configuration by default. Pass in your own config file.    See    <code>CMMCorePlus.loadSystemConfiguration</code></li> <li>An experiment is just an iterable of <code>useq.MDAEvent</code> objects.</li> </ol> <p>Tip</p> <p><code>CMMCorePlus.run_mda</code> is a convenience method that runs the experiment in a separate thread. If you want to run it in the main thread, use <code>CMMCorePlus.mda.run</code> directly.</p> <pre><code>mmc.mda.run(seq)\n</code></pre> <p>The code above will execute a single, very boring event! It will snap one image (the default action of an <code>MDAEvent</code>) with the current exposure time, channel, stage position, etc... and then stop.</p> <p>Let's make it a little more interesting.</p>"},{"location":"guides/mda_engine/#the-mdaevent-object","title":"The <code>MDAEvent</code> object","text":"<p>The <code>useq.MDAEvent</code> object is the basic building block of an experiment. It is a relatively simple dataclass that defines a single action to be performed. For complete details, see the useq-schema documentation, but some key attributes you might want to set are:</p> <ul> <li>exposure (<code>float</code>): The exposure time (in milliseconds) to use for this   event.</li> <li>channel (<code>str | dict[str, str]</code>): The configuration group to use. If a   <code>dict</code>, it should have two keys: <code>group</code> and <code>config</code> (the configuration group   and preset, respectively). If a <code>str</code>, it is assumed to be the name of a preset in   the <code>Channel</code> group.</li> <li>x_pos, y_pos, z_pos (<code>float</code>): An <code>x</code>, <code>y</code>, and <code>z</code> stage position   to use for this event.</li> <li>min_start_time (<code>float</code>): The minimum time to wait before starting this   event.(in seconds, relative to the start of the experiment)</li> </ul> <p>Example</p> <pre><code>snap_a_dapi = MDAEvent(channel=\"DAPI\", exposure=100, x_pos=1100, y_pos=1240)\n</code></pre> <p>NOTE: The name <code>\"DAPI\"</code> here must be a name of a preset in your micro-manager \"Channel\" configuration group.</p> <p>For any missing keys, the implied meaning is \"use the current setting\". For example, an <code>MDAEvent</code> without an <code>x_pos</code> or a <code>y_pos</code> will use the current stage position.</p> <p>The implied \"action\" of an <code>MDAEvent</code> is to snap an image. But there are ways to customize that, described later.</p>"},{"location":"guides/mda_engine/#a-multi-event-sequence","title":"A multi-event sequence","text":"<p>With our understanding of <code>MDAEvent</code> objects, we can now create a slightly more interesting experiment. This one will snap four images: two channels at two different stage positions.</p> <pre><code>from pymmcore_plus import CMMCorePlus\nfrom useq import MDAEvent\n\n# Create the core instance.\nmmc = CMMCorePlus.instance()\nmmc.loadSystemConfiguration()\n\n# Snap two channels at two positions\nmda_sequence = [\n    MDAEvent(channel={'config': \"DAPI\"}, x_pos=1100, y_pos=1240),\n    MDAEvent(channel={'config': \"FITC\"}, x_pos=1100, y_pos=1240),\n    MDAEvent(channel={'config': \"DAPI\"}, x_pos=1442, y_pos=1099),\n    MDAEvent(channel={'config': \"FITC\"}, x_pos=1442, y_pos=1099),\n]\n\n# Run it!\nmmc.run_mda(mda_sequence)\n</code></pre> <p>Logs</p> <p>If you run the code above, you will see some logs printed to the console that look something like this:</p> <pre><code>2023-08-12 16:37:50,694 - INFO - MDA Started: GeneratorMDASequence()\n2023-08-12 16:37:50,695 - INFO - channel=Channel(config='DAPI') x_pos=1100.0 y_pos=1240.0\n2023-08-12 16:37:50,881 - INFO - channel=Channel(config='FITC') x_pos=1100.0 y_pos=1240.0\n2023-08-12 16:37:50,891 - INFO - channel=Channel(config='DAPI') x_pos=1442.0 y_pos=1099.0\n2023-08-12 16:37:50,947 - INFO - channel=Channel(config='FITC') x_pos=1442.0 y_pos=1099.0\n2023-08-12 16:37:50,958 - INFO - MDA Finished: GeneratorMDASequence()\n</code></pre> <p>See logging for more details on how to configure and review logs.</p> <p>At this point, you might be thinking that constructing a sequence by hand is a little tedious. And you'd be right! That's why we have the <code>MDASequence</code> class.</p>"},{"location":"guides/mda_engine/#building-sequences-with-mdasequence","title":"Building sequences with <code>MDASequence</code>","text":"<p>For most standard multi-dimensional experiments, you will want to use <code>useq.MDASequence</code> to construct your sequence of events. It allows you to declare a \"plan\" for each axis in your experiment (channels, time, z, etc...) along with the order in which the axes should be iterated.</p> <p>See the useq-schema documentation for complete details, but let's look at how <code>MDASequence</code> can be used to create a few common experiments.</p>"},{"location":"guides/mda_engine/#a-two-channel-time-series","title":"A two-channel time series","text":"<pre><code>from useq import MDASequence\n\nmda_sequence = MDASequence(\n    time_plan={\"interval\": 2, \"loops\": 6}, # (1)!\n    channels=[\n        {\"config\": \"DAPI\", \"exposure\": 50},\n        {\"config\": \"FITC\", \"exposure\": 80},\n    ]\n)\n</code></pre> <ol> <li>10 loops, with a 2 second interval between each loop. See also, additional    time-plans.</li> </ol> output of <code>list(mda_sequence)</code> <pre><code>[\n    MDAEvent(index={'t': 0, 'c': 0}, channel=Channel(config='DAPI'), exposure=50.0, min_start_time=0.0),\n    MDAEvent(index={'t': 0, 'c': 1}, channel=Channel(config='FITC'), exposure=80.0, min_start_time=0.0),\n    MDAEvent(index={'t': 1, 'c': 0}, channel=Channel(config='DAPI'), exposure=50.0, min_start_time=2.0),\n    MDAEvent(index={'t': 1, 'c': 1}, channel=Channel(config='FITC'), exposure=80.0, min_start_time=2.0),\n    MDAEvent(index={'t': 2, 'c': 0}, channel=Channel(config='DAPI'), exposure=50.0, min_start_time=4.0),\n    MDAEvent(index={'t': 2, 'c': 1}, channel=Channel(config='FITC'), exposure=80.0, min_start_time=4.0),\n    MDAEvent(index={'t': 3, 'c': 0}, channel=Channel(config='DAPI'), exposure=50.0, min_start_time=6.0),\n    MDAEvent(index={'t': 3, 'c': 1}, channel=Channel(config='FITC'), exposure=80.0, min_start_time=6.0),\n    MDAEvent(index={'t': 4, 'c': 0}, channel=Channel(config='DAPI'), exposure=50.0, min_start_time=8.0),\n    MDAEvent(index={'t': 4, 'c': 1}, channel=Channel(config='FITC'), exposure=80.0, min_start_time=8.0),\n    MDAEvent(index={'t': 5, 'c': 0}, channel=Channel(config='DAPI'), exposure=50.0, min_start_time=10.0),\n    MDAEvent(index={'t': 5, 'c': 1}, channel=Channel(config='FITC'), exposure=80.0, min_start_time=10.0),\n]\n</code></pre>"},{"location":"guides/mda_engine/#a-z-stack-at-three-positions","title":"A Z-stack at three positions","text":"<pre><code>from useq import MDASequence, Position\n\nmda_sequence = MDASequence(\n    z_plan={\"range\": 4, \"step\": 0.5},  # (1)!\n    stage_positions=[  # (2)!\n        (10, 10, 20),\n        {'x': 30, 'y': 40, 'z': 50},\n        Position(x=60, y=70, z=80),\n    ]\n)\n</code></pre> <ol> <li>A 4-micron Z-stack with 0.5 micron steps, ranging around each position. See    also, additional    z-plans.</li> <li>These are all valid ways to specify a stage    position.    None of <code>x</code>, <code>y</code>, or <code>z</code> are required.</li> </ol> output of <code>list(mda_sequence)</code> <pre><code>[\n    MDAEvent(index={'p': 0, 'z': 0}, x_pos=10.0, y_pos=10.0, z_pos=18.0),\n    MDAEvent(index={'p': 0, 'z': 1}, x_pos=10.0, y_pos=10.0, z_pos=18.5),\n    MDAEvent(index={'p': 0, 'z': 2}, x_pos=10.0, y_pos=10.0, z_pos=19.0),\n    MDAEvent(index={'p': 0, 'z': 3}, x_pos=10.0, y_pos=10.0, z_pos=19.5),\n    MDAEvent(index={'p': 0, 'z': 4}, x_pos=10.0, y_pos=10.0, z_pos=20.0),\n    MDAEvent(index={'p': 0, 'z': 5}, x_pos=10.0, y_pos=10.0, z_pos=20.5),\n    MDAEvent(index={'p': 0, 'z': 6}, x_pos=10.0, y_pos=10.0, z_pos=21.0),\n    MDAEvent(index={'p': 0, 'z': 7}, x_pos=10.0, y_pos=10.0, z_pos=21.5),\n    MDAEvent(index={'p': 0, 'z': 8}, x_pos=10.0, y_pos=10.0, z_pos=22.0),\n    MDAEvent(index={'p': 1, 'z': 0}, x_pos=30.0, y_pos=40.0, z_pos=48.0),\n    MDAEvent(index={'p': 1, 'z': 1}, x_pos=30.0, y_pos=40.0, z_pos=48.5),\n    MDAEvent(index={'p': 1, 'z': 2}, x_pos=30.0, y_pos=40.0, z_pos=49.0),\n    MDAEvent(index={'p': 1, 'z': 3}, x_pos=30.0, y_pos=40.0, z_pos=49.5),\n    MDAEvent(index={'p': 1, 'z': 4}, x_pos=30.0, y_pos=40.0, z_pos=50.0),\n    MDAEvent(index={'p': 1, 'z': 5}, x_pos=30.0, y_pos=40.0, z_pos=50.5),\n    MDAEvent(index={'p': 1, 'z': 6}, x_pos=30.0, y_pos=40.0, z_pos=51.0),\n    MDAEvent(index={'p': 1, 'z': 7}, x_pos=30.0, y_pos=40.0, z_pos=51.5),\n    MDAEvent(index={'p': 1, 'z': 8}, x_pos=30.0, y_pos=40.0, z_pos=52.0),\n    MDAEvent(index={'p': 2, 'z': 0}, x_pos=60.0, y_pos=70.0, z_pos=78.0),\n    MDAEvent(index={'p': 2, 'z': 1}, x_pos=60.0, y_pos=70.0, z_pos=78.5),\n    MDAEvent(index={'p': 2, 'z': 2}, x_pos=60.0, y_pos=70.0, z_pos=79.0),\n    MDAEvent(index={'p': 2, 'z': 3}, x_pos=60.0, y_pos=70.0, z_pos=79.5),\n    MDAEvent(index={'p': 2, 'z': 4}, x_pos=60.0, y_pos=70.0, z_pos=80.0),\n    MDAEvent(index={'p': 2, 'z': 5}, x_pos=60.0, y_pos=70.0, z_pos=80.5),\n    MDAEvent(index={'p': 2, 'z': 6}, x_pos=60.0, y_pos=70.0, z_pos=81.0),\n    MDAEvent(index={'p': 2, 'z': 7}, x_pos=60.0, y_pos=70.0, z_pos=81.5),\n    MDAEvent(index={'p': 2, 'z': 8}, x_pos=60.0, y_pos=70.0, z_pos=82.0)\n]\n</code></pre>"},{"location":"guides/mda_engine/#a-grid-of-z-stacks","title":"A grid of Z-stacks","text":"<p>Here we use <code>axis_order</code> to declare that we want the full Z-stack to happen at each <code>(row, col)</code> before moving to the next position in the grid.</p> <pre><code>from useq import MDASequence\n\nmda_sequence = MDASequence(\n    stage_positions=[{'x': 100, 'y': 200, 'z': 300}],\n    grid_plan={\"fov_width\": 20, \"fov_height\": 10, \"rows\": 2, \"columns\": 2},\n    z_plan={\"range\": 10, \"step\": 2.5},\n    axis_order=\"pgz\"  # (1)!\n)\n</code></pre> <ol> <li>The \"fastest\" axes come last. By putting <code>z</code> after <code>g</code> in the <code>axis_order</code>,     we're saying \"at each <code>g</code>, do a full <code>z</code> iteration\".</li> </ol> output of <code>list(mda_sequence)</code> <pre><code>[\n    MDAEvent(index={'p': 0, 'g': 0, 'z': 0}, x_pos=90.0, y_pos=205.0, z_pos=295.0),\n    MDAEvent(index={'p': 0, 'g': 0, 'z': 1}, x_pos=90.0, y_pos=205.0, z_pos=297.5),\n    MDAEvent(index={'p': 0, 'g': 0, 'z': 2}, x_pos=90.0, y_pos=205.0, z_pos=300.0),\n    MDAEvent(index={'p': 0, 'g': 0, 'z': 3}, x_pos=90.0, y_pos=205.0, z_pos=302.5),\n    MDAEvent(index={'p': 0, 'g': 0, 'z': 4}, x_pos=90.0, y_pos=205.0, z_pos=305.0),\n    MDAEvent(index={'p': 0, 'g': 1, 'z': 0}, x_pos=110.0, y_pos=205.0, z_pos=295.0),\n    MDAEvent(index={'p': 0, 'g': 1, 'z': 1}, x_pos=110.0, y_pos=205.0, z_pos=297.5),\n    MDAEvent(index={'p': 0, 'g': 1, 'z': 2}, x_pos=110.0, y_pos=205.0, z_pos=300.0),\n    MDAEvent(index={'p': 0, 'g': 1, 'z': 3}, x_pos=110.0, y_pos=205.0, z_pos=302.5),\n    MDAEvent(index={'p': 0, 'g': 1, 'z': 4}, x_pos=110.0, y_pos=205.0, z_pos=305.0),\n    MDAEvent(index={'p': 0, 'g': 2, 'z': 0}, x_pos=110.0, y_pos=195.0, z_pos=295.0),\n    MDAEvent(index={'p': 0, 'g': 2, 'z': 1}, x_pos=110.0, y_pos=195.0, z_pos=297.5),\n    MDAEvent(index={'p': 0, 'g': 2, 'z': 2}, x_pos=110.0, y_pos=195.0, z_pos=300.0),\n    MDAEvent(index={'p': 0, 'g': 2, 'z': 3}, x_pos=110.0, y_pos=195.0, z_pos=302.5),\n    MDAEvent(index={'p': 0, 'g': 2, 'z': 4}, x_pos=110.0, y_pos=195.0, z_pos=305.0),\n    MDAEvent(index={'p': 0, 'g': 3, 'z': 0}, x_pos=90.0, y_pos=195.0, z_pos=295.0),\n    MDAEvent(index={'p': 0, 'g': 3, 'z': 1}, x_pos=90.0, y_pos=195.0, z_pos=297.5),\n    MDAEvent(index={'p': 0, 'g': 3, 'z': 2}, x_pos=90.0, y_pos=195.0, z_pos=300.0),\n    MDAEvent(index={'p': 0, 'g': 3, 'z': 3}, x_pos=90.0, y_pos=195.0, z_pos=302.5),\n    MDAEvent(index={'p': 0, 'g': 3, 'z': 4}, x_pos=90.0, y_pos=195.0, z_pos=305.0)\n]\n</code></pre>"},{"location":"guides/mda_engine/#skip-timepoints-or-z-stacks","title":"Skip timepoints or Z-stacks","text":"<p>The <code>Channel</code> field has a few tricks, such as skipping timepoints or Z-stacks for specific channels. Here we take a fast Z-stack (leaving the shutter open) in the <code>FITC</code> channel only, and a single image in the <code>DIC</code> channel every 3 timepoints:</p> <pre><code>from useq import MDASequence\n\nmda_sequence = MDASequence(\n    z_plan={\"range\": 10, \"step\": 2.5},\n    time_plan={\"interval\": 2, \"loops\": 6},\n    channels=[\n        \"FITC\",\n        {\"config\": \"DIC\", \"acquire_every\": 3, \"do_stack\": False},\n    ],\n    keep_shutter_open_across=['z'],\n)\n</code></pre> output of <code>list(mda_sequence)</code> <pre><code>[\n    MDAEvent(index={'t': 0, 'c': 0, 'z': 0}, channel='FITC', min_start_time=0.0, z_pos=-5.0, keep_shutter_open=True),\n    MDAEvent(index={'t': 0, 'c': 0, 'z': 1}, channel='FITC', min_start_time=0.0, z_pos=-2.5, keep_shutter_open=True),\n    MDAEvent(index={'t': 0, 'c': 0, 'z': 2}, channel='FITC', min_start_time=0.0, z_pos=0.0, keep_shutter_open=True),\n    MDAEvent(index={'t': 0, 'c': 0, 'z': 3}, channel='FITC', min_start_time=0.0, z_pos=2.5, keep_shutter_open=True),\n    MDAEvent(index={'t': 0, 'c': 0, 'z': 4}, channel='FITC', min_start_time=0.0, z_pos=5.0),\n    MDAEvent(index={'t': 0, 'c': 1, 'z': 2}, channel='DIC', min_start_time=0.0, z_pos=0.0),\n    MDAEvent(index={'t': 1, 'c': 0, 'z': 0}, channel='FITC', min_start_time=2.0, z_pos=-5.0, keep_shutter_open=True),\n    MDAEvent(index={'t': 1, 'c': 0, 'z': 1}, channel='FITC', min_start_time=2.0, z_pos=-2.5, keep_shutter_open=True),\n    MDAEvent(index={'t': 1, 'c': 0, 'z': 2}, channel='FITC', min_start_time=2.0, z_pos=0.0, keep_shutter_open=True),\n    MDAEvent(index={'t': 1, 'c': 0, 'z': 3}, channel='FITC', min_start_time=2.0, z_pos=2.5, keep_shutter_open=True),\n    MDAEvent(index={'t': 1, 'c': 0, 'z': 4}, channel='FITC', min_start_time=2.0, z_pos=5.0),\n    MDAEvent(index={'t': 2, 'c': 0, 'z': 0}, channel='FITC', min_start_time=4.0, z_pos=-5.0, keep_shutter_open=True),\n    MDAEvent(index={'t': 2, 'c': 0, 'z': 1}, channel='FITC', min_start_time=4.0, z_pos=-2.5, keep_shutter_open=True),\n    MDAEvent(index={'t': 2, 'c': 0, 'z': 2}, channel='FITC', min_start_time=4.0, z_pos=0.0, keep_shutter_open=True),\n    MDAEvent(index={'t': 2, 'c': 0, 'z': 3}, channel='FITC', min_start_time=4.0, z_pos=2.5, keep_shutter_open=True),\n    MDAEvent(index={'t': 2, 'c': 0, 'z': 4}, channel='FITC', min_start_time=4.0, z_pos=5.0),\n    MDAEvent(index={'t': 3, 'c': 0, 'z': 0}, channel='FITC', min_start_time=6.0, z_pos=-5.0, keep_shutter_open=True),\n    MDAEvent(index={'t': 3, 'c': 0, 'z': 1}, channel='FITC', min_start_time=6.0, z_pos=-2.5, keep_shutter_open=True),\n    MDAEvent(index={'t': 3, 'c': 0, 'z': 2}, channel='FITC', min_start_time=6.0, z_pos=0.0, keep_shutter_open=True),\n    MDAEvent(index={'t': 3, 'c': 0, 'z': 3}, channel='FITC', min_start_time=6.0, z_pos=2.5, keep_shutter_open=True),\n    MDAEvent(index={'t': 3, 'c': 0, 'z': 4}, channel='FITC', min_start_time=6.0, z_pos=5.0),\n    MDAEvent(index={'t': 3, 'c': 1, 'z': 2}, channel='DIC', min_start_time=6.0, z_pos=0.0),\n    MDAEvent(index={'t': 4, 'c': 0, 'z': 0}, channel='FITC', min_start_time=8.0, z_pos=-5.0, keep_shutter_open=True),\n    MDAEvent(index={'t': 4, 'c': 0, 'z': 1}, channel='FITC', min_start_time=8.0, z_pos=-2.5, keep_shutter_open=True),\n    MDAEvent(index={'t': 4, 'c': 0, 'z': 2}, channel='FITC', min_start_time=8.0, z_pos=0.0, keep_shutter_open=True),\n    MDAEvent(index={'t': 4, 'c': 0, 'z': 3}, channel='FITC', min_start_time=8.0, z_pos=2.5, keep_shutter_open=True),\n    MDAEvent(index={'t': 4, 'c': 0, 'z': 4}, channel='FITC', min_start_time=8.0, z_pos=5.0),\n    MDAEvent(index={'t': 5, 'c': 0, 'z': 0}, channel='FITC', min_start_time=10.0, z_pos=-5.0, keep_shutter_open=True),\n    MDAEvent(index={'t': 5, 'c': 0, 'z': 1}, channel='FITC', min_start_time=10.0, z_pos=-2.5, keep_shutter_open=True),\n    MDAEvent(index={'t': 5, 'c': 0, 'z': 2}, channel='FITC', min_start_time=10.0, z_pos=0.0, keep_shutter_open=True),\n    MDAEvent(index={'t': 5, 'c': 0, 'z': 3}, channel='FITC', min_start_time=10.0, z_pos=2.5, keep_shutter_open=True),\n    MDAEvent(index={'t': 5, 'c': 0, 'z': 4}, channel='FITC', min_start_time=10.0, z_pos=5.0)\n]\n</code></pre>"},{"location":"guides/mda_engine/#a-note-on-syntax","title":"A note on syntax","text":"<p>If you prefer, you can use <code>useq</code> objects rather than <code>dicts</code> for all of these fields. This has the advantage of providing type-checking and auto-completion in your IDE.</p> <p>Example</p> <p>The following two sequences are equivalent:</p> <pre><code>import useq\n\nmda_sequence1 = useq.MDASequence(\n    time_plan={\"interval\": 2, \"loops\": 10},\n    z_plan={\"range\": 4, \"step\": 0.5},\n    channels=[\n        {\"config\": \"DAPI\", \"exposure\": 50},\n        {\"config\": \"FITC\", \"exposure\": 80},\n    ]\n)\n\nmda_sequence2 = useq.MDASequence(\n    time_plan=useq.TIntervalLoops(interval=2, loops=10),\n    z_plan=useq.ZRangeAround(range=4, step=0.5),\n    channels=[\n        useq.Channel(config=\"DAPI\", exposure=50),\n        useq.Channel(config=\"FITC\", exposure=80),\n    ]\n)\n\nassert mda_sequence1 == mda_sequence2\n</code></pre>"},{"location":"guides/mda_engine/#running-an-mda-sequence","title":"Running an MDA sequence","text":"<p>You may have noticed above that we could call <code>list()</code> on an instance of <code>MDASequence</code> to get a list of <code>MDAEvent</code> objects. This means that <code>MDASequence</code> is an iterable of <code>MDAEvent</code>... which is exactly what we need to pass to the <code>run_mda()</code> method.</p> <p>So, you can directly pass an instance of <code>MDASequence</code> to <code>run_mda</code>:</p> <pre><code>from pymmcore_plus import CMMCorePlus\nimport useq\n\nmmc = CMMCorePlus.instance()\nmmc.loadSystemConfiguration()\n\n# create a sequence\nmda_sequence = useq.MDASequence(\n    time_plan={\"interval\": 2, \"loops\": 10},\n    z_plan={\"range\": 4, \"step\": 0.5},\n    channels=[\n        {\"config\": \"DAPI\", \"exposure\": 50},\n        {\"config\": \"FITC\", \"exposure\": 20},\n    ]\n)\n\n# Run it!\nmmc.run_mda(mda_sequence)\n</code></pre>"},{"location":"guides/mda_engine/#handling-acquired-data","title":"Handling acquired data","text":"<p>You will almost certainly want to do something with the data that is collected during an MDA . <code>pymmcore-plus</code> is relatively agnostic about how acquired data is handled. There are currently no built-in methods for saving data to disk in any particular format.</p> <p>This is partially because there are so many good existing ways to store array data to disk in Python, including:</p> <ul> <li>zarr</li> <li>tifffile</li> <li>numpy</li> <li>xarray</li> <li>aicsimageio</li> </ul> <p>You will, however, want to know how to connect callbacks to the <code>frameReady</code> event, so that you can handle incoming data as it is acquired:</p> <pre><code>from pymmcore_plus import CMMCorePlus\nimport numpy as np\nimport useq\n\nmmc = CMMCorePlus.instance()\nmmc.loadSystemConfiguration()\n\n@mmc.mda.events.frameReady.connect # (1)!\ndef on_frame(image: np.ndarray, event: useq.MDAEvent):\n    # do what you want with the data\n    print(\n        f\"received frame: {image.shape}, {image.dtype} \"\n        f\"@ index {event.index}, z={event.z_pos}\"\n    )\n\nmda_sequence = useq.MDASequence(\n    time_plan={\"interval\": 0.5, \"loops\": 10},\n    z_plan={\"range\": 4, \"step\": 0.5},\n)\n\nmmc.run_mda(mda_sequence)\n</code></pre> <ol> <li>The <code>frameReady</code> signal accepts a callback with up to two arguments:    the image data as a numpy array, and the <code>MDAEvent</code> that triggered the callback</li> </ol> <p>See also additional events you may wish to connect to.</p>"},{"location":"guides/mda_engine/#cancelling-or-pausing","title":"Cancelling or Pausing","text":"<p>You can pause or cancel the mda with the <code>CMMCorePlus.mda.toggle_pause</code> or <code>CMMCorePlus.mda.cancel</code> methods.</p> <pre><code>mmc.mda.toggle_pause()  # pauses the mda\nmmc.mda.toggle_pause()  # resumes the mda\n\nmmc.mda.cancel()  # cancels the mda\n</code></pre>"},{"location":"guides/mda_engine/#serializing-mda-sequences","title":"Serializing MDA sequences","text":"<p><code>MDASequence</code> objects can be serialized and deserialized to and from JSON or YAML, making it easy to save and load them from file:</p> <pre><code>import useq\nfrom pathlib import Path\n\nmda_sequence = useq.MDASequence(\n    time_plan={\"interval\": 2, \"loops\": 10},\n    z_plan={\"range\": 4, \"step\": 0.5},\n    channels=[\n        {\"config\": \"DAPI\", \"exposure\": 50, \"do_stack\": False},\n        {\"config\": \"FITC\", \"exposure\": 20},\n    ],\n    axis_order=\"tcz\"\n)\n\nPath(\"mda_sequence.yaml\").write_text(mda_sequence.yaml())\n</code></pre> <p>... results in:</p> mda_sequence.yaml<pre><code>axis_order: tcz\nchannels:\n  - config: DAPI\n    do_stack: false\n    exposure: 50.0\n  - config: FITC\n    exposure: 20.0\ntime_plan:\n  interval: 0:00:02\n  loops: 10\nz_plan:\n  range: 4.0\n  step: 0.5\n</code></pre> <p>... which can be loaded back into a <code>MDASequence</code> object:</p> <pre><code>mda_sequence = useq.MDASequence.from_file(\"mda_sequence.yaml\")\n</code></pre> <p>... or even run directly with the <code>mmcore</code> command line:</p> <pre><code># use --config to specify a config file for your microscope\n$ mmcore run mda_sequence.yaml\n</code></pre>"},{"location":"guides/mda_engine/#hardware-triggered-sequences","title":"Hardware-triggered sequences","text":"<p>Having the computer \"in-the-loop\" for every event in an MDA sequence can add unwanted overhead that limits performance in rapid acquisition sequences. Because of this, some devices support hardware triggering. This means that the computer can tell the device to queue up and start a sequence of events, and the device will take care of executing the sequence without further input from the computer.</p> <p>Just like micro-manager's acquisition engine, the default acquisition engine in <code>pymmcore-plus</code> can opportunistically use hardware triggering whenever possible. This behavior is on by default, but you can disable it by setting <code>CMMCorePlus.mda.engine.use_hardware_sequencing = False</code>, which may be useful for various debugging or testing purposes:</p> <pre><code>from pymmcore_plus import CMMCorePlus\n\nmmc = CMMCorePlus.instance()\nmmc.loadSystemConfiguration()\n\n# enable hardware triggering\n# this is True by default, this is just an example for how to set it\nmmc.mda.engine.use_hardware_sequencing = True\n</code></pre> <p>How does pymmcore-plus know if my device supports hardware triggering?</p> <p>The low-level <code>CMMCore</code> object itself has a number of methods that query whether certain devices are capable of hardware triggering, such as</p> <ul> <li><code>pymmcore.CMMCore.isStageSequenceable</code></li> <li><code>pymmcore.CMMCore.isPropertySequenceable</code></li> <li><code>pymmcore.CMMCore.isXYStageSequenceable</code></li> <li><code>pymmcore.CMMCore.isExposureSequenceable</code></li> </ul> <p>Hint: Many devices that support sequencing have a property (often named <code>Sequence</code> or similar) that can be used to toggle their responses to the above queries, thereby enabling or disabling sequencing.</p> <p>If two <code>MDAEvents</code> in a sequence have different exposure, stage, or other device property values, then <code>pymmcore-plus</code> uses these methods to determine whether the events can be sequenced (see <code>pymmcore_plus.CMMCorePlus.canSequenceEvents</code>). If they can, then the events are grouped together and executed as a single hardware-triggered sequence.</p> <pre><code>from pymmcore_plus import CMMCorePlus\nimport useq\n\nmmc = CMMCorePlus.instance()\n\nmmc.loadSystemConfiguration()\nprint(mmc.canSequenceEvents(useq.MDAEvent(), useq.MDAEvent()))  # True\nprint(mmc.canSequenceEvents(\n    useq.MDAEvent(exposure=50, x_pos=54),\n    useq.MDAEvent(exposure=10, x_pos=40)\n))  # False, unless you have stage and exposure hardware triggering\n</code></pre>"},{"location":"guides/mda_engine/#next-steps","title":"Next steps","text":"<p>Now that you have a basic understanding of how to create and run multi-dimensional acquisition sequences in pymmcore-plus, you may want to take a look at some more advanced features:</p> <ul> <li>customizing the acquisition engine</li> <li>creating non-deterministic sequences for event-driven   acquisition</li> </ul>"},{"location":"guides/unicore/","title":"UniMMCore","text":"<p>Experimental</p> <p>This is an experimental feature, and the API may change in future releases.</p>"},{"location":"guides/unicore/#a-unified-controller-of-c-and-pure-python-devices","title":"A Unified controller of C++ and Pure-Python Devices","text":"<p>The <code>UniMMCore</code> class is a subclass of <code>CMMCorePlus</code> that can control both \"classic\" C++ devices (via the CMMCore) as well pure-Python device adapters. This simplifies the task of controlling new devices using pure-Python code, without the need to write and compile a C++ device adapter.</p>"},{"location":"guides/unicore/#overview","title":"Overview","text":"<p>UniMMCore allows you to seamlessly mix traditional Micro-Manager C++ device adapters with custom Python device implementations. When you call methods like <code>core.setXYPosition()</code> or <code>core.snapImage()</code>, UniMMCore automatically routes the call to the appropriate device implementation (C++ or Python) based on which device is currently active.</p>"},{"location":"guides/unicore/#benefits","title":"Benefits","text":"<ul> <li>Rapid Development: Write device adapters entirely in Python, no C++   compilation required.</li> <li>Integration: Python devices work alongside the more than 250 existing   C++ device adapters.</li> <li>Same API: UniMMCore uses the same <code>CMMCorePlus</code> API and may be used as a   drop-in replacement.</li> <li>Full feature support: Properties and sequences work with Python devices</li> </ul>"},{"location":"guides/unicore/#getting-started","title":"Getting Started","text":""},{"location":"guides/unicore/#basic-usage","title":"Basic Usage","text":"<p>To use UniMMCore, replace <code>CMMCorePlus</code> with <code>UniMMCore</code>:</p> <pre><code>from pymmcore_plus.experimental.unicore import UniMMCore\n\n# Instead of: core = CMMCorePlus()\ncore = UniMMCore()\n\n# Load traditional C++ devices defined in a config file (optional)\ncore.loadSystemConfiguration(...)\n\n# Load Python devices (we'll discuss creating these below)\nfrom my_custom_devices import MyCamera\n\ncore.loadPyDevice(\"MyCamera\", MyCamera())\ncore.initializeDevice(\"MyCamera\")\n\n# Set as the current camera device\ncore.setCameraDevice(\"MyCamera\")\n\n# Use the same API, UniMMCore routes to Python device automatically\ncore.setExposure(100)\nimg = core.snapImage()\n</code></pre>"},{"location":"guides/unicore/#supported-device-types","title":"Supported Device Types","text":"<p>UniMMCore currently supports the following device types for Python implementation:</p> <ul> <li>Common Methods</li> <li>CameraDevice</li> <li>XYStageDevice</li> <li>StateDevice</li> <li>ShutterDevice</li> <li>SLMDevice</li> <li>GenericDevice</li> </ul>"},{"location":"guides/unicore/#common-methods","title":"Common Methods","text":"<p>All device base classes inherit from <code>Device</code>, and may re-implement any of the following methods:</p> <pre><code>from pymmcore_plus.experimental.unicore import Device\n\nclass MyDevice(Device):\n    def initialize(self) -&gt; None:\n        \"\"\"Initialize the device.\n\n        Note: Communication with and initialization of the device should be\n        done here, *not* in `__init__`.\n        \"\"\"\n\n    def shutdown(self) -&gt; None:\n        \"\"\"Called when device is unloaded.\"\"\"\n\n    def busy(self) -&gt; bool:\n        \"\"\"Return `True` if the device is busy. (Returns False by default).\"\"\"\n\n    @classmethod\n    def name(cls) -&gt; str:\n        \"\"\"Return the name of the device.\n\n        By default, the class name is used.  (This is *not* the same as\n        the user-defined label)\n        \"\"\"\n\n    def description(self) -&gt; str:\n        \"\"\"Return a description of the device.\n\n        By default, the class docstring is used.\n        \"\"\"\n</code></pre>"},{"location":"guides/unicore/#camera-devices-cameradevice","title":"Camera Devices (<code>CameraDevice</code>)","text":"<p>For image acquisition devices. Implement the following abstract methods:</p> <pre><code>from pymmcore_plus.experimental.unicore import CameraDevice\nimport numpy as np\n\nclass MyCamera(CameraDevice):\n    def get_exposure(self) -&gt; float:\n        \"\"\"Return current exposure time in milliseconds.\"\"\"\n        pass\n\n    def set_exposure(self, exposure: float) -&gt; None:\n        \"\"\"Set exposure time in milliseconds.\"\"\"\n        pass\n\n    def shape(self) -&gt; tuple[int, ...]:\n        \"\"\"Return (height, width, [channels]) of current image.\"\"\"\n        pass\n\n    def dtype(self) -&gt; np.dtype:\n        \"\"\"Return NumPy dtype of camera images.\"\"\"\n        pass\n\n    def start_sequence(self, n: int | None, get_buffer: Callable) -&gt; Iterator[dict]:\n        \"\"\"Start sequence acquisition yielding metadata dicts.\"\"\"\n        pass\n</code></pre> <p>Warning</p> <p><code>SimpleCameraDevice</code> is not recommended for real hardware cameras: a per-frame <code>snap()</code> prevents SDK-level optimizations like ring buffers and DMA transfers. Use <code>CameraDevice</code> with <code>start_sequence()</code> instead.</p> <p>For simple or simulated cameras, use <code>SimpleCameraDevice</code> instead \u2014 it only requires <code>sensor_shape()</code> and <code>snap()</code>, and provides automatic software ROI:</p> <pre><code>from pymmcore_plus.experimental.unicore import SimpleCameraDevice\n\nclass MySimpleCamera(SimpleCameraDevice):\n    def get_exposure(self) -&gt; float: ...\n    def set_exposure(self, exposure: float) -&gt; None: ...\n\n    def sensor_shape(self) -&gt; tuple[int, ...]:\n        \"\"\"Return (height, width) of the full sensor.\"\"\"\n        ...\n\n    def dtype(self) -&gt; np.dtype: ...\n\n    def snap(self, buffer: np.ndarray) -&gt; dict:\n        \"\"\"Fill the full-frame buffer with image data.\"\"\"\n        ...\n</code></pre>"},{"location":"guides/unicore/#xy-stage-devices-xystagedevice","title":"XY Stage Devices (<code>XYStageDevice</code>)","text":"<p>For controlling 2-axis positioning stages:</p> Position MotorsStepper Motor <pre><code>from pymmcore_plus.experimental.unicore import XYStageDevice\n\nclass MyStage(XYStageDevice):\n    def set_position_um(self, x: float, y: float) -&gt; None:\n        \"\"\"Set stage position in micrometers.\"\"\"\n        pass\n\n    def get_position_um(self) -&gt; tuple[float, float]:\n        \"\"\"Get current stage position in micrometers.\"\"\"\n        pass\n\n    def set_origin_x(self) -&gt; None:\n        \"\"\"Set current X position as origin.\"\"\"\n        pass\n\n    def set_origin_y(self) -&gt; None:\n        \"\"\"Set current Y position as origin.\"\"\"\n        pass\n\n    def stop(self) -&gt; None:\n        \"\"\"Stop stage movement.\"\"\"\n        pass\n\n    def home(self) -&gt; None:\n        \"\"\"Move stage to home position.\"\"\"\n        pass\n</code></pre> <p>For stepper motor stages with sequence support, use <code>XYStepperStageDevice</code>:</p> <pre><code>from pymmcore_plus.experimental.unicore import XYStepperStageDevice\n\nclass MyStepperStage(XYStepperStageDevice):\n    def get_position_steps(self) -&gt; tuple[int, int]:\n        \"\"\"Get position in motor steps.\"\"\"\n        pass\n\n    def set_position_steps(self, x: int, y: int) -&gt; None:\n        \"\"\"Set position in motor steps.\"\"\"\n        pass\n\n    def get_step_size_x_um(self) -&gt; float:\n        \"\"\"Get X-axis step size in micrometers.\"\"\"\n        pass\n\n    def get_step_size_y_um(self) -&gt; float:\n        \"\"\"Get Y-axis step size in micrometers.\"\"\"\n        pass\n\n    # Additional methods for sequence support\n    def get_sequence_max_length(self) -&gt; int:\n        \"\"\"Maximum length of position sequences.\"\"\"\n        pass\n\n    def send_sequence(self, sequence: tuple[tuple[float, float], ...]) -&gt; None:\n        \"\"\"Load sequence of (x, y) positions.\"\"\"\n        pass\n</code></pre>"},{"location":"guides/unicore/#state-devices-statedevice","title":"State Devices (<code>StateDevice</code>)","text":"<p>For devices with discrete states (filter wheels, objective turrets, etc.):</p> <pre><code>from pymmcore_plus.experimental.unicore import StateDevice\n\nclass MyFilterWheel(StateDevice):\n    def set_state(self, pos: int) -&gt; None:\n        \"\"\"Set device to specified state/position.\"\"\"\n        pass\n\n    def get_state(self) -&gt; int:\n        \"\"\"Get current state/position.\"\"\"\n        pass\n</code></pre>"},{"location":"guides/unicore/#shutter-devices-shutterdevice","title":"Shutter Devices (<code>ShutterDevice</code>)","text":"<p>For controlling shutters or any binary open/close devices:</p> <pre><code>from pymmcore_plus.experimental.unicore import ShutterDevice\n\nclass MyShutter(ShutterDevice):\n    def get_open(self) -&gt; bool:\n        \"\"\"Return True if shutter is open.\"\"\"\n        pass\n\n    def set_open(self, open: bool) -&gt; None:\n        \"\"\"Open (True) or close (False) the shutter.\"\"\"\n        pass\n</code></pre>"},{"location":"guides/unicore/#slm-devices-slmdevice","title":"SLM Devices (<code>SLMDevice</code>)","text":"<p>For Spatial Light Modulators:</p> <pre><code>from pymmcore_plus.experimental.unicore import SLMDevice\nimport numpy as np\n\nclass MySLM(SLMDevice):\n    def get_width(self) -&gt; int:\n        \"\"\"Return SLM width in pixels.\"\"\"\n        pass\n\n    def get_height(self) -&gt; int:\n        \"\"\"Return SLM height in pixels.\"\"\"\n        pass\n\n    def get_number_of_components(self) -&gt; int:\n        \"\"\"Return 1 for grayscale, 3 for RGB.\"\"\"\n        pass\n\n    def get_bytes_per_pixel(self) -&gt; int:\n        \"\"\"Return bytes per pixel.\"\"\"\n        pass\n\n    def set_image(self, pixels: np.ndarray) -&gt; None:\n        \"\"\"Set the image to display.\"\"\"\n        pass\n\n    def display_image(self) -&gt; None:\n        \"\"\"Display the currently loaded image.\"\"\"\n        pass\n\n    def get_exposure(self) -&gt; float:\n        \"\"\"Get exposure time in milliseconds.\"\"\"\n        pass\n\n    def set_exposure(self, exposure_ms: float) -&gt; None:\n        \"\"\"Set exposure time in milliseconds.\"\"\"\n        pass\n</code></pre>"},{"location":"guides/unicore/#generic-devices-genericdevice","title":"Generic Devices (<code>GenericDevice</code>)","text":"<p>For devices that don't fit other categories but need property control:</p> <pre><code>from pymmcore_plus.experimental.unicore import GenericDevice\n\nclass MyGenericDevice(GenericDevice):\n    # Only basic Device methods needed - mainly for property-only devices\n    pass\n</code></pre>"},{"location":"guides/unicore/#device-properties","title":"Device Properties","text":"<p>Python devices support the full property system. </p>"},{"location":"guides/unicore/#defining-device-properties","title":"Defining Device Properties","text":"<p>Properties are defined either on the class using the <code>@pymm_property</code> decorator, or dynamically at runtime using <code>Device.register_property</code>.</p> <p>These two methods may be freely mixed, and accept largely the same arguments.</p> <code>@pymm_property</code><code>register_property</code> <pre><code>from pymmcore_plus.experimental.unicore import GenericDevice, pymm_property\n\nclass MyDevice(GenericDevice):\n    _my_prop = 42\n\n    @pymm_property(name=\"MyProp\", default_value=42, limits=(0, 100))\n    def my_prop(self) -&gt; int:\n        \"\"\"MyProp property with limits 0-100 and default 42.\"\"\"\n        return self._my_prop\n\n    @my_prop.setter\n    def my_prop(self, value: int) -&gt; None:\n        self._my_prop = value\n</code></pre> <p>In many cases, you may not know ahead of device initialization which properties are supported. In this case, you can register properties at runtime in <code>initialize()</code>:</p> <pre><code>from pymmcore_plus.experimental.unicore import GenericDevice\n\nclass MyDevice(GenericDevice):\n    def initialize(self) -&gt; None:\n        cls = type(self)\n        self.register_property(\n            name=\"MyProp\",\n            getter=cls._get_my_prop,\n            setter=cls._set_my_prop,\n            default_value=42,\n            limits=(0, 100),\n        )\n\n    def _set_my_prop(self, value: int) -&gt; None:\n        ...\n\n    def _get_my_prop(self) -&gt; int:\n        ...\n</code></pre>"},{"location":"guides/unicore/#properties-with-constraints","title":"Properties with Constraints","text":"<p>Properties may have value constraints such as numerical limits or (categorical) allowed values:</p> <pre><code>class MyStage(XYStageDevice):\n    @pymm_property(limits=(0.0, 100.0))\n    def speed(self) -&gt; float:\n        \"\"\"Stage speed (0-100%).\"\"\"\n        return self._speed\n\n    @pymm_property(allowed_values=[1, 2, 4, 8])\n    def step_size(self) -&gt; int:\n        \"\"\"Step size multiplier.\"\"\"\n        return self._step_size\n</code></pre>"},{"location":"guides/unicore/#sequenceable-properties","title":"Sequenceable Properties","text":"<p>In order to declare a property as \"sequenceable\" (i.e. supporting hardware-synchronized parameter changes), you must:</p> <ol> <li>Define a <code>sequence_max_length</code> of greater than zero.</li> <li>Implement <code>sequence_loader</code> and <code>sequence_starter</code>, (and optionally <code>sequence_stopper</code>)    methods.</li> </ol> <code>@pymm_property</code><code>register_property</code> <pre><code>class MyDevice(GenericDevice):\n    @pymm_property(sequence_max_length=100)\n    def someprop(self) -&gt; float:\n        return self._someprop\n\n    @someprop.setter\n    def set_someprop(self, value: float) -&gt; None:\n        self._someprop = value\n\n    @someprop.sequence_loader\n    def load_someprop_sequence(self, sequence: list[float]) -&gt; None:\n        \"\"\"Load a sequence of someprop values into hardware.\"\"\"\n\n    @someprop.sequence_starter  \n    def start_someprop_sequence(self) -&gt; None:\n        \"\"\"Tell hardware to start the sequence.\"\"\"\n\n    @someprop.sequence_stopper  # optional\n    def stop_someprop_sequence(self) -&gt; None:\n        \"\"\"Tell hardware to stop the sequence.\"\"\"\n</code></pre> <pre><code>class MyDevice(GenericDevice):\n    def initialize(self) -&gt; None:\n        cls = type(self)\n        self.register_property(\n            name=\"someprop\",\n            getter=cls._get_someprop,\n            setter=cls._set_someprop,\n            sequence_loader=cls.load_someprop_sequence,\n            sequence_starter=cls.start_someprop_sequence,\n            sequence_stopper=cls.stop_someprop_sequence,\n            sequence_max_length=100,\n            default_value=10.0,\n            limits=(0.1, 10000.0),\n        )\n\n    def _get_someprop(self) -&gt; float:\n        return self._someprop\n\n    def _set_someprop(self, value: float) -&gt; None:\n        self._someprop = value\n\n    def load_someprop_sequence(self, sequence: list[float]) -&gt; None:\n        \"\"\"Load a sequence of someprop values into hardware.\"\"\"\n\n    def start_someprop_sequence(self) -&gt; None:\n        \"\"\"Tell hardware to start the sequence.\"\"\"\n\n    def stop_someprop_sequence(self) -&gt; None:\n        \"\"\"Tell hardware to stop the sequence.\"\"\"\n</code></pre>"},{"location":"guides/unicore/#property-types-and-validation","title":"Property Types and Validation","text":"<p>Properties are automatically typed based on their return annotations, but you can be explicit:</p> <pre><code>class MyDevice(GenericDevice):\n    @pymm_property(property_type=str)\n    def serial_number(self) -&gt; str:\n        return \"12345\"\n\n    @pymm_property(property_type=int, limits=(1, 1000))\n    def gain(self) -&gt; int:\n        return self._gain\n</code></pre>"},{"location":"guides/unicore/#device-lifecycle","title":"Device Lifecycle","text":"<p>All Python devices follow this lifecycle:</p>"},{"location":"guides/unicore/#1-creation-and-loading","title":"1. Creation and Loading","text":"<pre><code># Create device instance\ndevice = MyCamera()\n\n# Load into core with a label\ncore.loadPyDevice(\"Camera1\", device)\n</code></pre>"},{"location":"guides/unicore/#2-initialization","title":"2. Initialization","text":"<pre><code># Initialize the device (calls device.initialize())\ncore.initializeDevice(\"Camera1\")\n</code></pre> <p>Override <code>initialize()</code> for device-specific setup:</p> <pre><code>class MyCamera(CameraDevice):\n    def initialize(self) -&gt; None:\n        \"\"\"Called when device is initialized.\"\"\"\n        # Setup hardware connections, configure device, etc.\n        self.connect_to_hardware()\n        super().initialize()  # Call parent if needed\n</code></pre>"},{"location":"guides/unicore/#3-usage","title":"3. Usage","text":"<p>Once loaded and initialized, use the device through the standard CMMCore API:</p> <pre><code># Set as current device\ncore.setCameraDevice(\"Camera1\") \n\n# Use standard API\ncore.setExposure(50)\nimage = core.snapImage()\n</code></pre>"},{"location":"guides/unicore/#4-shutdown","title":"4. Shutdown","text":"<pre><code># Shutdown specific device\ncore.unloadDevice(\"Camera1\")\n\n# Or shutdown all devices  \ncore.unloadAllDevices()\n</code></pre> <p>Override <code>shutdown()</code> for cleanup:</p> <pre><code>class MyCamera(CameraDevice):\n    def shutdown(self) -&gt; None:\n        \"\"\"Called when device is unloaded.\"\"\"\n        self.disconnect_from_hardware()\n        super().shutdown()\n</code></pre>"},{"location":"guides/unicore/#thread-safety","title":"Thread Safety","text":"<p>Python devices are automatically made thread-safe using locks. All device methods are called with the device locked to prevent concurrent access.</p> <p>If you need manual locking:</p> <pre><code>device = MyCamera()\ncore.loadPyDevice(\"Camera\", device)\n\n# Manual locking\nwith device:\n    # Device is locked for this block\n    device.some_internal_method()\n</code></pre>"},{"location":"guides/unicore/#events-and-metadata","title":"Events and Metadata","text":"<p>Python devices work seamlessly with the event system:</p> <pre><code>@core.events.propertyChanged.connect\ndef on_property_changed(device, prop, value):\n    print(f\"{device}.{prop} = {value}\")\n\n# This will emit the event\ncore.setProperty(\"Camera1\", \"Exposure\", 100)\n</code></pre> <p>Sequence acquisitions include metadata just as C++ camera adapters do</p> <pre><code>core.startSequenceAcquisition(10)\nwhile core.getRemainingImageCount() &gt; 0:\n    img, metadata = core.getLastImageAndMD()\n    print(f\"Image {metadata['ImageNumber']} timestamp: {metadata['ElapsedTime-ms']}\")\n</code></pre>"},{"location":"guides/unicore/#error-handling","title":"Error Handling","text":"<p>Python devices can raise exceptions which are converted to appropriate Micro-Manager errors:</p> <pre><code>class MyCamera(CameraDevice):\n    def set_exposure(self, exposure: float) -&gt; None:\n        if exposure &lt; 0:\n            raise ValueError(\"Exposure must be positive\")\n        if exposure &gt; 10000:\n            raise ValueError(\"Exposure too long\")\n        self._exposure = exposure\n</code></pre> <pre><code># This will raise a RuntimeError (converted from ValueError)\ncore.setExposure(-5)\n</code></pre>"},{"location":"guides/unicore/#complete-examples","title":"Complete Examples","text":"<p>See the <code>examples/</code> directory for complete working examples:</p> <ul> <li><code>examples/unicore_camera.py</code> - Synthetic camera with temporal patterns</li> <li><code>examples/unicore_hamamatsu.py</code> - Real Hamamatsu camera integration</li> <li><code>examples/unicore.py</code> - Basic XY stage with properties</li> </ul> <p>These examples demonstrate real-world usage patterns and best practices for implementing Python device adapters with UniMMCore.</p>"}]}